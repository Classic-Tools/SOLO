                                   ;"KERNELTEXT1"
.TITLE	KERNEL FOR CONCURRENT PASCAL
.SBTTL	EDIT HISTORY
;
;<01>	10-APR-79	S. WILLIAMS
;
;	THIS CODE MODIFIED TO RUN BAREFOOT ON PDP-11/34 WITHOUT I/D SPACE
;	SEPARATION, TWO REGISTER SETS, OR FLOATING POINT HARDWARE.
;
;	ALSO ADDED ABILITY TO BOOT FROM ANY RK05 UNIT ...
;
;
;
;
;	SPL MACRO TO SIMULATE PDP-11/45 "SPL" INSTRUCTION
;
	.MACRO	SPL	PL
	.IF	EQ,PL
	CLR	@#PSW
	.IFF
	MOV	#PL*40,@#PSW
	.ENDC
	.ENDM	SPL

;
;
;	MACRO TO PUSH STUFF ON STACK
;
;
	.MACRO	PUSH	LIST
	.IRP	X,<LIST>
	MOV	X,-(SP)
	.ENDR
	.ENDM	PUSH
;
;	MACRO TO UNDO A PUSH
;
	.MACRO	POP	LIST
	.IRP	X,<LIST>
	MOV	(SP)+,X
	.ENDR
	.ENDM	POP
;
;	FAKE OUT THE MTPD AND MFPD INSTRUCTIONS FOR 11/40 AND 11/35
;
	.MACRO	MTPD	X
	MTPI	X
	.ENDM	MTPD
;
	.MACRO	MFPD	X
	MFPI	X
	.ENDM	MFPD

	.IF	NDF, F$PU	;USED BY SW FLOATING POINT
;
;	GET PSW INTO REGISTER 0
;
	.MACRO	GETPSW	X
	EMT	0		;FETCH PSW INTO R0
	MOV	R0,X		;MOV TO DESTINATION
	.ENDM	GETPSW

	.ENDC			;F$PU

;
;
;	MACRO TO SET UP COMMON INTERRUPT ENTRY CODE
;
;
	.MACRO	INTSRV	R	;R -> SERVICE ROUTINE
	PUSH	<R5,R4,R3,R2,R1,R0> ;SAVE REGS
	.IF	NB,R
	PUSH	#KNEXIT		;FAKE
	JMP	@#R		;	JSR
	.ENDC
	.ENDM	INTSRV
.SBTTL	FLOATING POINT SUPPORT
;
;
;<01>	THIS SECTION ADDED BY EDIT <01>
;
;
;	IF AN FPU-11 IS NOT AVAILABLE, LEAVE ASSEMBLY-TIME VARIABLE "F$PU"
;	UNDEFINED, AND A SET OF SOFTWARE ROUTINES WILL BE INCLUDED AT 
;	ASSEMBLY TIME.
;
;	ADDITIONAL SIZE: APP 1K(W).
;
;F$PU	=	1			;<01>	DEFINE FOR FPU SUPPORT

.IF	NDF,F$PU			;<01>	INCLUDE SW ROUTINES ONLY IF
					;<01>	NO FPU

.GLOBL	$ADD				;<01>	DOUBLE FLOATING ADD
.GLOBL	$SBD				;<01>	DOUBLE FLOATING SUBTRACT
.GLOBL	$MLD				;<01>	DOUBLE FLOATING MULTIPLY
.GLOBL	$DVD				;<01>	DOUBLE FLOATING DIVIDE
.GLOBL	$DCMP				;<01>	DOUBLE FLOATING COMPARE
.GLOBL	$ID				;<01>	CONVERT INTEGER -> DOUBLE
.GLOBL	$DI				;<01>	CONVERT DOUBLE  -> INTEGER
.GLOBL	OVERFL				;<01>	OVERFLOW EXIT POINT


.ENDC					;<01>
                        ;****  ASSEMBLY OPTIONS  ****
                        ;*
                        ;*
                        ;*
                                .SBTTL ASSEMBLY OPTIONS
                        ;*
                        ;*
                        ;*
        .NLIST TTM;                    NEGATE CONSOLE MODE
;*
;*
;*
        .DSABL GBL;                    NO GLOBALS
;*
;*
;*
;<01>	.ENABL CDR;                    IGNORE CARD SERIALIZATION
	.ENABL AMA		;<01>  USE ABSOLUTE ADDRESSING IN KERNEL ONLY!
;*
;*
;*
;*
;*      THE RSX11M KERNEL BUILDER REQUIRES A RELOCATABLE
;*      ASSEMBLY.  THEREFORE, THE FOLLOWING
;*      ASECT IS CONVERTED INTO A COMMENT.
       .ASECT ;<01>	RE-CONVERT FOR RT-11
	. = 0 ;<01>	SET UP FOR 0 BASE ADDR.
;*
;*
;*
        .PAGE
        .SBTTL PROGRAMMER IDENTIFICATION

;****  A DECLARATION OF RESPONSIBILITY  *****
;*
;*
;**************
;*
;*      THE DESIGN OF THIS KERNEL FOR CONCURRENT PASCAL IS BY
;*
;*             PER BRINCH HANSEN;
;*
;*      THE HIGH LEVEL ENCODING IS BY
;*
;*             PER BRINCH HANSEN,
;*             ROBERT S. DEVERILL;
;*
;*      THE ASSEMBLER LEVEL ENCODING IS BY
;*
;*             ROBERT S. DEVERILL:_
;*
;*      BOTH OF WHOM ARE OF
;*
;*             INFORMATION SCIENCE
;*             ENGINEERING DIVISION
;*             CALIFORNIA INSTITUTE OF TECHNOLOGY
;*             PASADENA CALIFORNIA.
;*
;**************
;*
;*      THE DATE OF THIS CURRENT VERSION IS 9 JUNE 1975.
;*
;*      THE ORIGINAL VERSION WAS WRITTEN BY 10 DEC 1974.
;*
;*
;********************************************
        .PAGE
        .SBTTL PROCESSOR REGISTER NAMES

;****  REGISTER NAMES  *****
;*
;*
;*      THE REGISTER NAMES WHICH ARE USED IN MOST OF THIS MODULE ARE THE
;*      NAMES SUPPLIED BY THE ASSEMBLER, TO WIT:
;*
R0      =      %0;
R1      =      %1;
R2      =      %2;
R3      =      %3;
R4      =      %4;
R5      =      %5;
SP      =      %6;
PC      =      %7;
;*
;*
;*      WE WILL REFER TO THE REGISTERS BY THEIR CONVENTIONAL PASCAL
;*      NAMES ONLY ON THE RARE OCCASIONS WHEN THIS IS RELEVANT.  THE
;*      PASCAL NAMES ARE:
;*
W       =      R0;                     WORD OR REAL SCRATCH REGISTER 0,
X       =      R1;                     WORD OR REAL SCRATCH REGISTER 1,
Y       =      R2;                     WORD SCRATCH REGISTER 2,
Q       =      R3;                     USER CODE POINTER,
B       =      R4;                     USER LOCAL BASE REGISTER,
G       =      R5;                     USER GLOBAL BASE REGISTER,
S       =      SP;                     PROCESSOR STACK TOP REGISTER,
P       =      PC;                     PROCESSOR PROGRAM COUNTER.
;*
;*      BLOCK NUMBER FOR PROCESSOR INTERNAL REGISTERS
;*
.PRBLK  =      7600;                   BLOCK NUMBER OF THE HARDWARE
;*                                     PERIPHERALS AND REGISTERS AREA
;*
;*      PROCESSOR INTERNAL REGISTERS
;*
PSW     =      177776;                 PROCESSOR STATUS WORD
SLR     =      177774;                 STACK LIMIT REGISTER
CSDR    =      177570;                 CONSOLE SWITCH AND DISPLAY REG
LKS     =      177546;                 KW11-L LINE FREQUENCY CLOCK
;*
;*             BIT DEFINITIONS FOR LKS
;*
;*      =      ^B1111111100000000;     8 BITS - NOT USED
LKSMON  =      ^B0000000010000000;     FREQUENCY MONITOR BIT
LKSINE  =      ^B0000000001000000;     ENABLE INTERRUPT MODE
;*      =      ^B0000000000111111;     6 BITS - NOT USED
;*
;*
        .PAGE
        .SBTTL MACHINE CORE PARAMETERS

;****  MACHINE CORE SIZE PARAMETERS  *****
;*
;*
.BLKSW  =      32.;                    SIZE OF SEGMENTATION BLOCK, WORDS
.BLKSB  =      .BLKSW * 2.;            SIZE OF SEGMENTATION BLOCK, BYTES
.KWSBK  =      1024. / .BLKSW;         SIZE OF A KILOWORD IN BLOCKS
;*
;*
.SEGSW  =      4096.;                  SEGMENT SIZE IN WORDS
.SEGSB  =      .SEGSW * 2.;            SEGMENT SIZE IN BYTES
.SGSBK  =      .SEGSW / .BLKSW;        SEGMENT SIZE IN BLOCKS
;*
;****  MEMORY SEGMENTATION REGISTERS  *****
;*
SSR0    =      177572;                 SEGMENT STATUS REGISTER 0
;*
;*
UISDR   =      177600;                 USER INSTR DESCR REGS 0-7
UDSDR   =      177620;                 USER DATA DESCR REGS 0-7
UISAR   =      177640;                 USER INSTR ADDR REGS 0-7
UDSAR   =      177660;                 USER DATA ADDR REGS 0-7
;*
;*
SISDR   =      172200;                 SUPERVISOR INSTR DESCR REGS 0-7
SDSDR   =      172220;                 SUPERVISOR DATA DESCR REGS 0-7
SISAR   =      172240;                 SUPERVISOR INSTR ADDR REGS 0-7
SDSAR   =      172260;                 SUPERVISOR DATA ADDR REGS 0-7
;*
;*
KISDR   =      172300;                 KERNEL INSTR DESCR REGS 0-7
KDSDR   =      172320;                 KERNEL DATA DESCR REGS 0-7
KISAR   =      172340;                 KERNEL INSTR ADDR REGS 0-7
KDSAR   =      172360;                 KERNEL DATA ADDR REGS 0-7
;*
;*
        .PAGE
;****  SEGMENT DESCRIPTOR REGISTER DEFINITIONS  *****
;*
;*      THE SDR FIELDS ARE DECLARED BY GIVING THEIR RIGHTMOST BITS:
;*
SDRACF  =      ^B0000000000000001;     3 BITS - ACCESS CONTROL FIELD
SDRED   =      ^B0000000000001000;     1 BIT  - EXPANSION DIRECTION
;*      =      ^B0000000000110000;     2 BITS - NOT USED
SDRWR   =      ^B0000000001000000;     1 BIT  - WRITE TO SEGMENT
SDRAT   =      ^B0000000010000000;     1 BIT  - ACCESS TRAPPED
SDRPLF  =      ^B0000000100000000;     7 BITS - SEGMENT LENGTH
;*      =      ^B1000000000000000;     1 BIT  - NOT USED
;*
;*      ACCESS CONTROL FIELD BITS
;*
SDRAWA  =      ^B000;                  READ ABORT, WRITE ABORT
SDRTWA  =      ^B001;                  READ TRAP , WRITE ABORT
SDRNWA  =      ^B010;                  READ      , WRITE ABORT
SDRTWT  =      ^B100;                  READ TRAP , WRITE TRAP
SDRNWT  =      ^B101;                  READ      , WRITE TRAP
SDRNWN  =      ^B110;                  READ      , WRITE
;*
;*      THE EXPANSION DIRECTION BIT
;*
SDREDU  =      0;                      SEGMENT EXPANDS UP
SDREDD  =      1;                      SEGMENT EXPANDS DOWN
;*
;*      MACRO TO DEFINE SEGMENT DESCRIPTOR REGISTER CONTENTS
;*
        .MACRO SDRDEF NAME,AC,ED,PL
     $1 =      SDRACF * AC;
     $2 =      SDRED * ED + <SDRPLF * <129. * ED - 1>>;
     $3 =      SDRPLF * <1 - <2 * ED>> * PL;
NAME    =      $1 + $2 + $3;
        .ENDM  SDRDEF
;*
;*             DEFINE THE USER SDR VALUE:
;*
;*                                     ALLOW READ AND WRITE,
;*                                     EXPANSION DIRECTION UP,
;*                                     128 BLOCKS.
;*
        SDRDEF USDR,SDRNWN,SDREDU,.SGSBK;
;*
;*             DEFINE THE KERNEL SDR VALUE:
;*
;*                                     ALLOW READ AND WRITE,
;*                                     EXPANSION DIRECTION UP,
;*                                     128 BLOCKS.
;*
KSDR    =      USDR;
;*
;*
        .PAGE
        .SBTTL PSW DEFINITIONS

;****  PROCESSOR STATUS WORD FORMAT  *****
;*
;*      THE PSW FIELDS ARE DECLARED BY GIVING THEIR RIGHTMOST BITS:
;*
PSCBIT  =      ^B0000000000000001;     1 BIT  - CARRY
PSVBIT  =      ^B0000000000000010;     1 BIT  - OVERFLOW
PSZBIT  =      ^B0000000000000100;     1 BIT  - RESULT = 0
PSNBIT  =      ^B0000000000001000;     1 BIT  - RESULT < 0
PSTBIT  =      ^B0000000000010000;     1 BIT  - TRAP SET
PSPRTY  =      ^B0000000000100000;     3 BITS - PRIORITY
;*      =      ^B0000011100000000;     3 BITS - NOT USED
PSPMOD  =      ^B0001000000000000;     2 BITS - PREVIOUS MODE
PSCMOD  =      ^B0100000000000000;     2 BITS - CURRENT MODE
;*
;*      THE RELEVANT FIELD VALUES ARE:
;*
PSCARR  =      PSCBIT * 1;             CARRY = TRUE
PSOVER  =      PSVBIT * 1;             OVERFLOW = TRUE
PSZERO  =      PSZBIT * 1;             RESULT ZERO = TRUE
PSNEGA  =      PSNBIT * 1;             RESULT NEGATIVE = TRUE
PSTTRP  =      PSTBIT * 1;             T-BIT TRAP IS SET
PSPRT7  =      PSPRTY * 7;             PROCESSOR PRIORITY = 7
PSPRT6  =      PSPRTY * 6;             PROCESSOR PRIORITY = 6
PSPRT5  =      PSPRTY * 5;             PROCESSOR PRIORITY = 5
PSPRT4  =      PSPRTY * 4;             PROCESSOR PRIORITY = 4
PSPRT3  =      PSPRTY * 3;             PROCESSOR PRIORITY = 3
PSPRT2  =      PSPRTY * 2;             PROCESSOR PRIORITY = 2
PSPRT1  =      PSPRTY * 1;             PROCESSOR PRIORITY = 1
PSPRT0  =      PSPRTY * 0;             PROCESSOR PRIORITY = 0
PSPMDK  =      PSPMOD * KRNLMD;        PREVIOUS MODE = KERNEL
PSPMDS  =      PSPMOD * SPVRMD;        PREVIOUS MODE = SUPERVISOR
PSPMDU  =      PSPMOD * USERMD;        PREVIOUS MODE = USER
PSCMDK  =      PSCMOD * KRNLMD;        CURRENT MODE = KERNEL
PSCMDS  =      PSCMOD * SPVRMD;        CURRENT MODE = SUPERVISOR
PSCMDU  =      PSCMOD * USERMD;        CURRENT MODE = USER
;*
;*      WHERE
;*
KRNLMD  =      ^B00;                   KERNEL MODE
SPVRMD  =      ^B01;                   SUPERVISOR MODE
USERMD  =      ^B11;                   USER MODE
;*
;*             DEFINE THE KERNEL PROCESSOR STATUS WORD
;*
KNLPSW  =      PSCMDK+PSPRT7	   ;<01>   KERNEL MODE,
                                   ;   REGISTER SET 0,
                                   ;   PROCESSOR PRIORITY 7
;*
;*             DEFINE THE USER PROCESSOR STATUS WORD
;*
USRPSW  =      PSCMDU+PSPRT0	   ;<01>   USER MODE,
USRPSW  =      USRPSW+PSPMDU       ;   REGISTER SET 1,
                                   ;   PROCESSOR PRIORITY 0
;*
;*
        .PAGE
        .SBTTL FLOATING POINT PROCESSOR DEFINITIONS

;****  FLOATING POINT UNIT STATUS REGISTER FORMAT  *****
;*
;*
;*             BIT DEFINITIONS FOR THE FPS REGISTER
;*
FPSFER  =      ^B1000000000000000;     FLOATING POINT ERROR
FPSFID  =      ^B0100000000000000;     FPP INTERRUPTS DISABLED
;*      =      ^B0011000000000000;     2 BITS - NOT USED
FPSIUV  =      ^B0000100000000000;     UNDEF. VARIABLE INT. ENABLED
FPSFIU  =      ^B0000010000000000;     UNDERFLOW INT. ENABLED
FPSFIV  =      ^B0000001000000000;     OVERFLOW INT. ENABLED
FPSFIC  =      ^B0000000100000000;     INTEGER CONVERSION INT. ENABLED
FPSFD   =      ^B0000000010000000;     DOUBLE PRECISION MODE
FPSFL   =      ^B0000000001000000;     LONG INTEGER MODE
FPSFT   =      ^B0000000000100000;     TRUNCATE MODE
FPSFMM  =      ^B0000000000010000;     MAINTENANCE MODE
FPSFN   =      ^B0000000000001000;     RESULT NEGATIVE
FPSFZ   =      ^B0000000000000100;     RESULT ZERO
FPSFV   =      ^B0000000000000010;     RESULT OVERFLOW
FPSFC   =      ^B0000000000000001;     CONVERSION CARRY
;*
;*             DEFINE THE INITIAL USER FLOATING POINT STATUS
;*
FSTAT0  =      FPSIUV+FPSFIU+FPSFIV+FPSFIC+FPSFD; UNDEF. VAR. INT.,
                                                ; UNDERFLOW INT.,
                                                ; OVERFLOW INT.,
                                                ; INTEGER CONV INT.,
                                                ; DOUBLE PRECISION,
                                                ; SHORT INTEGER,
                                                ; ROUNDED ARITHMETIC
;*
;*             CODE DEFINITIONS FOR THE FEC REGISTER
;*
FECOPC  =      2.;                     OPCODE ERROR
FECDVZ  =      4.;                     DIVIDE CHECK
FECICE  =      6.;                     INTEGER CONVERSION ERROR
FECOVF  =      8.;                     OVERFLOW
FECUNF  =      10.;                    UNDERFLOW
FECUDV  =      12.;                    UNDEFINED VARIABLE
FECMTT  =      14.;                    MAINTENANCE TRAP
;*
;*
        .PAGE
        .SBTTL TM11 TAPE DEFINITIONS

;****  TM11 TAPE HARDWARE REGISTERS  *****
;*
;*             ADDRESSES OF THE HARDWARE REGISTERS
;*
MTS     =      172520;                 STATUS REGISTER
MTC     =      172522;                 COMMAND REGISTER
MTBRC   =      172524;                 BYTE/RECORD COUNTER
MTCMA   =      172526;                 CURRENT MEMORY ADDRESS REGISTER
MTD     =      172530;                 DATA BUFFER
;*
;*             BIT DEFINITIONS FOR THE STATUS REGISTER
;*
MTSTUR  =      ^B0000000000000001;     TAPE UNIT READY
MTSRWS  =      ^B0000000000000010;     REWIND STATUS
MTSWRL  =      ^B0000000000000100;     WRITE LOCK (FILE PROTECT)
MTSDWN  =      ^B0000000000001000;     TAPE SETTLE DOWN
MTS7CH  =      ^B0000000000010000;     SEVEN CHANNEL
MTSBOT  =      ^B0000000000100000;     BEGINNING OF TAPE
MTSELR  =      ^B0000000001000000;     SELECT REMOTE
MTSNXM  =      ^B0000000010000000;     NONEXISTENT MEMORY
MTSBTE  =      ^B0000000100000000;     BAD TAPE ERROR
MTSRLE  =      ^B0000001000000000;     RECORD LENGTH ERROR
MTSEOT  =      ^B0000010000000000;     END OF TAPE
MTSBGL  =      ^B0000100000000000;     BUS GRANT LATE
MTSPAE  =      ^B0001000000000000;     PARITY ERROR
MTSCRE  =      ^B0010000000000000;     CYCLIC REDUNDANCY ERROR
MTSEOF  =      ^B0100000000000000;     END OF FILE
MTSILC  =      ^B1000000000000000;     ILLEGAL COMMAND
;*
;*             BIT AND FIELD DEFINITIONS FOR THE COMMAND REGISTER
;*
;*      FIELDS ARE DECLARED BY GIVING THEIR RIGHTMOST BITS:
;*
MTCGO   =      ^B0000000000000001;     1 BIT  - BEGIN OPERATION
MTCFUN  =      ^B0000000000000010;     3 BITS - FUNCTION FIELD
MTCADD  =      ^B0000000000010000;     2 BITS - ADDRESS EXTENSION
MTCIEN  =      ^B0000000001000000;     1 BIT  - INTERRUPT ENABLE
MTCCUR  =      ^B0000000010000000;     1 BIT  - CU READY
MTCUS   =      ^B0000000100000000;     3 BITS - UNIT SELECT
MTCPEV  =      ^B0000100000000000;     1 BIT  - LATERAL PARITY (EVEN)
MTCPCL  =      ^B0001000000000000;     1 BIT  - POWER CLEAR
MTCDEN  =      ^B0010000000000000;     2 BITS - DENSITY
MTCERR  =      ^B1000000000000000;     1 BIT  - HARD ERROR
;*
;*      FIELD VALUE DEFINITIONS FOR MTCFUN ARE:__
;*
MTFOFL  =      ^B000;                  OFFLINE
MTFRD   =      ^B001;                  READ
MTFWR   =      ^B010;                  WRITE
MTFWFM  =      ^B011;                  WRITE EOF
MTFSPF  =      ^B100;                  SPACE FORWARD
MTFSPR  =      ^B101;                  SPACE REVERSE
MTFWGP  =      ^B110;                  WRITE GAP
MTFREW  =      ^B111;                  REWIND
;*
;*      FIELD VALUE DEFINITIONS FOR MTCDEN ARE:__
;*
MDS200  =      ^B00;                   SEVEN TRACK, 200 BPI
MDS556  =      ^B01;                   SEVEN TRACK, 556 BPI
MDS800  =      ^B10;                   SEVEN TRACK, 800 BPI
MDN800  =      ^B11;                   NINE TRACK, 800 BPI
;*
;*
        .PAGE
        .SBTTL RK11 DISK DEFINITIONS

;****  RK11 HARDWARE REGISTERS
;*
;*             ADDRESSES OF THE HARDWARE REGISTERS
;*
RKDS    =      177400;                 DRIVE STATUS REGISTER
RKER    =      177402;                 ERROR REGISTER
RKCS    =      177404;                 CONTROL STATUS REGISTER
RKWC    =      177406;                 WORD COUNT REGISTER
RKBA    =      177410;                 CURRENT BUS ADDRESS REGISTER
RKDA    =      177412;                 DISK ADDRESS REGISTER
RKDB    =      177416;                 DATA BUFFER REGISTER
;*
;*             BIT AND FIELD DEFINITIONS FOR THE DRIVE STATUS REGISTER
;*
;*      FIELDS ARE DECLARED BY GIVING THEIR RIGHTMOST BITS:
;*
RDSSC   =      ^B0000000000000001;     4 BITS - SECTOR COUNTER
RDSCSA  =      ^B0000000000010000;     1 BIT  - (SECTOR) COUNTER=ADDR
RDSWPS  =      ^B0000000000100000;     1 BIT  - WRITE PROTECT STATUS
RDSRDY  =      ^B0000000001000000;     1 BIT  - READ/WRITE/SEEK READY
RDSDRY  =      ^B0000000010000000;     1 BIT  - DRIVE READY
RDSSOK  =      ^B0000000100000000;     1 BIT  - SECTOR COUNTER OK
RDSSIN  =      ^B0000001000000000;     1 BIT  - SEEK INCOMPLETE
RDSDRU  =      ^B0000010000000000;     1 BIT  - DRIVE UNSAFE
RDRK05  =      ^B0000100000000000;     1 BIT  - RK05 DISK DRIVE
RDSDPL  =      ^B0001000000000000;     1 BIT  - DRIVE POWER LOW
RDSID   =      ^B0010000000000000;     3 BITS - DRIVE IDENTIFIER
;*
;*             BIT DEFINITIONS FOR THE ERROR REGISTER
;*
RERWCE  =      ^B0000000000000001;     WRITE CHECK ERROR (SOFT)
RERCSE  =      ^B0000000000000010;     CHECKSUM ERROR (SOFT)
;*      =      ^B0000000000011100;     3 BITS - NOT USED
RERNXS  =      ^B0000000000100000;     NONEXISTENT SECTOR
RERNXC  =      ^B0000000001000000;     NONEXISTENT CYLINDER
RERNXD  =      ^B0000000010000000;     NONEXISTENT DISK
RERTE   =      ^B0000000100000000;     TIMING ERROR
RERDLT  =      ^B0000001000000000;     DATA LATE
RERNXM  =      ^B0000010000000000;     NONEXISTENT MEMORY
RERPGE  =      ^B0000100000000000;     PROGRAMMING ERROR
RERSKE  =      ^B0001000000000000;     SEEK ERROR
RERWLO  =      ^B0010000000000000;     WRITE LOCKOUT VIOLATION
REROVR  =      ^B0100000000000000;     OVERRUN
RERDRE  =      ^B1000000000000000;     DRIVE ERROR
;*
;*             BIT AND FIELD DEFINITIONS FOR CONTROL STATUS REGISTER
;*
;*      FIELDS ARE DECLARED BY GIVING THEIR RIGHTMOST BITS
;*
RCSGO   =      ^B0000000000000001;     1 BIT  - INITIATE FUNCTION
RCSFUN  =      ^B0000000000000010;     3 BITS - FUNCTION FIELD
RCSMEX  =      ^B0000000000010000;     2 BITS - MEMORY EXTENSION
RCSIDE  =      ^B0000000001000000;     1 BIT  - INTERRUPT ON DONE
RCSRDY  =      ^B0000000010000000;     1 BIT  - CONTROL READY
RCSSSE  =      ^B0000000100000000;     1 BIT  - STOP ON SOFT ERROR
;*      =      ^B0000001000000000;     1 BIT  - NOT USED
RCSFMT  =      ^B0000010000000000;     1 BIT  - FORMAT MODE
RCSIBA  =      ^B0000100000000000;     1 BIT  - INHIBIT INCREMENT
;*      =      ^B0001000000000000;     1 BIT  - NOT USED
RCSSCP  =      ^B0010000000000000;     1 BIT  - SEARCH COMPLETE
RCSHE   =      ^B0100000000000000;     1 BIT  - HARD ERROR
RCSERR  =      ^B1000000000000000;     1 BIT  - ERROR (HARD OR SOFT)
;*
;*      FIELD VALUE DEFINITIONS FOR RCSFUN ARE:__
;*
RCFCRE  =      ^B000;                  CONTROL RESET
RCFWR   =      ^B001;                  WRITE
RCFRD   =      ^B010;                  READ
RCFWRC  =      ^B011;                  WRITE CHECK
RCFSK   =      ^B100;                  SEEK
RCFRDC  =      ^B101;                  READ CHECK
RCFDRE  =      ^B110;                  DRIVE RESET
RCFWRL  =      ^B111;                  WRITE LOCK
;*
;*             BIT AND FIELD DEFINITIONS FOR DISK ADDRESS REGISTER
;*
;*      FIELDS ARE DECLARED BY GIVING THEIR RIGHTMOST BITS:
;*
RDASC   =      ^B0000000000000001;     4 BITS - SECTOR ADDRESS, 0..11
RDASUR  =      ^B0000000000010000;     1 BIT  - SURFACE, 0..1
RDACYL  =      ^B0000000000100000;     8 BITS - CYLINDER, 0..202
RDADRS  =      ^B0010000000000000;     3 BITS - DRIVE SELECT, 0..7
;*
;*
        .PAGE
        .SBTTL LT33 TERMINAL DEFINITIONS

;****  LT33 HARDWARE REGISTERS
;*
;*             ADDRESSES OF THE HARDWARE REGISTERS
;*
RCSR    =      177560;                 RECEIVER STATUS REGISTER
RBUF    =      177562;                 RECEIVER BUFFER REGISTER
XCSR    =      177564;                 TRANSMITTER STATUS REGISTER
XBUF    =      177566;                 TRANSMITTER BUFFER REGISTER
;*
;*             BIT DEFINITIONS FOR THE STATUS REGISTERS
;*
;*      =      ^B1111000000000000;     4 BITS - NOT USED
TSRBSY  =      ^B0000100000000000;     BUSY (RECEIVER ONLY)
;*      =      ^B0000011100000000;     3 BITS - NOT USED
TSRRDY  =      ^B0000000010000000;     READY
TSRIDE  =      ^B0000000001000000;     INTERRUPT ENABLE
;*      =      ^B0000000000111110;     5 BITS - NOT USED
TSRGO   =      ^B0000000000000001;     START (RECEIVER ONLY)
;*
;*             THE 8-BIT ASCII BIT FOR THE RECEIVER BUFFER REGISTER
;*
ASCII8  =      ^B0000000010000000;     1 FOR 8-BIT, 0 FOR 7-BIT ASCII
;*
;*
        .PAGE
        .SBTTL LP11 PRINTER DEFINITIONS

;****  LP11 HARDWARE REGISTERS
;*
;*             ADDRESSES OF THE HARDWARE REGISTERS
;*
LPS     =      177514;                 LINE PRINTER STATUS REGISTER
LPB     =      177516;                 LINE PRINTER DATA BUFFER REGISTER
;*
;*             BIT DEFINITIONS FOR THE STATUS REGISTER
;*
;*      =      ^B0000000000111111;     6 BITS - NOT USED
LPSIDE  =      ^B0000000001000000;     INTERRUPT ENABLE
LPSRDY  =      ^B0000000010000000;     PRINTER READY
;*      =      ^B0111111100000000;     7 BITS - NOT USED
LPSERR  =      ^B1000000000000000;     ERROR
;*
;*
        .PAGE
        .SBTTL CD11 CARD READER DEFINITIONS

;****  CD11 HARDWARE REGISTERS
;*
;*             ADDRESSES OF THE HARDWARE REGISTERS
;*
CDST    =      172460;                 STATUS AND CONTROL REGISTER
CDCC    =      172462;                 COLUMN COUNT REGISTER
CDBA    =      172464;                 CURRENT ADDRESS REGISTER
CDDB    =      172466;                 DATA BUFFER REGISTER
;*
;*             BIT AND FIELD DEFINITIONS FOR THE STATUS AND CONTROL REG
;*
CDSERR  =      ^B1000000000000000;     ERROR
CDSRDC  =      ^B0100000000000000;     READER CHECK
CDSEOF  =      ^B0010000000000000;     END OF FILE
CDSOFL  =      ^B0001000000000000;     OFF LINE
CDSDER  =      ^B0000100000000000;     DATA ERROR
CDSDTL  =      ^B0000010000000000;     DATA LATE
CDSNXM  =      ^B0000001000000000;     NONEXISTENT MEMORY
CDSPCL  =      ^B0000000100000000;     POWER CLEAR
CDSRDY  =      ^B0000000010000000;     READY
CDSIDE  =      ^B0000000001000000;     INTERRUPT ENABLE
CDSMEX  =      ^B0000000000110000;     2 BITS - MEMORY EXTENSION
CDSOLT  =      ^B0000000000001000;     ONLINE TRANSITION
CDSHPC  =      ^B0000000000000100;     HOPPER CHECK
CDSDPK  =      ^B0000000000000010;     DATA PACKING MODE
CDSGO   =      ^B0000000000000001;     START READ
;*
;*
        .PAGE
        .SBTTL KERNEL TRAP VECTOR DEFINITIONS.

;****  PRELIMINARY DEFINITIONS:  *****
;*
;*             MACRO TO SET A SINGLE TRAP VECTOR
;*
        .MACRO TVDEF TRPROC,TPSW
        .WORD  TRPROC,TPSW
        .ENDM  TVDEF
;*
;*             TRAP VECTOR AREA EXTENT DEFINITIONS
;*
TVABEG  =      004;                    START OF TRAP VECTOR AREA
TVAEND  =      400;                    END OF TRAP VECTOR AREA
TVECS   =      <TVAEND - TVABEG> / 4;  NUMBER OF TRAP VECTORS POSSIBLE
;*
;*             THE LOCATIONS OF RELEVANT TRAP VECTORS
;*
FETRAP  =      004;                    FATAL ERRORS:__
                                       ;  ODD ADDRESS,
                                       ;  FATAL STACK VIOLATION (RED),
                                       ;  TIMEOUT (NXM),
                                       ;  PARITY ERROR,
                                       ;  WARNING STACK VIOLATION.
IITRAP  =      010;                    ILLEGAL INSTRUCTIONS:__
                                       ;  "JMP R",
                                       ;  "JSR M,R",
                                       ;  USER MODE "HALT",
                                       ;  RESERVED OPCODES:__
                                       ;    000007 - 000077
                                       ;    000210 - 000227
                                       ;    007000 - 007777
                                       ;    075000 - 076777
                                       ;    106400 - 107777
				       ;<01> AND FLOATING POINT IF NO FPU!!
TBTRAP  =      014;                    T-BIT TRAP (NOT USED)
IOTRAP  =      020;                    IOT TRAP (KERNEL CALL)
PFTRAP  =      024;                    POWER FAILURE
EMTRAP  =      030;                    EMULATOR TRAP (NOT USED)
TRTRAP  =      034;                    TRAP INSTRUCTION (USED BY INTER-
                                       ;   PRETER TRACE)

UNITNO  =      040		;<01>  UNIT NUMBER FOR RK05 DISK (RKDA IMAGE)
RESTRT  =      042		;<01>  PLACE TO RESTART AFTER CRASH

TITRAP  =      060;                    CONSOLE TTY (LT33) INPUT INTRPT.
TOTRAP  =      064;                    CONSOLE TTY (LT33) OUTPUT INTRPT.
CLTRAP  =      100;                    CLOCK (KW11-L) INTERRUPT
LPTRAP  =      200;                    LINE PRINTER (LPXX) INTERRUPT
RKTRAP  =      220;                    DISK (RK11) INTERRUPT
TMTRAP  =      224;                    MAG TAPE (TM11) INTERRUPT
CDTRAP  =      230;                    CARD READER (CD11) INTERRUPT
PITRAP  =      240;                    PROGRAMMING INTERRUPT REQUEST
                                       ;  (NOT USED)
FPTRAP  =      244;                    FLOATING POINT EXCEPTION
SGTRAP  =      250;                    SEGMENT VIOLATION
                                       ;  (INDICATES SYSTEM ERROR)
        .PAGE
;****  SET THE TRAP VECTORS  *****
;*
;*
;
;<01> ****** W A R N I N G ! ! ! ! ! ! ! THE AUTOLOAD PROGRAM CHECKS TO SEE
;*     				         IF LOCATION 0 IS A 137!!!!!!
;*
ZERO:   JMP   @#$KNL0;<01>             JUMP TO INITIALIZATION.  THESE
;*                                     TWO WORDS ARE RESERVED FOR USE
;*                                     BY THE MACHINE IN THE RARE CASE
;*                                     WHEN POWER FAILURE PREVENTS THE
;*                                     COMPLETION OF A FATAL STACK
;*                                     VIOLATION TRAP.
;*
;*             FILL TRAP VECTOR AREA WITH ILLEGAL TRAPS TO LABEL XXXINT
;*             DEFINED BELOW.  THE NEW PSW IS USED TO TRANSMIT THE TRAP
;*             VECTOR ADDRESS TO THE COMMON INTERCEPTOR, XXXINT.
;*
        .REPT  TVECS
        TVDEF  XXXINT,.-2;             UNEXPECTED CALL;
        .ENDR
;*
;*             PLANT THE RELEVANT TRAP VECTORS
;*
;*      BECAUSE THE ASSEMBLY IS RELOCATABLE, THE FOLLOWING
;*      TRAP VECTORS MUST BE MADE RELATIVE TO
;*      RELOCATABLE ZERO.
;*
      . = ZERO+FETRAP          ;FATAL ERROR TRAP
        TVDEF  FEINT,KNLPSW

      . = ZERO+IITRAP          ;<01> ON 11/34 TRAPS COME HERE
	TVDEF  FEINT,KNLPSW    ;<01> HANDLE AS IF TRAPPED TO 4

      . = ZERO+TBTRAP          ;T-BIT TRAP
        TVDEF  TBTINT,KNLPSW
      . = ZERO+IOTRAP          ;KERNELCALL
        TVDEF  KNCALL,KNLPSW

	.IF	NDF,F$PU       ;<01>
      . = ZERO+EMTRAP	       ;<01> USED BY GETPSW MACRO
	TVDEF  EMTPRO,KNLPSW   ;<01> RETURN PSW IN R0
	.ENDC		       ;<01>

      . = ZERO+UNITNO	       ;<01> DUMMY THIS WORD
	.WORD	0	       ;<01> FOR RE-BOOT PURPOSES
      . = ZERO+RESTRT	       ;<01> RESTART KINDNESS
	JMP	@#$RVM0	       ;<01> CALLS SYSTEM INIT ROUTINE

      . = ZERO+TITRAP          ;LT33TERMINAL.READINTERRUPT
        TVDEF  LTIN32,KNLPSW
      . = ZERO+TOTRAP          ;LT33TERMINAL.WRITEINTERRUPT
        TVDEF  LTOU32,KNLPSW
      . = ZERO+CLTRAP          ;CLOCK INTERRUPT
        TVDEF  CLKINT,KNLPSW
      . = ZERO+LPTRAP          ;LPXXPRINTER.INTERRUPT
        TVDEF  LPIN32,KNLPSW
      . = ZERO+RKTRAP          ;RK11DISK.INTERRUPT
        TVDEF  RKIN32,KNLPSW
      . = ZERO+TMTRAP          ;TM11TAPE.INTERRUPT
        TVDEF  TMIN32,KNLPSW
      . = ZERO+CDTRAP          ;CD11CARDREADER.INTERRUPT
        TVDEF  CDIN32,KNLPSW
      . = ZERO+FPTRAP          ;REAL INTERRUPT
        TVDEF  FPPINT,KNLPSW
;*
;*             END THE TRAP VECTOR AREA
;*
      . = ZERO+TVAEND          ;MOVE TO END OF TRAP VECTORS
;*
;*
        .PAGE
        .SBTTL DEFINITIONS OF THE KERNEL STACK

;****  KERNEL STACK DEFINITIONS  *****
;*
;*
KSTKSZ  =      32.;                    SIZE OF THE STACK, WORDS.
;*
;*
KSTTOP  =      .;                      ABSOLUTE STACK TOP
        .BLKW  KSTKSZ;
KSR0:	.WORD  0		;<01>  REGISTER STORAGE AREA
KSR1:	.WORD  0		;<01>
KSR2:	.WORD  0		;<01>
KSR3:	.WORD  0		;<01>
KSR4:	.WORD  0		;<01>
KSR5:	.WORD  0		;<01>
KSOPC:	.WORD  0		;<01>  PC
KSOPSW:	.WORD  0		;<01>  PSW
KSTBOT  =      .;                      STACK BOTTOM
        .PAGE
        .SBTTL DEFINE PRIMITIVE DATA TYPES

;****  LENGTHS OF THE PASCAL PRIMITIVE DATA TYPES  *****
;*
;*
.INTEGER=      2.;                     BYTES
;*
;*
.REAL   =      8.;                     BYTES
;*
;*
.BOOLEAN=      2.;                     BYTES
;*
;*
.CHAR   =      2.;                     BYTES
;*
;*
.ADDRESS=      2.;                     BYTES
;*
;***********************************************************************
;*
;*      ANTICIPATE SOME KERNEL DATATYPE LENGTHS
;*
;*
.TIME   =      4.;                     BYTES
;*
;*
.GATE   =      6.;                     BYTES
;*
;*
.QUEUETY=      4.;                     BYTES
;*
;*
.HEADTYP=      36.;                    BYTES
;*
;*
.REGTYPE=      36.;                    BYTES
;*
;*
.MAPTYPE=      16.;                    BYTES
;*
;***********************************************************************
;*
;*      MACROS TO CHECK DATATYPE LENGTHS
;*
;*
        .MACRO GENERR A,B,C,D,E
        .ERROR A''B''C''D''E
        .ENDM
        .MACRO CHKDTL SYM
      $ =      $ - SYM
        .IF NE $ - .'SYM
        GENERR $,<;>,<REDEFINE ".>,SYM,<", ABOVE.>
        .ENDC
        .ENDM
;*
;*
        .PAGE
        .SBTTL DEBUGGING FACILITIES

;****  DEFINITIONS OF DEBUGGING SWITCHES AND MACRO'S  *****
;*
;*      DEFINE THE DEBUGGING STATE:
;*
;*             NORMALLY ALL OF THE SWITCHES, BELOW, WILL HAVE THE
;*             VALUE 0.
;*
$.DBPS  =      0;                   1: PRINT THE KERNEL STATE
$.DBNC  =      0;                   1: NO CLOCK INTERRUPTS:  THE BELL
                ;                      OF THE CONSOLE TELETYPE WILL
                ;                      SIMULATE A CLOCK INTERRUPT.
$.DBST  =      0;                   1: TYPE SERVICE TRACE
$.DBCD  =      0;                   1: INCLUDE THE CORE DUMP FACILITY
$.DBTA  =      0;                   1: LOAD OPERATING SYSTEM FROM TAPE 0
$.DBLT  =      0;                   1: DO NOT REWIND THE SYSTEM TAPE
$.DBVC  =      0;                   1: VERIFY PRELIMINARY CORE CLEARING
$.DBIT  =      0;                   1: INCLUDE INTERPRETER TRACE
;*
;*      MACRO TO TERMINATE KERNEL ERROR PROCESSING
;*
        .MACRO SYSERR	TEXT		;<01> A LITTLE MORE HELPFUL
        .IF NE $.DBCD
        JMP    $.DBDC
        .ENDC
        .IF EQ $.DBCD
	JSR	R0,$SERR
	.ASCII	\TEXT\<200>
	.EVEN
        .ENDC
        .ENDM  SYSERR
;*
;*      MACRO TO SET 'JMP DUMP' IN LOCATION 0
;*
        .MACRO SETDMP
     $$ =      ZERO
        .IF NE $.DBCD
     $$ =      $.DBDC
        .ENDC
        MOV    #<$$-4>,ZERO+2
        .ENDM  SETDMP
;*
;*      MACRO TO VERIFY CORE CONTENTS
;*
        .MACRO VERCOR
        .IF NE $.DBVC
        .IF NE $.DBCD
        JSR    PC,$.DBDC
        .ENDC
        .IF EQ $.DBCD
        JSR    PC,$.DBCV
        .ENDC
        .ENDC
        .ENDM  VERCOR
;*
;*      MACRO TO PRINT KERNEL STATE
;*
        .MACRO KNSTAT
        .IF NE $.DBPS
        JSR    PC,$.DBSP
        .ENDC
        .ENDM  KNSTAT
;*
;*      MACRO TO TYPE CURRENT RUNNING PROCESS
;*
        .MACRO KNSERV
        .IF NE $.DBST
        JSR    PC,$.DBTS
        .ENDC
        .ENDM  KNSERV
;*
;*      MACRO TO TRACE GET AND PUT OPERATIONS ON PROCESS QUEUES
;*
        .MACRO QTRACE OP
        .IF NE $.DBST
        .IF IDN OP,GET
        JSR    PC,$.DBTG
        .ENDC
        .IF IDN OP,PUT
        JSR    PC,$.DBTP
        .ENDC
        .ENDC
        .ENDM  QTRACE
;*
;*      MACRO TO SIMULATE CLOCK INTERRUPT BY THE TELETYPE BELL KEY
;*
        .MACRO BLTICK
        .IF NE $.DBNC
     $$ =      CLOCK8
        .ENDC
        .ENDM  BLTICK
;*
;*
        .PAGE
;****  PROCEDURES TO TYPE SERVICE TRACES  *****
;*
;*
        .IF NE $.DBST
;*
;*      TYPE CURRENT RUNNING PROCESS
;*
$.DBTS: MOV    #1$,$.DB00
        MOV    USER99,$.DB01
        BR     $.DB02
1$:     .ASCIZ <13.><10.>/SERVICE/
        .EVEN
;*
;*      TYPE PROCESS DEPARTURES
;*
$.DBTG: MOV    #1$,$.DB00
        MOV    GET4R,$.DB01
        BR     $.DB02
1$:     .ASCIZ <13.><10.>/DEPARTURE/
        .EVEN
;*
;*      TYPE PROCESS ARRIVALS
;*
$.DBTP: MOV    #1$,$.DB00
        MOV    NEWEL4,$.DB01
        BR     $.DB02
1$:     .ASCIZ <13.><10.>/ARRIVAL/
        .EVEN
;*
;*
$.DB00: .WORD  0
$.DB01: .WORD  0
$.DB02: MOV    STAT28,$.DB31
        MOV    OUTL28,$.DB32
        MOV    ECHO28,$.DB33
        MOV    $.DB00,TEXT33
        JSR    PC,WRIT33
        MOV    $.DB01,NN34
        JSR    PC,WRIT34
        MOV    $.DB31,STAT28
        CMP    $.DB31,#WRIT28
        BNE    2$
        MOV    $.DB32,OUTL28
        MOV    $.DB33,ECHO28
        RTS    PC
2$:     MOV    #1$,TOTRAP
        BIS    #INEN28,WRST28
        SPL    0
        WAIT
        SPL    7
        RTS    PC
1$:     MOV    #LTOU32,TOTRAP
        RTI
$.DB31: .WORD  0
$.DB32: .WORD  0
$.DB33: .WORD  0
        .ENDC
;*
;*
        .PAGE
;****  PROCEDURES TO PRINT THE KERNEL STATE  *****
;*
;*
        .IF NE $.DBPS+$.DBVC+$.DBIT
$.DB03: .WORD  0                       ; PROCEDURE PRINT(VAR I:
                                       ;                      INTEGER);
                                       ; BEGIN
$.DB04: MOV    #1$,R3                  ;
        MOV    #6.,R4                  ;   CONVERT TO OCTAL;
        MOV    #8.,R2                  ;
        JSR    PC,$.DB05               ;
        MOV    #5.,R4                  ;   CONVERT TO DECIMAL;
        MOV    #10.,R2                 ;
        JSR    PC,$.DB05               ;
7$:     TST    LPS                     ;   READY THE PRINTER;
        BGE    2$                      ;
        MOV    #3$,TEXT33              ;
        JSR    PC,WRIT33               ;
4$:     TST    LPS                     ;
        BLT    4$                      ;
2$:     TSTB   LPS                     ;
        BGE    2$                      ;
        MOV    #5$,R1                  ;
6$:     MOVB   (R1)+,LPB               ;   PRINT INTEGER VALUES;
        TSTB   LPS                     ;
        BMI    6$                      ;
        RTS    PC                      ; END;
5$:     .BLKB  <1+5+1+6>
1$:     .ASCII <10.>
3$:     .ASCIZ <13.><10.>/READY THE PRINTER/
        .EVEN
$.DB29  =      5$
$.DB30  =      7$
$.DB05: MOV    @$.DB03,R1              ; CONVERT INTEGER TO ASCII;
1$:     CLR    R0
        DIV    R2,R0
        ADD    #'0,R1
        MOVB   R1,-(R3)
        MOV    R0,R1
        SOB    R4,1$
        MOVB   #' ,-(R3)
        RTS    PC
$.DB27:                                ; PROCEDURE GRABPRINTER;
                                       ; BEGIN
        MOV    #12.,$.DB29             ;   NEW PAGE;
        JSR    PC,$.DB30               ;
        RTS    PC                      ; END;
$.DB28:                                ; PROCEDURE RELEASEPRINTER;
                                       ; BEGIN
1$:     TSTB   LPS                     ;   RELEASE IT;
        BGE    1$                      ;
        TST    USER29                  ;
        BNE    2$                      ;
        MOV    #3$,LPTRAP              ;
        BIS    #INEN29,STAT29          ;
        SPL    0                       ;
        WAIT                           ;
        SPL    7                       ;
2$:     RTS    PC                      ;
3$:     MOV    #LPIN32,LPTRAP          ;
        RTI                            ; END;
;*
;*
$.DB06: .WORD  0                       ; PRINT AN ARRAY OF INTEGERS;
$.DB07: .WORD  0
$.DB08: MOV    $.DB06,$.DB03
        MOV    $.DB07,R0
1$:     MOV    R0,2$
        JSR    PC,$.DB04
        ADD    #2,$.DB03
        MOV    2$,R0
        SOB    R0,1$
        RTS    PC
2$:     .WORD  0
        .ENDC
        .IF NE $.DBPS
;*
;*      PRINT THE KERNEL STATUS:
;*
$.DB09:                                ; PROCEDURE PRINTNEWCORE;
                                       ; BEGIN
        MOV    #1$,$.DB03              ;   PRINT(BASEADDR);
        JSR    PC,$.DB04               ;
        MOV    #TOP16,$.DB03           ;   PRINT(TOP);
        JSR    PC,$.DB04               ;
        MOV    #FREE16,$.DB03          ;   PRINT(FREE);
        JSR    PC,$.DB04               ;
        RTS    PC                      ; END;
1$:     .WORD  BASE16                  ;
;*
;*
$.DB10: .WORD  0                       ; PROCEDURE PRINTQUEUE(Q);
                                       ; BEGIN
$.DB11: MOV    #$.DB10,$.DB03          ;   PRINT(@Q);
        JSR    PC,$.DB04               ;
        MOV    $.DB10,$.DB06           ;   PRINT IT;
        MOV    #<.QUEUETYPE/2>,$.DB07  ;
1$:     JSR    PC,$.DB08               ;
        MOV    @$.DB06,$.DB06          ;
        CMP    $.DB06,$.DB10           ;
        BNE    1$                      ;
        RTS    PC                      ; END;
;*
;*
$.DB12: .WORD  0                       ; PROCEDURE PRINTTIME(T);
                                       ; BEGIN
$.DB13: MOV    $.DB12,$.DB06           ;   PRINT IT;
        MOV    #<.TIME/2>,$.DB07       ;
        JSR    PC,$.DB08               ;
        RTS    PC                      ; END;
;*
;*
$.DB14:                                ; PROCEDURE PRINTCLOCK;
                                       ; BEGIN
        MOV    #NOW7,$.DB12            ;   PRINTTIME(NOW);
        JSR    PC,$.DB13               ;
        MOV    #NEXTT7,$.DB10          ;   PRINTQUEUE(NEXTTIME.AWAITING)
        JSR    PC,$.DB11               ;
        RTS    PC                      ; END;
;*
;*
$.DB15:                                ; PROCEDURE PRINTCORE;
                                       ; BEGIN
        MOV    #USER99,R1              ;   PRINT(HEADADDR DIV 64);
        CLR    R0                      ;
        DIV    #64.,R0                 ;
        MOV    R0,1$                   ;
        MOV    #1$,$.DB03              ;
        JSR    PC,$.DB04               ;
        MOV    #COREC9,$.DB03          ;   PRINT(CORECAPACITY);
        JSR    PC,$.DB04               ;
        MOV    #TOP9,$.DB03            ;   PRINT(TOP);
        JSR    PC,$.DB04               ;
        MOV    #FREE9,$.DB03           ;   PRINT(FREE);
        JSR    PC,$.DB04               ;
        RTS    PC                      ; END;
1$:     .WORD  0                       ;
;*
;*
$.DB16: .WORD  0                       ; PROCEDURE PRINTHEAD(H);
                                       ; BEGIN
$.DB17: MOV    $.DB16,$.DB06           ;   PRINT IT;
        MOV    #<.HEADTYPE/2>,$.DB07   ;
        JSR    PC,$.DB08               ;
        RTS    PC                      ; END;
;*
;*
$.DB18: .WORD  0                       ; PROCEDURE PRINTREG(R);
                                       ; BEGIN
$.DB19: MOV    $.DB18,$.DB06           ;   PRINT THEM;
        MOV    #<.REGTYPE/2>,$.DB07    ;
        JSR    PC,$.DB08               ;
        RTS    PC                      ; END;
;*
;*
$.DB20: .WORD  0                       ; PROCEDURE PRINTMAP(M);
                                       ; BEGIN
$.DB21: MOV    $.DB20,$.DB06           ;   PRINT IT;
        MOV    #<.MAPTYPE/2>,$.DB07    ;
        JSR    PC,$.DB08               ;
        RTS    PC                      ; END;
;*
;*
$.DB22:                                ; PROCEDURE PRINTVIRTUAL;
                                       ; BEGIN
        MOV    #HARD10,$.DB20          ;   PRINTMAP(HARDWAREMAP);
        JSR    PC,$.DB21               ;
        MOV    #COMM10,$.DB03          ;   PRINT(COMMON);
        JSR    PC,$.DB04               ;
        MOV    #HEAP10,$.DB03          ;   PRINT(HEAPTOP);
        JSR    PC,$.DB04               ;
        RTS    PC                      ; END;
;*
;*
$.DB23: .WORD  0                       ; PROCEDURE PRINTPROCESS(P);
                                       ; BEGIN
$.DB24: MOV    #$.DB23,$.DB03          ;   PRINT(@P);
        JSR    PC,$.DB04               ;
        MOV    $.DB23,R0               ;   PRINTHEAD(P.HEAD);
        ADD    #HEAD0,R0               ;
        MOV    R0,$.DB16               ;
        JSR    PC,$.DB17               ;
        MOV    $.DB23,R0               ;   PRINTREG(P.REG);
        ADD    #REG0,R0                ;
        MOV    R0,$.DB18               ;
        JSR    PC,$.DB19               ;
        MOV    $.DB23,R0               ;   PRINTMAP(P.MAP);
        ADD    #MAP0,R0                ;
        MOV    R0,$.DB20               ;
        JSR    PC,$.DB21               ;
        RTS    PC                      ; END;
;*
;*
$.DB25:                                ; PROCEDURE PRINTRUNNING;
                                       ; BEGIN
        MOV    USER99,$.DB23           ;   PRINTPROCESS(USER);
        JSR    PC,$.DB24               ;
        MOV    #HEAD99,$.DB16          ;   PRINTHEAD(HEAD);
        JSR    PC,$.DB17               ;
        MOV    #CONS99,$.DB03          ;   PRINT(CONST);
        JSR    PC,$.DB04               ;
        MOV    #PARA11,$.DB06          ;   PRINTPARAMS;
        MOV    #MAX11,$.DB07           ;
        JSR    PC,$.DB08               ;
        MOV    #NEXT11,$.DB03          ;   PRINT(NEXTINDEX);
        JSR    PC,$.DB04               ;
        MOV    #PRID11,$.DB06          ;   PRINTPROCESSIDS;
        MOV    #PROCS,$.DB07           ;
        JSR    PC,$.DB08               ;
        MOV    #1$,R0                  ;   PRINTREG(REG);
        MOV    R0,$.DB18               ;
        MOV    SP,R1                   ;
        MOV    R0,SP                   ;
        BIS    #PSREG1,PSW             ;
        MOV    W,(SP)+                 ;
        MOV    X,(SP)+                 ;
        MOV    Y,(SP)+                 ;
        MOV    Q,(SP)+                 ;
        MOV    B,(SP)+                 ;
        MOV    G,(SP)+                 ;
        BIC    #PSREG1,PSW             ;
        MOV    SP,R0                   ;
        MOV    R1,SP                   ;
        BIS    #PSPMDU,PSW             ;
        MFPI   SP                      ;
        MOV    (SP)+,(R0)+             ;
        MOV    KSOPC,(R0)+             ;
        MOV    KSOPSW,(R0)+            ;
        STD    W,(R0)+                 ;
        STD    X,(R0)+                 ;
        STFPS  (R0)                    ;
        JSR    PC,$.DB19               ;
        RTS    PC                      ; END;
1$:     .BLKB  .REGTYPE                ;
;*
;*
$.DB26:                                ; PROCEDURE PRINTREADY;
                                       ; BEGIN
        MOV    #TOP12,$.DB10           ;   PRINTQUEUE(TOP);
        JSR    PC,$.DB11               ;
        MOV    #MIDD12,$.DB10          ;   PRINTQUEUE(MIDDLE);
        JSR    PC,$.DB11               ;
        MOV    #BOTT12,$.DB10          ;   PRINTQUEUE(BOTTOM);
        JSR    PC,$.DB11               ;
        MOV    #IDLI12,$.DB03          ;   PRINT(IDLING);
        JSR    PC,$.DB04               ;
        RTS    PC                      ; END;
;*
;*      PRINT THE KERNEL STATE:
;*
$.DBSP:                                ; PROCEDURE KNSTAT;
                                       ; BEGIN
        JSR    PC,$.DB27               ;   GRABPRINTER;
        JSR    PC,$.DB09               ;   PRINTNEWCORE;
        MOV    #PERIO6,$.DB03          ;   PRINT(TIMER.PERIOD);
        JSR    PC,$.DB04               ;
        JSR    PC,$.DB14               ;   PRINTCLOCK;
        JSR    PC,$.DB15               ;   PRINTCORE;
        JSR    PC,$.DB22               ;   PRINTVIRTUAL;
        JSR    PC,$.DB25               ;   PRINTRUNNING;
        JSR    PC,$.DB26               ;   PRINTREADY;
        JSR    PC,$.DB28               ;   RELEASEPRINTER;
        RTS    PC                      ; END;
        .ENDC
;*
;*
        .PAGE
;****  CORE DUMP PROCEDURE  *****
;*
;*
        .IF NE $.DBCD
$.DBDC:
        MOV    PC,R0
        SYSERR
        .ENDC
;*
;*
        .PAGE
;****  CORE VERIFICATION PROCEDURE  *****
;*
;*
        .IF NE $.DBVC
        .IF EQ $.DBCD
$.DBCV:                                ; PROCEDURE VERIFYCORE;
                                       ; BEGIN
        MOV    KISAR+12.,R0            ;
        MOV    #.PRBLK,R1              ;
        SUB    #.SGSBK,R1              ;
        MOV    R1,KISAR+12.            ;
        MOV    #2$,FETRAP              ;
1$:     TST    140000                  ;
        BR     3$                      ;
2$:     SUB    #.SGSBK,KISAR+12.       ;
        ADD    #4,SP                   ;
        BR     1$                      ;
3$:     MOV    #FEINT,FETRAP           ;
        MOV    KISAR+12.,6$            ;
        ADD    #.SGSBK,6$              ;
4$:     MOV    #<.SEGSB-2>,R1          ;
10$:    TST    140000(R1)              ;
        BNE    5$                      ;
        SUB    #2,R1                   ;
        BGE    10$                     ;
        SUB    #.SGSBK,KISAR+12.       ;
        BR     4$                      ;
5$:     MOV    KISAR+12.,7$            ;
        MOV    R1,8$                   ;
        MOV    140000(R1),9$           ;
        MOV    R0,KISAR+12.            ;
        JSR    PC,$.DB27               ;   GRABPRINTER;
        MOV    #6$,$.DB06              ;   PRINTRESULTS;
        MOV    #4,$.DB07               ;
        JSR    PC,$.DB08               ;
        JSR    PC,$.DB28               ;   RELEASEPRINTER;
        RTS    PC                      ; END;
6$:     .WORD  0                       ;
7$:     .WORD  0                       ;
8$:     .WORD  0                       ;
9$:     .WORD  0                       ;
        .ENDC
        .ENDC
        .PAGE
;****  PROCEDURE TO PRINT INTERPRETER TRACE  *****
;*
;*
        .IF NE $.DBIT
     $$ =      .
      . =      TRTRAP
        TVDEF  $.DBTI,KNLPSW
      . =      $$
;*
;*
$.DBTI:                                ; PROCEDURE PRINTTRACE(OPCODE, Q,
                                       ;                      S, SMAX);
                                       ; BEGIN
        MOV    #10.,$.DB29             ;   PRINTNEWLINE;
        JSR    PC,$.DB30               ;
        MOV    #<HEAD99+INDEX1>,$.DB03 ;   PRINT(INDEX);
        JSR    PC,$.DB04               ;
     $$ =      HEAD99+PARAM1           ;   PRINT(OPCODE);
        MOV    #$$,$.DB03              ;
        JSR    PC,$.DB04               ;
     $$ =      $$ + .INTEGER           ;   PRINT(Q);
        MOV    #$$,$.DB03              ;
        JSR    PC,$.DB04               ;
     $$ =      $$ + .INTEGER           ;   PRINT(S);
        MOV    #$$,$.DB03              ;
        JSR    PC,$.DB04               ;
1$:     MFPD   @$$                     ;   PRINTSTACK;
        MOV    SP,$.DB03               ;
        JSR    PC,$.DB04               ;
        TST    (SP)+                   ;
        CMP    $$,$$+.INTEGER          ;
        BEQ    2$                      ;
        ADD    #2.,$$                  ;
        BR     1$                      ;
2$:     RTI                            ; END;
        .ENDC
;*
;*
        .PAGE
        .SBTTL FIRST LEVEL TRAP/INTERRUPT INTERCEPTORS

;****  TRAPS AND INTERRUPTS WITH COMMON PREPROCESSING COME HERE  *****
;*
;*

;*
;*             FATAL ERROR TRAP:
;*
FEINT:	INTSRV			   ;<01> STACK THE REGS SO CAN TELL WHERE IT
				   ;<01> CAME FROM!!
	MOV    #FETRAP,R0          ;   R0 := TRAP VECTOR ADDRESS;
        SYSERR	<TRAP TO 4/10>     ;<01>
;*
;*             T-BIT TRAP:
;*
TBTINT:	INTSRV			   ;<01> PRESERVE REGISTER CONTENTS
	CMP    14(SP),#XXXIN0      ;<01> TRAP FROM XXXINT ?
        BEQ    XXXIN1              ;   BRANCH IF SO;
        MOV    #TBTRAP,R0          ;   R0 := TRAP VECTOR ADDRESS;
        SYSERR	<BPT EXECUTION>	   ;<01>
;*
;*             UNEXPECTED CALL:
;*
XXXINT:	INTSRV			   ;<01> PRESERVE THE REGISTERS
	MOV    PSW,XXXIN2          ;   R0 := TRAP OR INTERRUPT VECTOR
XXXIN0: SPL    7                   ;         ADDRESS;  THIS CAUSES IT
XXXIN1: MOV    XXXIN2,R0           ;         TO BE DISPLAYED AT THE
        BIC    #^C<TVAEND-1>,R0    ;         COMPUTER CONSOLE.
        SYSERR <UNKNOWN INTERRUPT> ;<01>
XXXIN2: .WORD  0                   ;
.SBTTL	SYSTEM ERROR HANDLER
;
;	THIS ENTIRE SECTION ADDED BY EDIT <01>
;
;
;	THE FOLLOWING SECTION OF CODE IS USED TO DUMP OUT THE REGISTERS, PC,
;	AND PSW OF THE PROCESS CAUSING A SYSTEM CRASH.  OBVIOUSLY, MORE STUFF
;	COULD BE ADDED LATER (AND PROBABLY WILL).  THIS IS MUCH BETTER THAN
;	A SIMPLE HALT!!!!!!!!!
;
;
;
;	LOCAL MACROS:
;
	.MACRO	PRINT	X	   ;PRINT ASCII STRING ON TERMINAL
	.IF	NB,X
	MOV	X,R0		   ;R0 -> ASCII
	.ENDC
	JSR	PC,PRINT	   ;CALL PRINT ROUTINE
	.ENDM	PRINT

	.MACRO	OCTAL	X,Y	   ;CONVERT TO OCTAL ASCII
	.IF	NB,X
	MOV	X,R0
	.ENDC
	.IF	NB,Y
	MOV	Y,R1
	.ENDC
	JSR	PC,OCTAL	   ;CALL CONVERSION SUBROUTINE
	.ENDM	OCTAL

$SERR:
	.ENABL	LSB
	SPL	7		   ;UP PRIORITY IF NOT ALREADY
	PRINT			   ;PRINT STRING ASSOCIATED WITH ERROR
				   ;(CONTAINED IN SYSERR MACRO CALL)
	PRINT	#HEADER		   ;PRINT OUT HEADINGS
	MOV	#KSR0,R2	   ;R2 -> REGISTERS
	MOV	#8.,R3		   ;R3 COUNTS
1$:
	OCTAL	(R2)+,#ONUM	   ;CONVERT A REGISTER TO ASCII
	PRINT	#ONUM		   ;AND PRINT
	DEC	R3		   ;COUNT
	BNE	1$		   ;	    DOWN
	PRINT	#NULL		   ;RETURN THE CARRIAGE
	HALT			   ;NOW STOP!
	BR	.-2		   ;DISALLOW CONTINUE
;
;	AT THIS POINT, COULD PROBABLY FORCE AN EXCEPTION CONDITION ON USER
;	(IF TRAP CAME FROM USER STATE), AND CONTINUE SYSTEM EXECUTION.
;
;
;	DATA:
;
HEADER:	.ASCII	<15><12>\SYSTEM FAILURE\<15><12>
	.ASCII	\  R0     R1     R2     R3     R4     R5     PC     PSW\
NULL:	.BYTE	0
ONUM:	.ASCII	\XXXXXX \<200>
	.EVEN
	.DSABL	LSB
.SBTTL	SYSERR SUBROUTINES
;
;
;	THE FOLLOWING SUBROUTINE PRINTS THE ASCII STRING POINTED TO BY R0
;	ON THE CONSOLE TERMINAL.  THE STRING IS TERMINATED IN TWO WAYS:
;
;		1). A NULL CHARACTER, WHICH CAUSES A CR/LF SEQUENCE TO BE
;		    APPENDED TO THE END OF THE STRING.
;
;		2). A NEGATIVE BYTE (PARITY BIT SET), WHICH CAUSES THE STRING
;		    TO BE OUTPUT "AS IS".
;
PRINT:
	TSTB	XCSR			;WAIT ON
	BPL	PRINT			;	   DONE
	MOVB	(R0)+,XBUF		;OUTPUT NEXT CHARACTER
	BGT	PRINT			;GT => MORE CHARACTERS IN STRING
	BMI	RETURN			;MI => DO NO MORE
	MOV	#CRLF,R0		;R0 -> CR,LF,-1 SEQUENCE
	BR	PRINT			;PRINT THIS
RETURN:	RTS	PC			;RETURN TO CALLER
CRLF:	.BYTE	15,12,-1		;CR,LF SEQUENCE
	.EVEN				;ALIGNMENT
;
;
;	THE OCTAL SUBROUTINE CONVERTS THE NUMBER IN R0 TO OCTAL ASCII
;	(6 DIGITS) IN THE AREA POINTED TO BY R1.  THIS CODE COURTESY THE
;	AUTHORS OF THE RT-11 OPERATING SYSTEM.
;
;
OCTAL:
	MOV	#30,R4			;SEED DIGIT
	SEC				;USED AS END FLAG
1$:
	ROL	R0			;SHIFT OUT TOP BIT
	ROLB	R4			;NOTE R4 NOW = ASCII DIGIT
	MOVB	R4,(R1)+		;PUT IN BUFFER

	MOV	#206,R4			;SEED NEXT DIGIT
2$:
	ASL	R0			;SHIFT OUT NEXT BIT
	BEQ	3$			;EQ => DONE
	ROLB	R4			;SHIFT INTO DESTINATION
	BCS	2$			;CS => 1ST TIME AROUND
	BR	1$			;ELSE, DONE
3$:
	RTS	PC			;RETURN TO CALLER
.SBTTL	CLOCK INTERRUPT SERVICE
;*
;*             KW11-L LINE CLOCK INTERRUPT:
;*
CLKINT:	BIS	#LKSINE,@#LKS	   ;<01> RE-ENABLE INTERRUPT
	INTSRV	CLOCK8		   ;<01> GOTO CLOCK 8 TO SERVICE INTRPT 
;*
;*             FLOATING POINT PROCESSOR INTERRUPT:
;*
FPPINT: INTSRV REAL11              ;<01> REALINTERRUPT;
.SBTTL	KERNEL CALL INTERRUPT SERVICE
;*
;*             KERNEL CALL:
;*
KNCALL:	INTSRV			   ;<01> SERVICE INTERRUPT IMMEDIATELY
	JSR    PC,@<HEAD99+OPCOD1> ; CASE RUNNING.HEAD.OPCODE OF
                                   ;    0: WAIT;
                                   ;    2: REALTIME;
                                   ;    4: SYSTEMERROR;
                                   ;    6: INITPROCESS;
                                   ;    8: ENDPROCESS;
                                   ;   10: STOPJOB;
                                   ;   12: ENTER;
                                   ;   14: LEAVE;
                                   ;   16: DELAY;
                                   ;   18: CONTINUE;
                                   ;   20: INITGATE;
                                   ;   22: IO;
                                   ; END;
KNEXIT: TST    USER99              ; IF RUNNING.USER = NIL THEN
        BNE    1$                  ;
        JSR    PC,SELE12           ;   READY.SELECT;
1$:     KNSTAT                     ;
        KNSERV                     ;
	POP	<R0,R1,R2,R3,R4,R5> ;<01> DONE, RESTORE REGISTERS
        RTI                        ; KERNELEXIT;
;*
;*
        .PAGE
        .SBTTL INITIALIZE THE VIRTUAL MACHINE

;****  INITIALIZE THE KERNEL AND LOAD THE SYSTEM PROGRAM
;*
;*
;***********************************************************************
;*                                 ;
;*                                 ;
;*                                 ; CONST PROGRAMSTART = ...;
;*                                 ;       KERNELLENGTH = ...;
;*                                 ;
;*                                 ; TYPE STACKINDEX = 0..31;
;*                                 ;      MAPINDEX = 0..7;
;*                                 ;      DISKBLOCK = 0..4799;
;*                                 ;
;*      =      SP                  ; VAR STACKPOINTER: STACKINDEX;
$SDA0:  .WORD  24.                 ;     SYSTEMBLOCK: DISKBLOCK INIT 24;
;*      =      $.DBTA              ;     SYSTEMTAPE: BOOLEAN;
;*                                 ;     KERNELSTACK: ARRAY
;*                                 ;          (.STACKINDEX.) OF INTEGER;
;*      =      SSR0                ;     ADDRESSMAPPING: BOOLEAN;
;*      =      KISDR               ;     KERNELSDRS: ARRAY (.MAPINDEX.)
;*                                 ;                         OF INTEGER;
;*      =      KISAR               ;     KERNELMAP: ARRAY (.MAPINDEX.)
;*                                 ;                         OF INTEGER;
;*      =      COREC9              ;     CORECAPACITY: INTEGER;
;*                                 ;
;*                                 ;
;*                                 ; PROCEDURE LOADVIRTUALMACHINE;
;*                                 ;
;*      =      .SGSBK              ; CONST BLOCKINCR = 128;
;*      =      .PRBLK              ;       REGISTERBLOCK = 3968;
;*                                 ;       DISK0 = 0;
;*      =      KSDR                ;       SEGMENTDESCRIPTOR = ...
;*                                 ;    "8K BYTES, UPWARDS, READ/WRITE";
;*                                 ;
;*      =      RKCS, RKER          ; VAR ERROR: BOOLEAN;
;*      =      R0                  ;     I: MAPINDEX;
;*                                 ;
;*                                 ; BEGIN
;* THIS PROCEDURE IS EXECUTED FOR  ;
;* THE FIRST TIME BY ACTION OF A   ;
;* HUMAN OPERATOR AT THE COMPUTER  ;
;* CONSOLE, WHO PERFORMS A STANDARD;
;* INITIAL PROGRAM LOAD FROM DISK  ;
;* DRIVE 0.  WHEN THIS HAS BEEN    ;
;* DONE, THE CODE WHICH IMPLEMENTS ;
;* THE VIRTUAL MACHINE (KERNEL +   ;
;* INTERPRETER) WILL HAVE BEEN READ;
;* INTO CORE STARTING AT PHYSICAL  ;
;* ADDRESS 000000.  CONTROL IS     ;
;* PASSED TO "$KNL0" VIA A 'JMP'   ;
;* INSTRUCTION SITUATED AT 000000. ;
;*                                 ;
;* SUBSEQUENTLY, THIS PROCEDURE MAY;
;* BE RE-EXECUTED BY JUMPING TO THE;
;* LABEL "$RVM0", BELOW, AFTER     ;
;* HAVING MOVED THE STARTING PAGE  ;
;* NUMBER OF THE NEW OPERATING SYS-;
;* TEM INTO "$SDA0", ABOVE.        ;
;*                                 ;
;*<01> ALSO BY LOADING ADDR 42 AND ;
;*<01> START FROM FRONT PANEL (NICE;
;*<01> FOR DEBUGGING CHANGES THAT  ;
;*<01> DON'T QUITE WORK!)          ;
;*                                 ;
$RVM0:  RESET                      ;   RESETUNIBUS;
      $ =      <INTEND-ZERO+511.>  ;   READ(DISK0, 0, 0, KERNELLENGTH,
      $ =      <$/512.> * 256.     ;                             ERROR);
        MOV    #<-$>,RKWC          ;
	MOV    #1,RKDA		   ;<01> THIS VERSION STARTS @ BLK 1
	BIS    UNITNO,RKDA	   ;<01> AND FROM ANY UNIT
        MOV    $SDA0,R0            ;
	MOV    UNITNO,R1	   ;<01> SAVE THIS ALSO
      $ =      <RCSFUN*RCFRD>+RCSGO;
        MOV    #$,RKCS             ;
1$:     TSTB   RKCS                ;
        BGE    1$                  ;
        MOV    R0,$SDA0            ;
	MOV    R1,UNITNO	   ;<01> REPLACE UNIT NUMBER
                                   ;
                                   ;
$KNL0:  SPL    7                   ;   EXCLUDEINTERRUPTS;
        SETDMP                     ;
        MOV    #KSR0,SP            ;<01> STACKPOINTER := 1; "THIS RESERVES
                                   ;     8 STACK ENTRIES WHICH WILL
                                   ;     BE SUBSEQUENTLY FILLED WITH THE
                                   ;     STATUS, RETURN, AND REGISTERS
				   ;     OF THE INITIAL PROCESS."

        MOV    #8.,R0              ;   FOR I := 0 TO 7 DO
        CLR    R1                  ;
        MOV    #KISDR,R2           ;
        MOV    #KISAR,R3           ;   BEGIN
1$:     MOV    #KSDR,(R2)+         ;     KERNELSDRS(.I.) :=
                                   ;                  SEGMENTDESCRIPTOR;
        MOV    R1,(R3)+            ;     KERNELMAP(.I.) :=
        ADD    #.SGSBK,R1          ;                      I * BLOCKINCR;
        SOB    R0,1$               ;   END;
        MOV    #.PRBLK,-(R3)       ;   KERNELMAP(.7.) := REGISTERBLOCK;
                                   ;
        TST    RKCS                ;   IF ERROR THEN
        BGE    2$                  ;
        CMP    #RERNXM,RKER        ;
        BEQ    2$                  ;
3$:     TSTB   XCSR                ;   BEGIN
        BGE    3$                  ;     TYPE('(:13:)(:10:)');
        MOV    #4$,R0              ;     TYPE('KERNEL LOAD ERROR');
7$:     TSTB   (R0)                ;     TYPE('(:13:)(:10:)');
        BEQ    5$                  ;
        MOVB   (R0)+,XBUF          ;
6$:     TSTB   XCSR                ;
        BGE    6$                  ;
        BR     7$                  ;
4$:     .ASCII <13.><10.>          ;
        .ASCII /KERNEL LOAD ERROR/ ;
        .ASCIZ <13.><10.>          ;
        .EVEN                      ;
5$:     HALT                       ;     HALT;
        SYSERR <LOAD ABORTED>      ;   END;
2$:                                ;
                                   ; END;
                                   ;
                                   ;
;*                                 ; PROCEDURE LOADSYSTEMPROGRAM;
;*                                 ;
;*                                 ;
;*                                 ; CONST PROGRAMEND = ...;
;*                                 ;       ENDOFCORE = ...;
;*                                 ;
;*                                 ; TYPE PAGE = ARRAY (.1..256.) OF
;*                                 ;                            INTEGER;
;*                                 ;      SEGMENTINDEX = 1..4096;
;*                                 ;      SEGMENT = ARRAY
;*                                 ;        (.SEGMENTINDEX.) OF INTEGER;
;*                                 ;
;*      =      KISAR+12.           ; VAR SEGADDR: @SEGMENT;
;*      =      R1                  ;     I: SEGMENTINDEX;
;*      =      R2                  ;     SEGINDEX: SEGMENTINDEX;
;*                                 ;
$LSP0:                             ;
;* IT IS EXPECTED THAT THE HUMAN   ; PROCEDURE LOADFROMTAPE;
;* OPERATOR WILL MOUNT A TAPE REEL ;
;* CONTAINING THE CODE OF THE OP-  ;
;* ERATING SYSTEM ON THE (9-TRACK) ;
;* TAPE DRIVE 0.                   ;
;*                                 ;
;*                                 ; CONST TAPE0 = 0;
;*                                 ;
;*      =      MTC                 ; VAR ERROR: BOOLEAN;
;*      =      MTCMA               ;     ADDR: @PAGE;
;*                                 ;
        .IF NE $.DBTA              ; BEGIN
     $R =      MDN800 * MTCDEN     ;   WHILE NOT MOUNTED(TAPE0) DO
     $R =      $R + <MTCFUN*MTFREW>;   BEGIN
        MOV    #$R,MTC             ;
        BIT    #MTSELR,MTS         ;
        BNE    1$                  ;
        MOV    #12$,TEXT33         ;     TYPE('(:13:)(:10:)');
        JSR    PC,WRIT33           ;     TYPE('MOUNT SYSTEM TAPE ');
                                   ;     TYPE('ON DRIVE 0 AND THEN ');
                                   ;     TYPE('PRESS "CONTINUE".');
        HALT                       ;     HALT;
        BR     $LSP0               ;
12$:    .ASCII <13.><10.>          ;
        .ASCII /MOUNT SYSTEM TAPE /;
        .ASCII /ON DRIVE 0 /       ;
        .ASCII /AND THEN /         ;
        .ASCIZ /PRESS "CONTINUE"./ ;
        .EVEN                      ;
1$:                                ;   END;
        .IF EQ $.DBLT              ;
        INC    MTC                 ;   REWIND(TAPE0, ERROR);
2$:     TSTB   MTC                 ;
        BGE    2$                  ;
        TST    MTC                 ;   IF ERROR THEN
        BGE    3$                  ;
        CLR    HEAD99+OPLIN1       ;
        MOV    #10$,RESU19         ;   KERNELERROR(
        JSR    PC,KERN19           ;          'TAPE REWIND ERROR(:0:)');
10$:    .ASCIZ /TAPE REWIND ERROR/ ;
        .EVEN                      ;
        .ENDC                      ;
3$:     MOV    #INTEND,MTCMA       ;   ADDR := @PROGRAMSTART;
        MOV    #-512.,MTBRC        ;   READ(TAPE0, ADDR, ERROR);
     $R =      MDN800 * MTCDEN     ;
     $R =      $R + MTCGO          ;
     $R =      $R + <MTCFUN*MTFRD> ;
        MOV    #$R,MTC             ;
4$:     TSTB   MTC                 ;
        BGE    4$                  ;
        TST    MTC                 ;   IF ERROR THEN
        BGE    5$                  ;
9$:     CLR    HEAD99+OPLIN1       ;
        MOV    #11$,RESU19         ;   KERNELERROR(
        JSR    PC,KERN19           ;            'TAPE READ ERROR(:0:)');
11$:    .ASCIZ /TAPE READ ERROR/   ;
        .EVEN                      ;
5$:     CLR    R0                  ;   FOR I := 2 TO
        MOV    INTEND,R1           ;       (ADDR@(.1.) + 511) DIV 512 DO
        ADD    #511.,R1            ;
        ADC    R0                  ;
        ASHC   #-9.,R0             ;
        DEC    R1                  ;   BEGIN
        BEQ    8$                  ;     ADDR := NEXTPAGE(ADDR);
6$:     MOV    #-512.,MTBRC        ;     READ(TAPE0, ADDR, ERROR);
        INC    MTC                 ;
7$:     TSTB   MTC                 ;
        BGE    7$                  ;
        TST    MTC                 ;     IF ERROR THEN
        BLT    9$                  ;     KERNELERROR(
                                   ;            'TAPE READ ERROR(:0:)');
        SOB    R1,6$               ;   END;
8$:                                ; END "LOADFROMTAPE";
        .ENDC                      ;
                                   ;
;*                                 ; PROCEDURE LOADFROMDISK(SYSTEM:
;*      =      $SDA0               ;                         DISKBLOCK);
;*                                 ;
;*                                 ; CONST DISK0 = 0;
;*                                 ;
;*      =      RKCS                ; VAR ERROR: BOOLEAN;
;*      =      RKBA                ;     ADDR: @PAGE;
;*      =      R1                  ;     SYSTEMLENGTH: INTEGER;
                                   ;
        .IF EQ $.DBTA              ; BEGIN
        MOV    #INTEND, RKBA       ;   ADDR := @PROGRAMSTART;
        MOV    #<-256.>,RKWC       ;   READ(DISK0, ADDR, SYSTEM, 512,
        MOV    $SDA0,R1            ;                             ERROR);
        CLR    R0                  ;   ADDR := NEXTPAGE(ADDR);
        DIV    #12.,R0             ;
        ASH    #4,R0               ;
        BIS    R1,R0               ;
        MOV    R0,RKDA             ;
	BIS    UNITNO,RKDA	   ;<01> SET PROPER UNIT NUMBER
      $ =      <RCSFUN*RCFRD>+RCSGO;
        MOV    #$,RKCS             ;
1$:     TSTB   RKCS                ;
        BGE    1$                  ;
        TST    RKCS                ;   IF ERROR THEN
        BGE    5$                  ;     KERNELERROR(
2$:     CLR    HEAD99+OPLIN1       ;          'SYSTEM LOAD ERROR(:0:)');
        MOV    #3$,RESU19          ;
        JSR    PC,KERN19           ;
3$:     .ASCIZ /SYSTEM LOAD ERROR/ ;
        .EVEN                      ;
5$:     CLR    R0                  ;   SYSTEMLENGTH :=
        MOV    INTEND,R1           ;            ((PROGRAMSTART(.1.) - 1)
        DEC    R1                  ;             DIV 512) * 512;
        ASHC   #<-9.>,R0           ;
        BEQ    7$                  ;
        ASH    #8.,R1              ;
        NEG    R1                  ;
        MOV    R1,RKWC             ;   READ(DISK0, ADDR, SYSTEM+1,
        INC    RKCS                ;               SYSTEMLENGTH, ERROR);
6$:     TSTB   RKCS                ;
        BGE    6$                  ;
        TST    RKCS                ;   IF ERROR THEN
        BLT    2$                  ;     KERNELERROR(
7$:                                ;          'SYSTEM LOAD ERROR(:0:)');
        .ENDC                      ; END "LOADFROMDISK";
                                   ;
                                   ;
                                   ; BEGIN "LOADSYSTEMPROGRAM"
;* CONDITIONAL ASSEMBLY, ABOVE,    ;   IF SYSTEMTAPE THEN
;* DEPENDING ON "$.DBTA".          ;     LOADFROMTAPE ELSE
                                   ;     LOADFROMDISK(SYSTEMBLOCK);
        RESET                      ;   RESETUNIBUS;
        SPL    7                   ;   EXCLUDEINTERRUPTS;
        INC    SSR0                ;   ADDRESSMAPPING := TRUE;
$CLC0:                             ;   "CLEAR REMAINING CORE"
        CLR    R0                  ;   SEGADDR := GETSEGMENTADDRESS(
        MOV    #INTEND,R1          ;                        PROGRAMEND);
        ADD    INTEND,R1           ;
        ADC    R0                  ;
        MOV    R1,R2               ;
        BIC    #017777,R1          ;
        ASHC   #-6,R0              ;
        MOV    KISAR+12.,R0        ;
        MOV    R1,KISAR+12.        ;
        BIC    #160000,R2          ;   SEGINDEX := GETSEGMENTINDEX(
        MOV    R2,R1               ;                        PROGRAMEND);
        ASR    R1                  ;
        NEG    R1                  ;
        MOV    #3$,FETRAP          ;   REPEAT
2$:     ADD    #.SEGSW,R1          ;     FOR I := SEGINDEX TO 4096 DO
        ADD    #140000,R2          ;
1$:     CLR    (R2)+               ;     SEGADDR@(.I.) := 0;
        SOB    R1,1$               ;
        ADD    #.SGSBK,KISAR+12.   ;     SEGADDR := GETNEXTSEGMENT(
        CLR    R2                  ;                           SEGADDR);
        CMP    #.PRBLK,KISAR+12.   ;     SEGINDEX := 1;
        BNE    2$                  ;   UNTIL SEGADDR = ENDOFCORE;
        SUB    #4,SP               ;
3$:     MOV    #FEINT,FETRAP       ;
        ADD    #4,SP               ;
        MOV    KISAR+12.,COREC9    ;   CORECAPACITY := BLOCKNUMBER(
        MOV    R0,KISAR+12.        ;                           SEGADDR);
        VERCOR                     ;
        .IF EQ $.DBNC              ;
        MOV    #LKSINE,LKS         ;   STARTLINEFREQUENCYCLOCK;
        .ENDC                      ;
        MOV    #KNEXIT,R0          ; END;
        JSR    R0,INIT36           ;
                                   ;
                                   ;
        .PAGE
        .SBTTL END OF THE KERNEL MODULE PREFACE
        .SBTTL
        .SBTTL #########################################################
        .SBTTL

;*
;*
;*
;*
;*
;*
;*
;*
;***********************************************************************
;***********************************************************************
;***********************************************************************
;****                                                              *****
;****                                                              *****
;****                                                              *****
;****          THIS MARKS THE END OF THE KERNEL MODULE PREFACE.    *****
;****                                                              *****
;****   THE CODE PROPER OF THE KERNEL FOLLOWS:                     *****
;****                                                              *****
;****                                                              *****
;****                                                              *****
;***********************************************************************
;***********************************************************************
;***********************************************************************
;*                                 ;
;*                                 ;
;*                                 ;
;*                                 ;
;*                                 ;
;*                                 ;
;*                                 ;
;*                                 ;
;*                                 ;
;*                                 ;
                                   ;"KERNELTEXT2"
        .PAGE
        .SBTTL DEFINITIONS OF BASIC KERNEL DATA TYPES
                                   ;"###################################
                                   ;              #  BASIC DATA TYPES  #
                                   ;###################################"
                                   ;
                                   ;
;**********************************;
; IN THE CODE THAT FOLLOWS WE SHALL;
; ALWAYS FEEL FREE TO ASSUME THAT  ;
; ALL RECORD FIELDS ARE ALLOCATED  ;
; CONSECUTIVELY IN THE ORDER OF    ;
; THEIR DECLARATION.               ;
;**********************************;
                                   ;
                                   ;
NIL     =      0                   ; CONST NIL = 0;
GATES   =      25.                 ;       GATES = 25; "MONITOR GATES"
PROCS   =      10.                 ;       PROCESSES = 10; "PROCESSES"
                                   ;
                                   ;
PROCESS =      0                   ; TYPE PROCESS =
      $ =      PROCESS             ;   RECORD
LINK0   =      $                   ;     "QUEUE LINK"
      $ =      $ + .QUEUETYPE      ;
HEAD0   =      $                   ;     HEAD:
      $ =      $ + .HEADTYPE       ;           HEADTYPE;
REG0    =      $                   ;     REG:
      $ =      $ + .REGTYPE        ;          REGTYPE;
MAP0    =      $                   ;     MAP:
      $ =      $ + .MAPTYPE        ;          MAPTYPE;
.PROCESS=      $ - PROCESS         ;   END;
                                   ;
                                   ;
HEADTYPE=      0                   ; TYPE HEADTYPE =
      $ =      HEADTYPE            ;   RECORD
INDEX1  =      $                   ;     INDEX:
      $ =      $ + .INTEGER        ;            INTEGER;
HEAPT1  =      $                   ;     HEAPTOP:
      $ =      $ + .INTEGER        ;              INTEGER;
LINE1   =      $                   ;     LINE:
      $ =      $ + .INTEGER        ;           INTEGER;
RESUL1  =      $                   ;     RESULT:
      $ =      $ + .INTEGER        ;             INTEGER;
RUNTI1  =      $                   ;     RUNTIME:
      $ =      $ + .TIME           ;              TIME;
SLICE1  =      $                   ;     SLICE:
      $ =      $ + .INTEGER        ;            INTEGER;
NESTI1  =      $                   ;     NESTING:
      $ =      $ + .INTEGER        ;              INTEGER;
PRIOR1  =      $                   ;     PRIORITY:
      $ =      $ + .INTEGER        ;               INTEGER;
OVERT1  =      $                   ;     OVERTIME:
      $ =      $ + .BOOLEAN        ;               BOOLEAN;
JOB1    =      $                   ;     JOB:
      $ =      $ + .BOOLEAN        ;          BOOLEAN;
CONTI1  =      $                   ;     CONTINUE:
      $ =      $ + .BOOLEAN        ;               BOOLEAN;
OPCOD1  =      $                   ;     OPCODE:
      $ =      $ + .INTEGER        ;             INTEGER;
PARAM1  =      $                   ;     PARAM:
      $ =      $ + <4. * .INTEGER> ;            ARRAY (.1..4.) OF
                                   ;                            INTEGER;
OPLIN1  =      $                   ;     OPLINE:
      $ =      $ + .INTEGER        ;             INTEGER;
        CHKDTL HEADTYPE            ;   END;
                                   ;
                                   ;
REGTYPE =      0                   ; TYPE REGTYPE =
      $ =      REGTYPE             ;   RECORD
W2      =      $                   ;     W:
      $ =      $ + .INTEGER        ;        INTEGER;
X2      =      $                   ;     X:
      $ =      $ + .INTEGER        ;        INTEGER;
Y2      =      $                   ;     Y:
      $ =      $ + .INTEGER        ;        INTEGER;
Q2      =      $                   ;     Q:
      $ =      $ + .INTEGER        ;        INTEGER;
B2      =      $                   ;     B:
      $ =      $ + .INTEGER        ;        INTEGER;
G2      =      $                   ;     G:
      $ =      $ + .INTEGER        ;        INTEGER;
S2      =      $                   ;     S:
      $ =      $ + .INTEGER        ;        INTEGER;
P2      =      $                   ;     P:
      $ =      $ + .INTEGER        ;        INTEGER;
PSTAT2  =      $                   ;     PSTATUS:
      $ =      $ + .INTEGER        ;               INTEGER;
FW2     =      $                   ;     FW:
      $ =      $ + .REAL           ;         REAL;
FX2     =      $                   ;     FX:
      $ =      $ + .REAL           ;         REAL;
FSTAT2  =      $                   ;     FSTATUS:
      $ =      $ + .INTEGER        ;              INTEGER;
        CHKDTL REGTYPE             ;   END;
                                   ;
                                   ;
MAPTYPE =      0                   ; TYPE MAPTYPE =
      $ =      MAPTYPE             ;
      $ =      $ + <8. * .INTEGER> ;   ARRAY (.0..7.) OF INTEGER;
        CHKDTL MAPTYPE             ;
                                   ;
                                   ;
PROCREF =      0                   ; TYPE PROCESSREF =
      $ =      PROCREF             ;
      $ =      $ + .ADDRESS        ;   @PROCESS;
.PROCREF=      $ - PROCREF         ;
                                   ;
                                   ;
PROCQUE =      0                   ; TYPE PROCESSQUEUE =
      $ =      PROCQUE             ;
      $ =      $ + .QUEUETYPE      ;   SEQUENCE OF PROCESSREF;
.PROCQUE=      $ - PROCQUE         ;
                                   ;
                                   ;
        .PAGE
                                   ;"###################################
                                   ;                       #  NEWCORE  #
                                   ;###################################"
                                   ;
                                   ;
; THIS CLASS MUST BE PLACED FIRST  ; VAR NEWCORE:
; IN THE KERNEL SO AS TO OVERLAP   ; CLASS
; THE CORE OCCUPIED BY THE TRANSI- ;
; ENT INITIALIZER BEGINNING AT LOC-;
; ATION "$KNL0".                   ;
                                   ;
     $G =      GATES * .GATE       ; CONST SPACE = GATES*GATELENG +
     $P =      PROCS * .PROCESS    ;               PROCESSES*PROCESSLENG
     $S =      $G + $P             ;
     $M =      . - $KNL0           ;
     $D =      $S - $M             ;
        .IF LT $D                  ;
     $S =      $M                  ;
     $D =      0                   ;
        .ENDC                      ;
        .BLKB  $D                  ;
SPAC16  =      $S                  ;
SLIM16:                            ;       SPACELIMIT =
        .ASCIZ /SPACE LIMIT/       ;                 'SPACE LIMIT(:0:)';
        .EVEN                      ;
BASE16  =      $KNL0               ;       BASEADDR = ...;
        .EVEN                      ;
TOP16:  .WORD  BASE16              ; VAR TOP: INTEGER;
FREE16: .WORD  SPAC16              ;     FREE: INTEGER;
                                   ;
                                   ;
LENG16: .BLKB  .INTEGER            ; FUNCTION NEW(LENGTH: INTEGER):
NEW16R: .BLKB  .INTEGER            ;                            INTEGER;
                                   ;
NEW16:  MOV    LENG16,R0           ; BEGIN
        CMP    R0,FREE16           ;   IF LENGTH > FREE THEN
        BLE    1$                  ;
        MOV    #SLIM16,RESU19      ;     KERNELERROR(SPACELIMIT);
        JSR    PC,KERN19           ;
1$:     MOV    TOP16,NEW16R        ;   NEW := TOP;
        ADD    R0,TOP16            ;   TOP :+ LENGTH;
        SUB    R0,FREE16           ;   FREE :- LENGTH;
        RTS    PC                  ; END;
                                   ;
                                   ;
INIT16:                            ; BEGIN
; DONE AT LABEL "TOP16".           ;   TOP := BASEADDR;
; DONE AT LABEL "FREE16".          ;   FREE := SPACE;
        RTS    PC                  ; END;
                                   ;
                                   ;
        .PAGE
                                   ;"###################################
                                   ;                     #  QUEUETYPE  #
                                   ;###################################"
                                   ;
                                   ;
QUTP4T: .BLKB  .ADDRESS            ; TYPE QUEUETYPE =
                                   ; CLASS
                                   ;
QUEUETYP=      0                   ; VAR
      $ =      QUEUETYPE           ;
SUCC4   =      $                   ;   SUCC:
      $ =      $ + .ADDRESS        ;         @QUEUETYPE;
PRED4   =      $                   ;   PRED:
      $ =      $ + .ADDRESS        ;         @QUEUETYPE;
        CHKDTL QUEUETYPE           ;
                                   ;
                                   ;
GET4R:  .BLKB  .ADDRESS            ; FUNCTION GET: @QUEUETYPE;
                                   ;
;FIRST  IS     R5                  ; VAR FIRST, SECOND: @QUEUETYPE;
;SECOND IS     R4                  ;
                                   ;
GET4:   MOV    QUTP4T,R0           ; BEGIN
        MOV    (R0),R5             ;   FIRST := SUCC;
        MOV    (R5),R4             ;   SECOND := FIRST.SUCC;
        MOV    R4,(R0)             ;   SUCC := SECOND;
        MOV    PRED4(R5),PRED4(R4) ;   SECOND.PRED := FIRST.PRED;
        MOV    R5,GET4R            ;   GET := FIRST;
        QTRACE GET                 ;
        RTS    PC                  ; END;
                                   ;
                                   ;
                                   ; PROCEDURE PUT(NEWELEM:
NEWEL4: .BLKB  .ADDRESS            ;                       @QUEUETYPE);
;LAST   IS     R5                  ; VAR LAST: @QUEUETYPE;
                                   ;
PUT4:   MOV    QUTP4T,R0           ; BEGIN
        MOV    NEWEL4,R1           ;
        MOV    PRED4(R0),R5        ;   LAST := PRED;
        MOV    R1,PRED4(R0)        ;   PRED := NEWELEM;
        MOV    R5,PRED4(R1)        ;   NEWELEM.PRED := LAST;
        MOV    (R5),(R1)           ;   NEWELEM.SUCC := LAST.SUCC;
        MOV    R1,(R5)             ;   LAST.SUCC := NEWELEM;
        QTRACE PUT                 ;
        RTS    PC                  ; END;
                                   ;
                                   ;
        .MACRO ANY4 Q,FL           ; FUNCTION ANY: BOOLEAN;
                                   ;
                                   ; "WE ASSUME THAT THIS FUNCTION AND
                                   ;  EMPTY, BELOW, WILL NOT BE USED
                                   ;  IN ASSIGNMENT STATEMENTS"
                                   ;
                                   ; BEGIN
        CMP    Q,(Q)               ;   ANY := SUCC <> THIS QUEUETYPE;
        BEQ    FL                  ;
        .ENDM  ANY4                ; END;
                                   ;
                                   ;
        .MACRO EMPTY4 Q,FL         ; FUNCTION EMPTY: BOOLEAN;
                                   ;
        CMP    Q,(Q)               ;   EMPTY := SUCC = THIS QUEUETYPE;
        BNE    FL                  ;
        .ENDM  EMPTY4              ; END;
                                   ;
                                   ;
INIT4:  MOV    QUTP4T,R0           ; BEGIN
        MOV    R0,R1               ;
        MOV    R1,(R0)+            ;   SUCC := THIS QUEUETYPE;
        MOV    R1,(R0)             ;   PRED := THIS QUEUETYPE;
        RTS    PC                  ; END;
                                   ;
                                   ;
        .PAGE
                                   ;"###################################
                                   ;                        #  SIGNAL  #
                                   ;###################################"
                                   ;
                                   ;
SIG26T: .BLKB  .ADDRESS            ; TYPE SIGNAL =
                                   ; CLASS
                                   ;
SIGNAL  =      0                   ; VAR AWAITING: PROCESSQUEUE;
      $ =      SIGNAL              ;
      $ =      $ + .PROCQUE        ;
.SIGNAL =      $ - SIGNAL          ;
                                   ;
                                   ; PROCEDURE AWAIT;
                                   ;
AWAI26:                            ; BEGIN
        JSR    PC,PREE11           ;   AWAITING.PUT(RUNNING.PREEMPTED);
        MOV    PRE11R,NEWEL4       ;
        MOV    SIG26T,QUTP4T       ;
        JSR    PC,PUT4             ;
        RTS    PC                  ; END;
                                   ;
                                   ;
                                   ; PROCEDURE SEND;
                                   ;
SEND26:                            ; BEGIN
        MOV    SIG26T,R0           ;   IF AWAITING.ANY THEN
        ANY4   R0,1$               ;   BEGIN
2$:                                ;     REPEAT
        MOV    R0,QUTP4T           ;       READY.ENTER(AWAITING.GET);
        JSR    PC,GET4             ;
        MOV    GET4R,P12           ;
        JSR    PC,ENTE12           ;
        MOV    SIG26T,R0           ;     UNTIL AWAITING.EMPTY;
        EMPTY4 R0,2$               ;
        JSR    PC,RESC12           ;     READY.RESCHEDULE;
                                   ;   END;
1$:     RTS    PC                  ; END;
                                   ;
                                   ;
INIT26:                            ; BEGIN
        MOV    SIG26T,QUTP4T       ;   AWAITING.INITIALIZE;
        JSR    PC,INIT4            ;
        RTS    PC                  ; END "OF SIGNAL";
                                   ;
                                   ;
        .PAGE
        .SBTTL KERNEL TIMING PROCESSES
                                   ;"###################################
                                   ;                          #  TIME  #
                                   ;###################################"
                                   ;
                                   ;
TIME5T: .BLKB  .ADDRESS            ; TYPE TIME =
                                   ; CLASS
                                   ;
TIME    =      0                   ; VAR ENTRY
      $ =      TIME                ;
SEC5    =      $                   ;   SEC:
      $ =      $ + .INTEGER        ;        INTEGER;
FRACT5  =      $                   ;   FRACTION:
      $ =      $ + .INTEGER        ;             INTEGER; "FRACTION
                                   ;     UNIT = 0.1 MILLISECOND"
        CHKDTL TIME                ;
                                   ;
                                   ;
INCR5:  .BLKB  .INTEGER            ; PROCEDURE ADD(INCR: INTEGER);
                                   ;
ADD5:   MOV    TIME5T,R0           ; BEGIN
        ADD    INCR5,FRACT5(R0)    ;   FRACTION :+ INCR;
        CMP    FRACT5(R0),#10000.  ;   IF FRACTION >= 10000 THEN
        BLT    1$                  ;   BEGIN
        INC    SEC5(R0)            ;     SEC :+ 1;
        SUB    #10000.,FRACT5(R0)  ;     FRACTION :- 10000;
1$:                                ;   END;
        RTS    PC                  ; END;
                                   ;
                                   ;
INIT5:  MOV    TIME5T,R0           ; BEGIN
        CLR    SEC5(R0)            ;   SEC := 0;
        CLR    FRACT5(R0)          ;   FRACTION := 0;
        RTS    PC                  ; END;
                                   ;
                                   ;
        .PAGE
                                   ;"###################################
                                   ;                         #  TIMER  #
                                   ;###################################"
                                   ;
                                   ;
                                   ; VAR TIMER:
                                   ; CLASS
                                   ;
SMALL6  =      10.                 ; CONST SMALLINCR = 10;
LARGE6  =      167.                ;       LARGEINCR = 167;
                                   ;
PERIO6: .WORD  0                   ; VAR PERIOD: INTEGER;
                                   ;
                                   ;
                                   ; FUNCTION ELAPSED: INTEGER;
                                   ;
        .MACRO ELAPS6              ; BEGIN
        MOV    PERIO6,R0           ;   ELAPSED := PERIOD + SMALLINCR;
        ADD    #SMALL6,R0          ;
        CLR    PERIO6              ;   PERIOD := 0;
        .ENDM  ELAPS6              ; END;
                                   ;
                                   ;
INTER6: .BLKB  .INTEGER            ; PROCEDURE TICK(INTERVAL: INTEGER);
                                   ;
TICK6:                             ; BEGIN
        ADD    #LARGE6,PERIO6      ;   PERIOD :+ LARGEINCR;
        RTS    PC                  ; END;
                                   ;
                                   ;
                                   ; PROCEDURE RESET;
                                   ;
        .MACRO RESET6              ; BEGIN
        CLR    PERIO6              ;   PERIOD := 0;
        .ENDM  RESET6              ; END;
                                   ;
                                   ;
INIT6:                             ; BEGIN
; DONE AT LABEL "PERIO6".          ;   PERIOD := 0;
        RTS    PC                  ; END;
                                   ;
        .PAGE
                                   ;"###################################
                                   ;                         #  CLOCK  #
                                   ;###################################"
                                   ;
                                   ;
                                   ; VAR CLOCK:
                                   ; CLASS
                                   ;
WAITT7  =      1                   ; CONST WAITTIME = 1;
                                   ;
NOW7:   .BLKB  .TIME               ; VAR NOW: TIME;
NEXTT7: .BLKB  .SIGNAL             ;     NEXTTIME: SIGNAL;
                                   ;
                                   ;
                                   ; PROCEDURE INCREMENT(INTERVAL:
INTER7: .BLKB  .INTEGER            ;                        INTEGER);
;P      IS     GET4R, P12          ; VAR P: PROCESSREF;
LASTT7: .BLKB  .INTEGER            ;     LASTTIME: INTEGER;
                                   ;
INCRE7:                            ; BEGIN
        MOV    NOW7+SEC5,LASTT7    ;   LASTTIME := NOW.SEC;
        MOV    #NOW7,TIME5T        ;   NOW.ADD(INTERVAL);
        MOV    INTER7,INCR5        ;
        JSR    PC,ADD5             ;
        MOV    LASTT7,R0           ;   IF NOW.SEC >=
        ADD    #WAITT7,R0          ;            LASTTIME + WAITTIME THEN
        CMP    NOW7+SEC5,R0        ;
        BLT    1$                  ;
        MOV    #NEXTT7,SIG26T      ;   NEXTTIME.SEND;
        JSR    PC,SEND26           ;
1$:     RTS    PC                  ; END;
                                   ;
                                   ;
WAIT7:                             ; PROCEDURE ENTRY WAIT;
                                   ;
                                   ; BEGIN
        MOV    #NEXTT7,SIG26T      ;   NEXTTIME.AWAIT;
        JSR    PC,AWAI26           ;
        RTS    PC                  ; END;
                                   ;
                                   ;
REALT7:                            ; FUNCTION ENTRY REALTIME: INTEGER;
                                   ;
     $$ =      NOW7 + SEC5         ; BEGIN
        MOV    $$,<HEAD99+PARAM1>  ;   REALTIME := NOW.SEC;
        RTS    PC                  ; END;
                                   ;
                                   ;
INIT7:                             ; BEGIN
        MOV    #NOW7,TIME5T        ;   NOW.INITIALIZE;
        JSR    PC,INIT5            ;
        MOV    #NEXTT7,SIG26T      ;   NEXTTIME.INITIALIZE;
        JSR    PC,INIT26           ;
        RTS    PC                  ; END;
                                   ;
                                   ;
                                   ;
        .PAGE
                                   ;"###################################
                                   ;               #  CLOCK INTERRUPT  #
                                   ;###################################"
                                   ;
                                   ;
                                   ; PROCEDURE ENTRY CLOCKINTERRUPT;
                                   ;
INTER8  =      LARGE6              ; CONST INTERVAL = 167;
                                   ;        "UNIT = 0.1 MILLISECOND"
                                   ;
CLOCK8:                            ; BEGIN
        MOV    #INTER8,INTER6      ;   TIMER.TICK(INTERVAL);
        JSR    PC,TICK6            ;
        MOV    #INTER8,INTER7      ;   CLOCK.INCREMENT(INTERVAL);
        JSR    PC,INCRE7           ;
        JSR    PC,RESC12           ;   READY.RESCHEDULE;
        RTS    PC                  ; END;
                                   ;
                                   ;
        .PAGE
        .SBTTL CORE ALLOCATION
                                   ;"###################################
                                   ;                          #  CORE  #
                                   ;###################################"
                                   ;
                                   ;
                                   ; VAR CORE:
                                   ; CLASS
                                   ;
COREL9:                            ; CONST CORELIMIT =
        .ASCIZ /CORE LIMIT/        ;                  'CORE LIMIT(:0:)';
        .EVEN                      ;
COREC9: .WORD  1536.               ;       CORECAPACITY = 1536 "BLOCKS";
                                   ;             " = 48 KILOWORDS"
                                   ;
      $ =      USER99 - ZERO       ; VAR TOP "BLOCK": INTEGER;
TOP9:   .WORD  $ / .BLKSB          ;
FREE9:  .BLKB  .INTEGER            ;     FREE "BLOCKS": INTEGER;
                                   ;
                                   ;
LENGT9: .BLKB  .INTEGER            ; PROCEDURE ALLOC(LENGTH: INTEGER;
FIRST9: .BLKB  .ADDRESS            ;              VAR FIRST: INTEGER);
;BLOCKS IS     R4                  ; VAR BLOCKS: INTEGER;
                                   ;
ALLOC9:                            ; BEGIN
        MOV    LENGT9,R5           ;   BLOCKS := (LENGTH + 63) DIV 64;
        CLR    R4                  ;
        ADD    #<.BLKSB-1>,R5      ;
        ADC    R4                  ;
        DIV    #.BLKSB,R4          ;
        CMP    R4,FREE9            ;   IF BLOCKS > FREE THEN
        BLE    1$                  ;
        MOV    #COREL9,RESU19      ;     KERNELERROR(CORELIMIT);
        JSR    PC,KERN19           ;
1$:     MOV    TOP9,@FIRST9        ;   FIRST := TOP;
        ADD    R4,TOP9             ;   TOP :+ BLOCKS;
        SUB    R4,FREE9            ;   FREE :- BLOCKS;
        RTS    PC                  ; END;
                                   ;
                                   ;
INIT9:                             ; BEGIN
; DONE AT LABEL "TOP9".            ;   TOP := HEADADDR DIV 64;
        MOV    COREC9,R0           ;   FREE := CORECAPACITY - TOP;
        SUB    TOP9,R0             ;
        MOV    R0,FREE9            ;
        RTS    PC                  ; END;
                                   ;
                                   ;
        .PAGE
        .SBTTL VIRTUAL MEMORY
                                   ;"###################################
                                   ;                       #  VIRTUAL  #
                                   ;###################################"
                                   ;
                                   ;
                                   ; VAR VIRTUAL:
                                   ; CLASS
                                   ;
VIRT10:                            ; CONST VIRTUALLIMIT =
        .ASCIZ /VIRTUAL LIMIT/     ;               'VIRTUAL LIMIT(:0:)';
        .EVEN                      ;
                                   ;
HARD10  =      UISAR               ; VAR HARDWAREMAP: MAPTYPE;
COMM10: .BLKB  .INTEGER            ;     COMMON: INTEGER;
HEAP10: .BLKB  .INTEGER            ;     ENTRY HEAPTOP: INTEGER;
                                   ;
                                   ;
                                   ; PROCEDURE DEFCOMMON(LENGTH:
CLEN10: .BLKB  .INTEGER            ;                           INTEGER);
CBAS10: .BLKB  .INTEGER            ; VAR BASE: INTEGER;
;PAGE   IS     R3                  ;     PAGE: INTEGER;
                                   ;
DEFC10:                            ; BEGIN
        MOV    CLEN10,LENGT9       ;   CORE.ALLOC(LENGTH, BASE);
        MOV    #CBAS10,FIRST9      ;
        JSR    PC,ALLOC9           ;
        MOV    CLEN10,R1           ;   COMMON := (LENGTH + 8191) DIV
        CLR    R0                  ;                               8192;
        ADD    #<.SEGSB-1>,R1      ;
        ADC    R0                  ;
        DIV    #.SEGSB,R0          ;
        MOV    R0,COMM10           ;
        CMP    R0,#8.              ;   IF COMMON > 8 THEN
        BLE    1$                  ;     KERNELERROR(VIRTUALLIMIT);
        MOV    #VIRT10,RESU19      ;
        JSR    PC,KERN19           ;
1$:     MOV    CBAS10,R1           ;   FOR PAGE := 0 TO COMMON - 1 DO
        MOV    #HARD10,R3          ;   BEGIN
2$:     MOV    R1,(R3)+            ;     HARDWAREMAP(.PAGE.) := BASE;
        ADD    #.SGSBK,R1          ;     BASE :+ 128;
        SOB    R0,2$               ;   END;
        MOV    COMM10,R1           ;   HEAPTOP := COMMON * 8192;
        MUL    #.SEGSB,R1          ;
        MOV    R1,HEAP10           ;
        RTS    PC                  ; END;
                                   ;
                                   ;
                                   ; PROCEDURE DEFPRIVATE(LENGTH:
PLEN10: .BLKB  .INTEGER            ;                           INTEGER);
PBAS10: .BLKB  .INTEGER            ; VAR BASE: INTEGER;
;PAGE   IS     R3                  ;     PAGE: INTEGER;
;TOTAL  IS     R0                  ;     TOTAL: INTEGER;
                                   ;
DEFP10:                            ; BEGIN
        MOV    PLEN10,LENGT9       ;   CORE.ALLOC(LENGTH, BASE);
        MOV    #PBAS10,FIRST9      ;
        JSR    PC,ALLOC9           ;
        MOV    PLEN10,R1           ;   TOTAL := (LENGTH + 8191) DIV 8192
        ADD    #<.SEGSB-1>,R1      ;            + COMMON;
        CLR    R0                  ;
        DIV    #.SEGSB,R0          ;
        MOV    COMM10,R3           ;
        ADD    R3,R0               ;
        CMP    R0,#8.              ;   IF TOTAL > 8 THEN
        BLE    1$                  ;     KERNELERROR(VIRTUALLIMIT);
        MOV    #VIRT10,RESU19      ;
        JSR    PC,KERN19           ;
1$:     MOV    PBAS10,R1           ;   FOR PAGE := COMMON TO TOTAL - 1
        SUB    R3,R0               ;   DO
        ASL    R3                  ;
        ADD    #HARD10,R3          ;   BEGIN
2$:     MOV    R1,(R3)+            ;     HARDWAREMAP(.PAGE.) := BASE;
        ADD    #.SGSBK,R1          ;     BASE :+ 128;
        SOB    R0,2$               ;   END;
        RTS    PC                  ; END;
                                   ;
                                   ;
P10:    .BLKB  .PROCREF            ; PROCEDURE GETMAP(P: PROCESSREF);
;PAGE   IS     R0, R2              ; VAR PAGE: INTEGER;
                                   ;
GETM10:                            ; BEGIN
        MOV    COMM10,R0           ;   FOR PAGE := COMMON TO 7 DO
        MOV    #8.,R1              ;
        SUB    R0,R1               ;
        ASL    R0                  ;
        MOV    R0,R2               ;
        ADD    #HARD10,R0          ;
        ADD    P10,R2              ;   WITH P@ DO
        ADD    #MAP0,R2            ;
1$:     MOV    (R2)+,(R0)+         ;   HARDWAREMAP(.PAGE.) :=
                                   ;                       MAP(.PAGE.);
        SOB    R1,1$               ; END;
        RTS    PC                  ;
                                   ;
                                   ;
                                   ; PROCEDURE PUTMAP;
;PAGE   IS     R0, R2              ; VAR PAGE: INTEGER;
                                   ;
PUTM10:                            ; BEGIN
        MOV    COMM10,R0           ;   FOR PAGE := COMMON TO 7 DO
        MOV    #8.,R1              ;
        SUB    R0,R1               ;
        ASL    R0                  ;
        MOV    R0,R2               ;
        ADD    #HARD10,R0          ;
        ADD    USER99,R2           ;   WITH RUNNING.USER@ DO
        ADD    #MAP0,R2            ;
1$:     MOV    (R0)+,(R2)+         ;   MAP(.PAGE.) :=
                                   ;               HARDWAREMAP(.PAGE.);
        SOB    R1,1$               ; END;
        RTS    PC                  ;
                                   ;
                                   ;
                                   ; PROCEDURE REALADDRESS(
VTLA10: .BLKB  .ADDRESS            ;            VIRTUALADDRESS: ADDRESS;
PREF10: .BLKB  .ADDRESS            ;            VAR PREFIX: 0..3;
REST10: .BLKB  .ADDRESS            ;            VAR REST: ADDRESS);
                                   ;
                                   ; TYPE LONGADDRESS = 0..262143;
                                   ;
;AD     IS     R1                  ; VAR AD: ADDRESS;
;I      IS     R0                  ;     I: 0..7;
;RAD    IS     R2 AND R3           ;     RAD: LONGADDRESS;
                                   ;
REAL10:                            ; BEGIN
        MOV    VTLA10,R1           ;   AD := VIRTUALADDRESS;
        MOV    R1,R0               ;   I := AD DIV 8192;
        SWAB   R0                  ;
        ASH    #-4,R0              ;
        BIC    #^C000016,R0        ;   "I=PAGENUMBER(VIRTUALADDRESS)"
        BIC    #^C017777,R1        ;   AD := AD MOD 8192;
                                   ;   "AD=BYTE NUMBER IN PAGE"
        CLR    R2                  ;   RAD := AD + HARDWAREMAP(.I.)*64;
        MOV    HARD10(R0),R3       ;
        ASHC   #6,R2               ;
        ADD    R1,R3               ;
        ADC    R2                  ;   "RAD=REAL ADDRESS OF BYTE"
        MOV    R2,@PREF10          ;   PREFIX := RAD DIV 65536;
        MOV    R3,@REST10          ;   REST := RAD MOD 65536;
        RTS    PC                  ; END;
                                   ;
                                   ;
INIT10:                            ; BEGIN
        MOV    #UISDR,R0           ;   "SET ALL SEGMENTS TO 4K WORDS
        MOV    #8.,R1              ;    WITH READ/WRITE/EXECUTE ACCESS
1$:     MOV    #USDR,(R0)+         ;    AND LET THE DATA SPACE SEGMEN-
        SOB    R1,1$               ;    TATION REMAIN DISABLED"
        RTS    PC                  ; END;
                                   ;
                                   ;
        .PAGE
        .SBTTL THE CURRENTLY RUNNING PROGRAM
                                   ;"###################################
                                   ;                       #  RUNNING  #
                                   ;###################################"
                                   ;
                                   ;
                                   ; VAR RUNNING:
                                   ; CLASS
                                   ;
PLIM11:                            ; CONST PARAMLIMIT =
        .ASCIZ /PARAMETER LIMIT/   ;             'PARAMETER LIMIT(:0:)';
        .EVEN                      ;
MAX11   =      20.                 ;       MAX = 20;
FLOA11  =      FSTAT0              ;       FLOATSTATUS = ...;
PGST11  =      USRPSW              ;       PROGSTATUS = ...;
STAR11  =      STARTADDR - USER99  ;       STARTADDR = ...;
                                   ;
                                   ; VAR ENTRY
USER11  =      USER99              ;   USER: PROCESSREF;
                                   ;     ENTRY
HEAD11  =      HEAD99              ;   HEAD: HEADTYPE;
CONS11  =      CONS99              ;   CONSTADDR: INTEGER;
                                   ;
PARA11: .REPT  MAX11               ;   PARAM: ARRAY (.1..MAX.) OF
        .BLKB  .INTEGER            ;                            INTEGER;
        .ENDR                      ;
NEXT11: .WORD  1                   ;   NEXTINDEX: INTEGER;
                                   ;     ENTRY
PRID11: .REPT  PROCS               ;   PROCESSID: ARRAY (.1..PROCESSES.)
        .BLKB  .PROCREF            ;                      OF PROCESSREF;
        .ENDR                      ;
                                   ; "HARDWARE"
                                   ;   REG: REGTYPE;
                                   ;
                                   ;
P11:    .BLKB  .PROCREF            ; PROCEDURE SERVE(P: PROCESSREF);
                                   ;
SERV11:                            ; BEGIN
        RESET6                     ;   TIMER.RESET;
        MOV    P11,R0              ;   USER := P;
        MOV    R0,USER11           ;
        MOV    #HEAD11,R1          ;   HEAD := USER@.HEAD;
        ADD    #HEAD0,R0           ;
      $ =      .HEADTYP / .INTEGER ;
        .REPT  $                   ;
        MOV    (R0)+,(R1)+         ;
        .ENDR                      ;
        MOV    SP,R1               ;   REG := USER@.REG;
        MOV    R0,SP               ;
        BIS    #<PSPMDU>,PSW	   ;<01> SET PREVIOUS USER MODE
        MOV    (SP)+,KSR0          ;<01>
        MOV    (SP)+,KSR1          ;<01>
        MOV    (SP)+,KSR2          ;<01>
        MOV    (SP)+,KSR3          ;<01>
        MOV    (SP)+,KSR4          ;<01>
        MOV    (SP)+,KSR5          ;<01>
        MOV    SP,R0               ;
        MOV    R1,SP               ;
        MOV    (R0)+,-(SP)         ;
        MTPI   SP                  ;
        MOV    (R0)+,KSOPC         ;
	.IF	DF,F$PU		   ;<01>	ONLY IF FPU PRESENT
        MOV    (R0)+,KSOPSW        ;
        LDD    (R0)+,W             ;
        LDD    (R0)+,X             ;
        LDFPS  (R0)                ;
	.IFF			   ;<01>
        MOV    (R0),KSOPSW         ;<01>
	.ENDC			   ;<01>
        MOV    USER11,P10          ;   VIRTUAL.GETMAP(USER);
        JSR    PC,GETM10           ;
                                   ;   WITH HEAD DO
        TST    HEAD11+NESTI1       ;   IF NESTING = 0 THEN
        BNE    1$                  ;
        CLR    HEAD11+OVERT1       ;   OVERTIME := FALSE;
1$:     RTS    PC                  ; END;
                                   ;
                                   ;
.SBTTL	PSW FETCH ROUTINE
;<01>
;<01>	THIS SERVICE RETURNS THE PSW CONTENTS IN R0 (USED ONLY BY SOFTWARE
;<01>	FLOATING POINT).
;<01>
	.IF	NDF,F$PU	;<01> ONLY IF NO FPU
EMTPRO:
	MOV	KSOPSW,R0	;<01> FETCH PSW
	RTI			;<01> AND RETURN
	.ENDC			;<01>
PRE11R: .BLKB  .PROCREF            ; FUNCTION PREEMPTED: PROCESSREF;
                                   ;
PREE11:                            ; BEGIN
        JSR    PC,UPDA11           ;   UPDATE;
        MOV    USER11,R0           ;   USER@.HEAD := HEAD;
        ADD    #HEAD0,R0           ;
        MOV    #HEAD11,R1          ;
      $ =      .HEADTYP / .INTEGER ;
        .REPT  $                   ;
        MOV    (R1)+,(R0)+         ;
        .ENDR                      ;
        MOV    SP,R1               ;   USER@.REG := REG;
        MOV    R0,SP               ;

        MOV    KSR0,(SP)+          ;<01>
        MOV    KSR1,(SP)+          ;<01>
        MOV    KSR2,(SP)+          ;<01>
        MOV    KSR3,(SP)+          ;<01>
        MOV    KSR4,(SP)+          ;<01>
        MOV    KSR5,(SP)+          ;<01>

        MOV    SP,R0               ;
        MOV    R1,SP               ;
        MFPI   SP                  ;
        MOV    (SP)+,(R0)+         ;
        MOV    KSOPC,(R0)+         ;
	.IF    DF,F$PU		   ;<01>	ONLY IF FPU PRESENT
        MOV    KSOPSW,(R0)+        ;
        STD    W,(R0)+             ;
        STD    X,(R0)+             ;
        STFPS  (R0)                ;
	.IFF			   ;<01>
        MOV    KSOPSW,(R0)         ;<01>
	.ENDC			   ;<01>
        MOV    USER11,PRE11R       ;   PREEMPTED := USER;
        CLR    USER11              ;   USER := NIL;
        RTS    PC                  ; END;
                                   ;
                                   ;
                                   ; PROCEDURE UPDATE;
                                   ;
MAXS11  =      167.                ; CONST MAXSLICE = 167;
                                   ;
NEWS11: .BLKB  .INTEGER            ; VAR NEWSLICE: INTEGER;
                                   ;
UPDA11:                            ; BEGIN
                                   ;   WITH HEAD DO
                                   ;   BEGIN
        ELAPS6                     ;     SLICE :+ TIMER.ELAPSED;
        MOV    R0,R1               ;
        ADD    HEAD11+SLICE1,R1    ;
        MOV    R1,HEAD11+SLICE1    ;
        CMP    R1,#MAXS11          ;     IF SLICE >= MAXSLICE THEN
        BLT    1$                  ;     BEGIN
        CLR    R0                  ;       NEWSLICE :=
        DIV    #MAXS11,R0          ;                 SLICE MOD MAXSLICE;
        MOV    R1,NEWS11           ;
        MOV    HEAD11+SLICE1,R0    ;       RUNTIME.ADD(SLICE -
        SUB    R1,R0               ;                          NEWSLICE);
        MOV    R0,INCR5            ;
    $$  =      HEAD11 + RUNTI1     ;
        MOV    #$$,TIME5T          ;
        JSR    PC,ADD5             ;
        MOV    NEWS11,HEAD11+SLICE1;       SLICE := NEWSLICE;
        INC    HEAD11+OVERT1       ;       OVERTIME := TRUE;
        TST    HEAD11+NESTI1       ;       IF NESTING = 0 THEN
        BNE    1$                  ;
        MOV    #2.,HEAD11+PRIOR1   ;       PRIORITY := 2;
                                   ;     END;
                                   ;   END;
1$:     RTS    PC                  ; END;
                                   ;
                                   ;
        .MACRO ENTE11              ; PROCEDURE ENTER;
                                   ;
                                   ; BEGIN
                                   ;   WITH HEAD DO
                                   ;   BEGIN
        INC    HEAD11+NESTI1       ;     NESTING :+ 1;
        CLR    HEAD11+PRIOR1       ;     PRIORITY := 0;
                                   ;   END;
        .ENDM  ENTE11              ; END;
                                   ;
                                   ;
                                   ; PROCEDURE LEAVE;
                                   ;
        .MACRO LEAV11 ?L           ; BEGIN
                                   ; WITH HEAD DO
                                   ;   BEGIN
        DEC    HEAD11+NESTI1       ;     NESTING :- 1;
        BNE    L                   ;     IF NESTING = 0 THEN
                                   ;     BEGIN
        MOV    #2.,HEAD11+PRIOR1   ;       PRIORITY := 2;
        JSR    PC,RESC12           ;       READY.RESCHEDULE;
                                   ;     END;
L:                                 ;   END;
        .ENDM  LEAV11              ; END;
                                   ;
                                   ;
                                   ; PROCEDURE STARTIO;
                                   ;
        .MACRO STIO11 ?L           ; BEGIN
                                   ;   WITH HEAD DO
        TST    HEAD11+NESTI1       ;   IF NESTING = 0 THEN
        BNE    L                   ;
        MOV    #1.,HEAD11+PRIOR1   ;   PRIORITY := 1;
L:                                 ;
        .ENDM  STIO11              ; END;
                                   ;
                                   ;
                                   ; PROCEDURE POPPARAM(PARAMLENGTH:
PLEN11: .BLKB  .INTEGER            ;                           INTEGER);
;I      IS     R0, R1              ; VAR I: INTEGER;
                                   ;
POPP11: MOV    PLEN11,R0           ; BEGIN
        BEQ    1$                  ;
        ASR    R0                  ;
        CMP    R0,#MAX11           ;   IF PARAMLENGTH > MAX THEN
        BLE    2$                  ;
        MOV    #PLIM11,RESU19      ;     KERNELERROR(PARAMLIMIT);
        JSR    PC,KERN19           ;
2$:     MOV    #PARA11,R1          ;   FOR I := 1 TO PARAMLENGTH DO
        MFPI   SP                  ;
        MOV    (SP)+,R2            ;
3$:     MFPD   (R2)+               ;   POP(PARAM(.I.), REG.S);
        MOV    (SP)+,(R1)+         ;
        SOB    R0,3$               ;
        MOV    R2,-(SP)            ;
        MTPI   SP                  ;
1$:     RTS    PC                  ; END;
                                   ;
                                   ;
PARL11: .BLKB  .INTEGER            ; PROCEDURE INITCHILD(PARAMLENGTH,
VARL11: .BLKB  .INTEGER            ;                     VARLENGTH,
STAC11: .BLKB  .INTEGER            ;                     STACKLENGTH,
QVAL11: .BLKB  .INTEGER            ;                     QVALUE:
                                   ;                           INTEGER);
LENG11: .BLKB  .INTEGER            ; VAR LENGTH: INTEGER;
;I      IS     R1                  ;     I: INTEGER;
                                   ;
INCH11:                            ; BEGIN
        MOV    #.PROCESS,LENG16    ;   USER := NEW(PROCESS);
        JSR    PC,NEW16            ;
        MOV    NEW16R,USER11       ;
        MOV    NEXT11,R0           ;   PROCESSID(.NEXTINDEX.) := USER;
        ADD    R0,R0               ;
     $$ =      PRID11 - 2          ;
        MOV    USER11,$$(R0)       ;
        MOV    PARL11,R0           ;   LENGTH := PARAMLENGTH +
        CLR    R1                  ;
        ADD    VARL11,R0           ;             VARLENGTH +
        ADC    R1                  ;
        ADD    STAC11,R0           ;             STACKLENGTH +
        ADC    R1                  ;
        ADD    #2,R0               ;             2;
        ADC    R1                  ;
        BEQ    3$                  ;   IF LENGTH > 65535 THEN
        MOV    #VIRT10,RESU19      ;     KERNELERROR(VIRTUALLIMIT);
        JSR    PC,KERN19           ;
3$:     MOV    R0,LENG11           ;
        MOV    R0,PLEN10           ;   VIRTUAL.DEFPRIVATE(LENGTH);
        JSR    PC,DEFP10           ;
                                   ;   WITH HEAD DO
        MOV    #<HEAD11+INDEX1>,R0 ;   BEGIN
        MOV    NEXT11,(R0)+        ;     INDEX := NEXTINDEX;
        INC    NEXT11              ;     NEXTINDEX :+ 1;
        MOV    HEAP10,(R0)+        ;     HEAPTOP := VIRTUAL.HEAPTOP;
     $$ =      HEAD11+RUNTI1       ;     RUNTIME.INITIALIZE;
        MOV    #$$,TIME5T          ;
        JSR    PC,INIT5            ;
        MOV    #<HEAD11+SLICE1>,R0 ;     SLICE := 0;
        CLR    (R0)+               ;
        CLR    (R0)+               ;     NESTING := 0;
        MOV    #2.,(R0)+           ;     PRIORITY := 2;
        CLR    (R0)+               ;     OVERTIME := FALSE;
        CLR    (R0)+               ;     JOB := FALSE "0";
        MOV    #10.,(R0)           ;     CONTINUE := TRUE "10";
                                   ;   END;
                                   ;   WITH REG DO
	PUSH   <R0,R1,R2>	   ;<01> SAVE REGISTERS
        BIS    #<PSPMDU>,PSW	   ;<01> BEGIN
        MOV    LENG11,R0           ;     S := HEAD.HEAPTOP + LENGTH;
        ADD    HEAD11+HEAPT1,R0    ;
        MOV    PARL11,R1           ;     FOR I := PARAMLENGTH DOWNTO 1
        BEQ    1$                  ;     DO
        MOV    R1,R2               ;
        ADD    #PARA11,R1          ;
        ASR    R2                  ;
2$:     MOV    -(R1),-(SP)         ;     PUSH(PARAM(.I.), S);
        MTPI   -(R0)               ;
        SOB    R2,2$               ;
1$:     SUB    #2,R0               ;     S :- 2;
        MOV    R0,KSR5             ;<01> G := S;
        SUB    VARL11,R0           ;     S :- (VARLENGTH + 2);
        SUB    #2,R0               ;
        MOV    R0,KSR4             ;<01> B := S;
        MOV    QVAL11,KSR3         ;<01> Q := QVALUE;
        MOV    R0,-(SP)            ;
        MTPI   S                   ;
	MOV    R0,KSR0		   ;<01> PASS REGS BACK
	MOV    R1,KSR1		   ;<01>
	MOV    R2,KSR2		   ;<01>
	POP    <R2,R1,R0>	   ;<01> RESTORE REGISTERS

	.IF    DF,F$PU		   ;<01> FPU VERSION ONLY
        LDFPS  #FLOA11             ;     FSTATUS := FLOATSTATUS;
	.ENDC			   ;<01> F$PU

        MOV    #PGST11,KSOPSW      ;     PSTATUS := PROGSTATUS;
        MOV    #STAR11,KSOPC       ;     P := STARTADDR;
                                   ;   END;
        JSR    PC,PUTM10           ;   VIRTUAL.PUTMAP;
        JSR    PC,RESC12           ;   READY.RESCHEDULE;
        RTS    PC                  ; END;
                                   ;
                                   ;
                                   ; PROCEDURE INITPARENT(
INTL11: .BLKB  .INTEGER            ;        INTERPRETERLENGTH: INTEGER);
                                   ;
;PROGADDR IS   R0                  ; VAR PROGADDR,
PRGL11: .BLKB  .INTEGER            ;     PROGLENGTH,
CODL11: .BLKB  .INTEGER            ;     CODELENGTH,
STKL11: .BLKB  .INTEGER            ;     STACKLENGTH,
VRLE11: .BLKB  .INTEGER            ;     VARLENGTH,
LNTH11: .BLKB  .INTEGER            ;     LENGTH: INTEGER;
                                   ;
INPA11:                            ; BEGIN
        CLR    HEAD11+LINE1        ;   HEAD.LINE := 0;
        MOV    #USER99,R0          ;   PROGADDR := HEADADDR +
        ADD    INTL11,R0           ;               INTERPRETERLENGTH;
        MOV    #PRGL11,R1          ;   GETDATA(PROGADDR,
        MOV    (R0)+,(R1)+         ;           PROGLENGTH,
        MOV    (R0)+,(R1)+         ;           CODELENGTH,
        MOV    (R0)+,(R1)+         ;           STACKLENGTH,
        MOV    (R0)+,(R1)+         ;           VARLENGTH);
        MOV    #.PROCESS,LENG16    ;   USER := NEW(PROCESS);
        JSR    PC,NEW16            ;
        MOV    NEW16R,USER11       ;
        MOV    NEXT11,R0           ;   PROCESSID(.NEXTINDEX.) := USER;
        ADD    R0,R0               ;
     $$ =      PRID11 - 2          ;
        MOV    USER11,$$(R0)       ;
        MOV    #<HEAD11+INDEX1>,R0 ;   WITH HEAD DO
                                   ;   BEGIN
        MOV    NEXT11,(R0)+        ;     INDEX := NEXTINDEX;
        INC    NEXT11              ;     NEXTINDEX :+ 1;
        MOV    INTL11,R1           ;     HEAPTOP := INTERPRETERLENGTH +
        CLR    R2                  ;
        ADD    PRGL11,R1           ;                PROGLENGTH;
        ADC    R2                  ;
        MOV    R1,(R0)             ;
        ADD    STKL11,R1           ;     LENGTH := HEAPTOP + STACKLENGTH
        ADC    R2                  ;
        ADD    VRLE11,R1           ;                       + VARLENGTH
        ADC    R2                  ;
        ADD    #2,R1               ;                       + 2;
        ADC    R2                  ;
        BEQ    1$                  ;     IF LENGTH > 65535 THEN
        MOV    #VIRT10,RESU19      ;       KERNELERROR(VIRTUALLIMIT);
        JSR    PC,KERN19           ;
1$:     MOV    R1,LNTH11           ;
        MOV    R1,CLEN10           ;     VIRTUAL.DEFCOMMON(LENGTH);
        JSR    PC,DEFC10           ;
     $$ =      HEAD11+RUNTI1       ;     RUNTIME.INITIALIZE;
        MOV    #$$,TIME5T          ;
        JSR    PC,INIT5            ;
        MOV    #<HEAD11+SLICE1>,R0 ;     SLICE := 0;
        CLR    (R0)+               ;
        CLR    (R0)+               ;     NESTING := 0;
        MOV    #2.,(R0)+           ;     PRIORITY := 2;
        CLR    (R0)+               ;     OVERTIME := FALSE;
        CLR    (R0)+               ;     JOB := FALSE "0";
        MOV    #10.,(R0)           ;     CONTINUE := TRUE "10";
                                   ;   END;
                                   ;   WITH REG DO
        BIS    #<PSPMDU>,PSW	   ;<01> BEGIN
	PUSH   R0		   ;<01> SAVE R0
        MOV    LNTH11,R0           ;     S := LENGTH - 2;
        SUB    #2.,R0              ;
        MOV    R0,KSR5             ;<01> G := S;
        SUB    VRLE11,R0           ;     S :- (VARLENGTH + 2);
        SUB    #2.,R0              ;
        MOV    R0,-(SP)            ;
        MTPI   S                   ;
        MOV    R0,KSR4             ;<01> B := S;
        MOV    INTL11,R0           ;     Q := INTERPRETERLENGTH + 8;
        ADD    #8.,R0              ;
        MOV    R0,KSR3             ;<01>

	.IF    DF,F$PU		   ;<01> ONLY IF FPU IS PRESENT
        LDFPS  #FLOA11             ;     FSTATUS := FLOATSTATUS;
	.ENDC			   ;<01>

        MOV    #PGST11,KSOPSW      ;     PSTATUS := PROGSTATUS;
        MOV    #STAR11,KSOPC       ;     P := STARTADDR;
        ADD    CODL11,R0           ;     CONSTADDR := Q + CODELENGTH;
        MOV    R0,CONS11           ;
                                   ;   END;
	MOV    R0,KSR0		   ;<01> PASS R0
	POP    R0		   ;<01> RESTORE R0
        RTS    PC                  ; END;
                                   ;
                                   ;
                                   ; PROCEDURE ENTRY SYSTEMERROR;
                                   ;
TERM11:                            ; CONST TERMINATED =
        .ASCIZ /TERMINATED/        ;                  'TERMINATED(:0:)';
OVER11:                            ;       OVERFLOWERROR =
        .ASCIZ /OVERFLOW ERROR/    ;              'OVERFLOW ERROR(:0:)';
POIN11:                            ;       POINTERERROR =
        .ASCIZ /POINTER ERROR/     ;               'POINTER ERROR(:0:)';
RANG11:                            ;       RANGEERROR =
        .ASCIZ /RANGE ERROR/       ;                 'RANGE ERROR(:0:)';
VARI11:                            ;       VARIANTERROR =
        .ASCIZ /VARIANT ERROR/     ;               'VARIANT ERROR(:0:)';
HEAP11:                            ;       HEAPLIMIT =
        .ASCIZ /HEAP LIMIT/        ;                  'HEAP LIMIT(:0:)';
STAK11:                            ;       STACKLIMIT =
        .ASCIZ /STACK LIMIT/       ;                 'STACK LIMIT(:0:)';
        .EVEN                      ;
;TEXT   IS     RESU19              ; VAR TEXT: LINE;
                                   ;
SYST11:                            ; BEGIN
        MOV    HEAD11+RESUL1,R0    ;   CASE HEAD.RESULT OF
        ASL    R0                  ;
        MOV    1$(R0),RESU19       ;
        BR     2$                  ;
1$:     .WORD  TERM11              ;     0: TEXT := TERMINATED;
        .WORD  OVER11              ;     1: TEXT := OVERFLOWERROR;
        .WORD  POIN11              ;     2: TEXT := POINTERERROR;
        .WORD  RANG11              ;     3: TEXT := RANGEERROR;
        .WORD  VARI11              ;     4: TEXT := VARIANTERROR;
        .WORD  HEAP11              ;     5: TEXT := HEAPLIMIT;
        .WORD  STAK11              ;     6: TEXT := STACKLIMIT;
                                   ;   END;
2$:     JSR    PC,KERN19           ;   KERNELERROR(TEXT);
;       RTS    PC                  ; END;
                                   ;
                                   ;
                                   ; PROCEDURE ENTRY REALINTERRUPT;
                                   ;
RIAD11  =      REALOV - USER99     ; CONST REALINTERRUPTADDR = ...;
                                   ;
REAL11:                            ; BEGIN
        MOV    #RIAD11,KSOPC       ;   REG.P := REALINTERRUPTADDR;
        RTS    PC                  ; END;
                                   ;
                                   ;
INIT11:                            ; BEGIN
; DONE AT LABEL "NEXT11".          ;   NEXTINDEX := 1;
        RTS    PC                  ; END "OF RUNNING";
                                   ;
                                   ;
        .PAGE
        .SBTTL PROCESS INITIATION/TERMINATION
                                   ;"###################################
                                   ;         #  INIT/END/STOP PROCESS  #
                                   ;###################################"
                                   ;
                                   ;
                                   ; PROCEDURE ENTRY INITPROCESS(
                                   ;                   PARAMLENGTH,
                                   ;                   VARLENGTH,
                                   ;                   STACKLENGTH,
                                   ;                   QVALUE: INTEGER);
                                   ;
INIT13: MOV    #<HEAD11+PARAM1>,R0 ; BEGIN
        MOV    (R0),PLEN11         ;
        MOV    (R0)+,PARL11        ;
        MOV    (R0)+,VARL11        ;
        MOV    (R0)+,STAC11        ;
        MOV    (R0),QVAL11         ;
        JSR    PC,POPP11           ;   RUNNING.POPPARAM(PARAMLENGTH);
        JSR    PC,PREE11           ;   READY.ENTER(RUNNING.PREEMPTED);
        MOV    PRE11R,P12          ;
        JSR    PC,ENTE12           ;
        JSR    PC,INCH11           ;   RUNNING.INITCHILD(PARAMLENGTH,
                                   ;                     VARLENGTH,
                                   ;                     STACKLENGTH,
                                   ;                     QVALUE);
        RTS    PC                  ; END;
                                   ;
                                   ;
                                   ; PROCEDURE ENTRY ENDPROCESS;
                                   ;
;PROC   IS     PRE11R              ; VAR PROC: PROCESSREF;
                                   ;
ENDP14:                            ; BEGIN
        JSR    PC,PREE11           ;   PROC := RUNNING.PREEMPTED;
        RTS    PC                  ; END;
                                   ;
                                   ;
                                   ; PROCEDURE ENTRY STOPJOB(
                                   ;                      P,
                                   ;                      WHY: INTEGER);
                                   ;
;PROC   IS     R1                  ; VAR PROC: PROCESSREF;
;HEAD   IS     R1                  ;     HEAD: @HEADTYPE;
                                   ;
STOP15:                            ; BEGIN
        MOV    #<HEAD11+PARAM1>,R0 ;   PROC := RUNNING.PROCESSID(.P.);
        MOV    (R0)+,R1            ;
        ADD    R1,R1               ;
        MOV    <PRID11-2>(R1),R1   ;
        CMP    R1,USER11           ;   IF PROC = RUNNING.USER
        BNE    1$                  ;
        MOV    #HEAD11,R1          ;     THEN HEAD := @RUNNING.HEAD
        BR     2$                  ;
1$:     ADD    #HEAD0,R1           ;     ELSE HEAD := @PROC@.HEAD;
2$:                                ;   WITH HEAD@ DO
                                   ;   BEGIN
        MOV    (R0),RESUL1(R1)     ;     RESULT := WHY;
        CLR    CONTI1(R1)          ;     CONTINUE := FALSE "0";
                                   ;   END;
        RTS    PC                  ; END;
                                   ;
                                   ;
        .PAGE
        .SBTTL THE READY PROCESS QUEUES
                                   ;"###################################
                                   ;                         #  READY  #
                                   ;###################################"
                                   ;
                                   ;
                                   ; VAR READY:
                                   ; CLASS
                                   ;
TOP12:  .BLKB  .PROCQUE            ; VAR TOP,
MIDD12: .BLKB  .PROCQUE            ;     MIDDLE,
BOTT12: .BLKB  .PROCQUE            ;     BOTTOM: PROCESSQUEUE;
IDLI12: .WORD  0                   ;     IDLING: BOOLEAN;
                                   ;
                                   ;
P12:    .BLKB  .PROCREF            ; PROCEDURE ENTER(P: PROCESSREF);
                                   ;
ENTE12: MOV    P12,R0              ; BEGIN
        MOV    R0,NEWEL4           ;
        MOV    HEAD0+PRIOR1(R0),R1 ;   CASE P@.HEAD.PRIORITY OF
        BNE    1$                  ;
        MOV    #TOP12,QUTP4T       ;     0: TOP.PUT(P);
        JSR    PC,PUT4             ;
        RTS    PC                  ;
2$:     MOV    #BOTT12,QUTP4T      ;     2: BOTTOM.PUT(P);
        JSR    PC,PUT4             ;
        RTS    PC                  ;
1$:     SOB    R1,2$               ;
        MOV    #MIDD12,QUTP4T      ;     1: MIDDLE.PUT(P);
        JSR    PC,PUT4             ;
        RTS    PC                  ;   END;
                                   ; END;
                                   ;
                                   ;
                                   ; PROCEDURE SELECT;
                                   ;
;Q      IS     R0                  ; VAR Q: @PROCESSQUEUE;
                                   ;
SELE12:                            ; BEGIN
        TST    IDLI12              ;   IF NOT IDLING THEN
        BNE    1$                  ;   BEGIN
2$:                                ;     REPEAT
        MOV    #TOP12,R0           ;       Q := @TOP;
        EMPTY4 R0,3$               ;       IF Q@.EMPTY THEN
                                   ;       BEGIN
        MOV    #MIDD12,R0          ;         Q := @MIDDLE;
        EMPTY4 R0,3$               ;         IF Q@.EMPTY THEN
                                   ;         BEGIN
        MOV    #BOTT12,R0          ;           Q := @BOTTOM;
        EMPTY4 R0,3$               ;           IF Q@.EMPTY THEN
                                   ;           BEGIN
        INC    IDLI12              ;             IDLING := TRUE;
        SPL    0                   ;             IDLE;
        WAIT                       ;
        SPL    7                   ;
        CLR    IDLI12              ;             IDLING := FALSE;
                                   ;             Q := NIL;
                                   ;           END;
                                   ;         END;
                                   ;       END;
        TST    USER11              ;     UNTIL (RUNNING.USER <> NIL) OR
        BEQ    2$                  ;                         (Q <> NIL);
        RTS    PC                  ;     IF (RUNNING.USER = NIL) THEN
3$:     MOV    R0,QUTP4T           ;     RUNNING.SERVE(Q@.GET);
        JSR    PC,GET4             ;
        MOV    GET4R,P11           ;
        JSR    PC,SERV11           ;
1$:     RTS    PC                  ;   END;
                                   ; END;
                                   ;
                                   ;
                                   ; PROCEDURE RESCHEDULE;
                                   ;
RESC12:                            ; BEGIN
                                   ;   WITH RUNNING, HEAD DO
        TST    USER11              ;   IF USER <> NIL THEN
        BEQ    1$                  ;   BEGIN
        JSR    PC,UPDA11           ;     UPDATE;
        TST    HEAD11+PRIOR1       ;     IF PRIORITY > 0 THEN
        BEQ    1$                  ;     IF
        MOV    #TOP12,R0           ;       TOP.ANY OR
        EMPTY4 R0,2$               ;
        TST    HEAD11+OVERT1       ;       OVERTIME OR
        BNE    2$                  ;
        CMP    #2.,HEAD11+PRIOR1   ;       (PRIORITY = 2 AND
        BNE    1$                  ;
        MOV    #MIDD12,R0          ;        MIDDLE.ANY) THEN
        ANY4   R0,1$               ;
2$:     JSR    PC,PREE11           ;     ENTER(PREEMPTED);
        MOV    PRE11R,P12          ;
        JSR    PC,ENTE12           ;
1$:     RTS    PC                  ;   END;
                                   ; END;
                                   ;
                                   ;
                                   ; PROCEDURE ENDIO;
                                   ;
ENDI12:                            ; BEGIN
        JSR    PC,RESC12           ;   RESCHEDULE;
                                   ;   WITH RUNNING DO
        TST    USER11              ;   IF USER <> NIL THEN
        BEQ    1$                  ;
        MOV    USER11,P10          ;   VIRTUAL.GETMAP(USER);
        JSR    PC,GETM10           ;
1$:     RTS    PC                  ; END;
                                   ;
                                   ;
INIT12:                            ; BEGIN
        MOV    #TOP12,QUTP4T       ;   TOP.INITIALIZE;
        JSR    PC,INIT4            ;
        MOV    #MIDD12,QUTP4T      ;   MIDDLE.INITIALIZE;
        JSR    PC,INIT4            ;
        MOV    #BOTT12,QUTP4T      ;   BOTTOM.INITIALIZE;
        JSR    PC,INIT4            ;
; DONE AT LABEL "IDLI12".          ;   IDLING := FALSE;
        RTS    PC                  ; END "OF READY";
                                   ;
                                   ;
        .PAGE
        .SBTTL MONITOR GATES
                                   ;"###################################
                                   ;                          #  GATE  #
                                   ;###################################"
                                   ;
                                   ;
GATE    =      0                   ; TYPE GATE =
      $ =      GATE                ; CLASS
                                   ;
OPEN15  =      $                   ; VAR OPEN:
      $ =      $ + .BOOLEAN        ;           BOOLEAN;
WAIT15  =      $                   ;     WAITING:
      $ =      $ + .PROCQUE        ;              PROCESSQUEUE;
        CHKDTL GATE                ;
                                   ;
                                   ;
                                   ; PROCEDURE ENTRY ENTER;
                                   ;
ENTE17:                            ; BEGIN
        ENTE11                     ;   RUNNING.ENTER;
        MOV    <HEAD11+PARAM1>,R0  ;   IF OPEN THEN
        DEC    (R0)                ;
        BEQ    1$                  ;     OPEN := FALSE ELSE
        CLR    (R0)+               ;
        MOV    R0,QUTP4T           ;     WAITING.PUT(RUNNING.PREEMPTED);
        JSR    PC,PREE11           ;
        MOV    PRE11R,NEWEL4       ;
        JSR    PC,PUT4             ;
1$:     RTS    PC                  ; END;
                                   ;
                                   ;
                                   ; PROCEDURE ENTRY LEAVE;
                                   ;
;P      IS     GET4R, P12          ; VAR P: PROCESSREF;
                                   ;
LEAV17: MOV    <HEAD11+PARAM1>,R0  ; BEGIN
        INC    (R0)+               ;
        ANY4   R0,1$               ;   IF NOT WAITING.ANY THEN
                                   ;     OPEN := TRUE ELSE
        MOV    R0,QUTP4T           ;     BEGIN
        CLR    -(R0)               ;
        JSR    PC,GET4             ;       P := WAITING.GET;
        MOV    GET4R,P12           ;       READY.ENTER(P);
        JSR    PC,ENTE12           ;
                                   ;     END;
1$:     LEAV11                     ;   RUNNING.LEAVE;
        RTS    PC                  ; END;
                                   ;
                                   ;
                                   ; PROCEDURE ENTRY DELAY(VAR Q:
                                   ;                        PROCESSREF);
;P      IS     GET4R, P12          ; VAR P: PROCESSREF;
                                   ;
DELA17:                            ; BEGIN
        JSR    PC,PREE11           ;   Q := RUNNING.PREEMPTED;
        MOV    PRE11R,-(SP)        ;
     $$ =      HEAD11 + PARAM1     ;
     $$ =      $$ + .INTEGER       ;
        MTPD   @$$                 ;
        MOV    <HEAD11+PARAM1>,R0  ;   IF WAITING.ANY THEN
        INC    (R0)+               ;   BEGIN
        ANY4   R0,1$               ;
        MOV    R0,QUTP4T           ;     P := WAITING.GET;
        CLR    -(R0)               ;
        JSR    PC,GET4             ;
        MOV    GET4R,P12           ;     READY.ENTER(P);
        JSR    PC,ENTE12           ;   END ELSE
1$:                                ;   OPEN := TRUE;
        RTS    PC                  ; END;
                                   ;
                                   ;
                                   ; PROCEDURE ENTRY CONTINUE(VAR Q:
                                   ;                        PROCESSREF);
;P      IS     R1, P12             ; VAR P: PROCESSREF;
                                   ;
CONT17:                            ; BEGIN
     $$ =      HEAD11 + PARAM1     ;   P := Q;
        MOV    <$$ + .INTEGER>,R0  ;
        MFPD   (R0)                ;
        MOV    (SP)+,R1            ;   IF P = NIL THEN
        BEQ    LEAV17              ;   LEAVE ELSE
        CLR    -(SP)               ;   BEGIN
        MTPD   (R0)                ;     Q := NIL;
        MOV    R1,P12              ;     READY.ENTER(P);
        JSR    PC,ENTE12           ;
        LEAV11                     ;     RUNNING.LEAVE;
                                   ;   END;
        RTS    PC                  ; END;
                                   ;
                                   ;
GAT17T: .BLKB  .INTEGER            ; BEGIN
INIT17: ENTE11                     ;   RUNNING.ENTER;
        MOV    GAT17T,R0           ;
        CLR    (R0)+               ;   OPEN := FALSE;
        MOV    R0,QUTP4T           ;   WAITING.INITIALIZE;
        JSR    PC,INIT4            ;
        RTS    PC                  ; END "OF GATE";
                                   ;
                                   ;
                                   ; PROCEDURE ENTRY INITGATE(VAR G: @
                                   ;                              GATE);
INIT18:                            ; BEGIN
        MOV    #.GATE,LENG16       ;   G := NEW(GATE);
        JSR    PC,NEW16            ;
        MOV    NEW16R,-(SP)        ;
        MTPD   @<HEAD11+PARAM1>    ;
        MOV    NEW16R,GAT17T       ;   G@.INITIALIZE;
        JSR    PC,INIT17           ;
        RTS    PC                  ; END;
                                   ;
                                   ;
                                   ;"KERNELTEXT3"
        .PAGE
        .SBTTL DATA TYPES FOR THE I/O CONTROLLERS
                                   ;"###################################
                                   ;                #  I/O DATA TYPES  #
                                   ;###################################"
                                   ;
                                   ;
                                   ; TYPE BUFFERTYPE = ANYTYPE;
                                   ;
      $ =      0                   ; TYPE IODEVICE = (
TTY020  =      $                   ;                  TTY0,
      $ =      $ + 1               ;
DSK020  =      $                   ;                  DISK0,
      $ =      $ + 1               ;
TP9020  =      $                   ;                  TAPE90,
      $ =      $ + 1               ;
PRT020  =      $                   ;                  PRINTER0,
      $ =      $ + 1               ;
CRD020  =      $                   ;                  CARDREADER0,
      $ =      $ + 1               ;
TP9120  =      $                   ;                  TAPE91
.IODEVIC=      .INTEGER            ;                 );
                                   ;
      $ =      0                   ; TYPE IOOPERATION = (
INPU21  =      $                   ;                     INPUT,
      $ =      $ + 1               ;
OUTP21  =      $                   ;                     OUTPUT,
      $ =      $ + 1               ;
MOVE21  =      $                   ;                     MOVE,
      $ =      $ + 1               ;
CONT21  =      $                   ;                     CONTROL
.IOOPERA=      .INTEGER            ;                    );
                                   ;
      $ =      0                   ; TYPE IORESULT = (
COMP22  =      $                   ;                  COMPLETE,
      $ =      $ + 1               ;
INTE22  =      $                   ;                  INTERVENTION,
      $ =      $ + 1               ;
TRAN22  =      $                   ;                  TRANSMISSION,
      $ =      $ + 1               ;
FAIL22  =      $                   ;                  FAILURE,
      $ =      $ + 1               ;
ENDF22  =      $                   ;                  ENDFILE,
      $ =      $ + 1               ;
ENDM22  =      $                   ;                  ENDMEDIUM,
      $ =      $ + 1               ;
STAR22  =      $                   ;                  STARTMEDIUM
.IORESUL=      .INTEGER            ;                 );
                                   ;
      $ =      0                   ; TYPE IOMOVE = (
OUTE23  =      $                   ;                OUTEOF,
      $ =      $ + 1               ;
REWI23  =      $                   ;                REWIND,
      $ =      $ + 1               ;
UPSP23  =      $                   ;                UPSPACE,
      $ =      $ + 1               ;
BACK23  =      $                   ;                BACKSPACE,
      $ =      $ + 1               ;
UNLO23  =      $                   ;                UNLOAD
.IOMOVE =      .INTEGER            ;               );
                                   ;
IOPARAM =      0                   ; TYPE IOPARAM =
      $ =      IOPARAM             ;   RECORD
OPER24  =      $                   ;     OPERATION:
      $ =      $ + .IOOPERATION    ;                IOOPERATION;
STAT24  =      $                   ;     STATUS:
      $ =      $ + .IORESULT       ;             IORESULT;
MODI24  =      $                   ;     MODIFIER:
      $ =      $ + .INTEGER        ;               UNIV INTEGER;
.IOPARAM=      $ - IOPARAM         ;   END;
                                   ;
                                   ; TYPE UNITTYPE = 0..7;
                                   ;
                                   ;
        .PAGE
        .SBTTL PROCEDURES FOR ABSENT I/O DEVICES
                                   ;"###################################
                                   ;               #  MISSING DEVICES  #
                                   ;###################################"
                                   ;
                                   ;
PARA38: .BLKB  .ADDRESS            ; PROCEDURE IOFAIL(VAR PARAM:
                                   ;                          @IOPARAM);
                                   ;
IOFA38:                            ; BEGIN
        MOV    #FAIL22,-(SP)       ;   PARAM@.STATUS := FAILURE;
        MOV    PARA38,R0           ;
        MTPD   STAT24(R0)          ;
        RTS    PC                  ; END;
                                   ;
                                   ;
DEVR39: .BLKB  .ADDRESS            ; FUNCTION DEVICEPRESENT(DEVREG:
DEV39R: .BLKB  .BOOLEAN            ;                 @INTEGER): BOOLEAN;
                                   ;
NONE39:                            ; ON NONEXISTENTMEMORYTRAP DO
        CLR    DEV39R              ;   DEVICEPRESENT := FALSE;
        RTI                        ;
                                   ;
DEVI39: MOV    #NONE39,FETRAP      ; BEGIN
        MOV    #1,DEV39R           ;   DEVICEPRESENT := TRUE;
        TST    @DEVR39             ;   IF DEVREG@ = 0 THEN ;
        MOV    #FEINT,FETRAP       ; END;
        RTS    PC                  ;
                                   ;
                                   ;
        .PAGE
        .SBTTL TAPE (TM11) I/O DRIVER
                                   ;"###################################
                                   ;                      #  TM11TAPE  #
                                   ;###################################"
                                   ;
                                   ;
                                   ; VAR TM11TAPE:  "9-TRACK TAPES ONLY"
                                   ; CLASS
                                   ;
IOCO25  =      -512.               ; CONST IOCOUNT = -512;
SPAC25  =      -1.                 ;       SPACECOUNT = -1;
                                   ;
                                   ; TYPE FUNCTYPE = (
OFFL25  =      MTFOFL              ;                  OFFLINE,
READ25  =      MTFRD               ;                  READ,
WRIT25  =      MTFWR               ;                  WRITE,
WEOF25  =      MTFWFM              ;                  WRITEEOF,
FORW25  =      MTFSPF              ;                  FORWARDSPACE,
BACK25  =      MTFSPR              ;                  BACKWARDSPACE,
WGAP25  =      MTFWGP              ;                  WRITEGAP,
REWI25  =      MTFREW              ;                  REWINDTAPE
.FUNCTYP=      .INTEGER            ;                 );
                                   ;
                                   ; TYPE TAPEDENSITY = (
ST2025  =      MDS200              ;                     ST200,
ST5525  =      MDS556              ;                     ST556,
ST8025  =      MDS800              ;                     ST800,
NT8025  =      MDN800              ;                     NT800
.TAPEDEN=      .INTEGER            ;                    );
                                   ;
                                   ; TYPE TAPECOMMAND =
.TAPECOM=      .INTEGER            ;   PACKED RECORD
ERRO25  =      MTCERR              ;     ERROR: BOOLEAN;
NTDE25  =      MTCDEN * NT8025     ;     DENSITY: TAPEDENSITY;
POWE25  =      MTCPCL              ;     POWERCLEAR: BOOLEAN;
EVEN25  =      MTCPEV              ;     EVENPARITY: BOOLEAN;
UNIT25  =      MTCUS               ;     UNIT: UNITTYPE;
REDY25  =      MTCCUR              ;     READY: BOOLEAN;
INEN25  =      MTCIEN              ;     INTERRUPT: BOOLEAN;
ADDB25  =      MTCADD              ;     ADDRBITS: 0..3;
FUNC25  =      MTCFUN              ;     FUNC: FUNCTYPE;
GO25    =      MTCGO               ;     GO: BOOLEAN;
                                   ;   END;
                                   ;
UNIS25:                            ; VAR UNITS: ARRAY (.UNITTYPE.) OF
    $TC =      NTDE25+INEN25+GO25  ;                        TAPECOMMAND;
    $UN =      0                   ;
        .REPT  8.                  ;
        .WORD  $TC + $UN           ;
    $UN =      $UN + UNIT25        ;
        .ENDR                      ;
FTBL25: .WORD  FUNC25 * READ25     ;     FUNCTABLE: ARRAY
        .WORD  FUNC25 * WRIT25     ;        (.IOOPERATION.) OF FUNCTYPE;
MTBL25: .WORD  FUNC25 * WEOF25     ;     MOVETABLE: ARRAY (.IOMOVE.) OF
        .WORD  FUNC25 * REWI25     ;                           FUNCTYPE;
        .WORD  FUNC25 * FORW25     ;
        .WORD  FUNC25 * BACK25     ;
        .WORD  FUNC25 * OFFL25     ;
USER25: .WORD  NIL                 ;     USER: PROCESSREF;
ADDR25: .BLKB  .ADDRESS            ;     ADDR: @IORESULT;
CONN25: .BLKB  .BOOLEAN            ; VAR ENTRY
                                   ;     CONNECTED: BOOLEAN;
                                   ; "HARDWARE"
STAT25  =      MTS                 ;     STATUSREG:
                                   ;       PACKED RECORD
ILLE25  =      MTSILC              ;         ILLEGALCOMMAND,
ENDO25  =      MTSEOF              ;         ENDOFFILE,
CYCL25  =      MTSCRE              ;         CYCLICREDUNDANCY,
PARI25  =      MTSPAE              ;         PARITYERROR,
BUSG25  =      MTSBGL              ;         BUSGRANTLATE,
ENDT25  =      MTSEOT              ;         ENDOFTAPE,
RECO25  =      MTSRLE              ;         RECORDLENGTH,
BADT25  =      MTSBTE              ;         BADTAPE,
NONE25  =      MTSNXM              ;         NONEXISTENTMEMORY,
SELE25  =      MTSELR              ;         SELECTREMOTE,
BEGI25  =      MTSBOT              ;         BEGINNINGOFTAPE,
SVNC25  =      MTS7CH              ;         SEVENCHANNEL,
SETT25  =      MTSDWN              ;         SETTLEDOWN,
FILE25  =      MTSWRL              ;         FILEPROTECT,
REWS25  =      MTSRWS              ;         REWINDING,
TAPE25  =      MTSTUR              ;         TAPEUNITREADY: BOOLEAN;
                                   ;       END;
COMR25  =      MTC                 ;     COMMANDREG: TAPECOMMAND;
COUN25  =      MTBRC               ;     COUNTREG: INTEGER;
ADRG25  =      MTCMA               ;     ADDRREG: ADDRESS;
                                   ;
                                   ;
BUF25:  .BLKB  .ADDRESS            ; PROCEDURE INITIO(VAR BUF:
                                   ;                        @BUFFERTYPE;
COM25:  .BLKB  .ADDRESS            ;                  VAR COM: @IOPARAM;
UNIN25: .BLKB  .INTEGER            ;                  UNITNUMBER:
                                   ;                          UNITTYPE);
                                   ;
;OPER   IS     R1                  ; VAR OPER: IOOPERATION;
SKEL25: .BLKB  .TAPECOMMAND        ;     SKELETON: TAPECOMMAND;
;       AND    R2                  ;
;MOVER  IS     R1                  ;     MOVER: IOMOVE;
PREF25: .BLKB  .INTEGER            ;     PREFIX: 0..3;
                                   ;
INIO25:                            ; BEGIN
        MOV    COM25,R0            ;   OPER := COM@.OPERATION;
        MFPD   (R0)+               ;
        MOV    (SP)+,R1            ;
        ASL    R1                  ;
        MOV    R0,ADDR25           ;   ADDR := @COM@.STATUS;
        MOV    UNIN25,R2           ;   SKELETON := UNITS(.UNITNUMBER.);
        MOV    UNIS25(R2),R2       ;
                                   ;   WITH SKELETON DO
                                   ;   BEGIN
        JMP    1$(R1)              ;     IF OPER <> CONTROL THEN
1$:     BR     2$                  ;       BEGIN
        BR     3$                  ;         CASE OPER OF
        BR     4$                  ;
        BR     5$                  ;
2$: 3$:                            ;           INPUT, OUTPUT:
                                   ;           BEGIN
        BIS    FTBL25(R1),R2       ;             FUNC :=
                                   ;                  FUNCTABLE(.OPER.);
        MOV    R2,SKEL25           ;             VIRTUAL.REALADDRESS(
        MOV    BUF25,VTLA10        ;                           BUF,
        MOV    #PREF25,PREF10      ;                           PREFIX,
        MOV    #ADRG25,REST10      ;                           ADDRREG);
        JSR    PC,REAL10           ;
        MOV    PREF25,R2           ;             ADDRBITS := PREFIX;
        ASH    #4.,R2              ;
        ADD    SKEL25,R2           ;
        MOV    #IOCO25,COUN25      ;             COUNTREG := IOCOUNT;
        BR     6$                  ;           END;
                                   ;
4$:                                ;           MOVE:
                                   ;           BEGIN
        MFPD   2(R0)               ;             MOVER := COM@.MODIFIER;
        MOV    (SP)+,R1            ;
        ASL    R1                  ;             FUNC :=
        BIS    MTBL25(R1),R2       ;                 MOVETABLE(.MOVER.);
        MOV    #SPAC25,COUN25      ;             COUNTREG := SPACECOUNT;
                                   ;           END;
                                   ;         END;
6$:     MOV    R2,COMR25           ;         COMMANDREG := SKELETON;
        JSR    PC,PREE11           ;         USER := RUNNING.PREEMPTED;
        MOV    PRE11R,USER25       ;
        RTS    PC                  ;       END ELSE
5$:                                ;       BEGIN "OPER = CONTROL"
        CLR    -(SP)               ;         COM@.STATUS := COMPLETE;
        MTPD   @ADDR25             ;
        RTS    PC                  ;       END;
                                   ;   END;
                                   ; END "OF INITIO";
                                   ;
                                   ;
                                   ; PROCEDURE INTERRUPT;
                                   ;
;RESULT IS     R0                  ; VAR RESULT: IORESULT;
                                   ;
INTE25:                            ; BEGIN
        MOV    USER25,R0           ;   IF USER <> NIL THEN
                                   ;   BEGIN
        BNE    1$                  ;
        RTS    PC                  ;
1$:                                ;     WITH COMMANDREG, STATUSREG DO
                                   ;     BEGIN
        MOV    R0,P12              ;       READY.ENTER(USER);
        JSR    PC,ENTE12           ;
        CLR    R0                  ;
        MOV    STAT25,R1           ;
        TST    COMR25              ;       IF NOT ERROR THEN
        BMI    2$                  ;
        BIT    #ENDO25,R1          ;         IF ENDOFFILE THEN
        BNE    3$                  ;           RESULT := ENDFILE ELSE
        BIT    #ENDT25,R1          ;           IF ENDOFTAPE THEN
        BNE    8$                  ;             RESULT := ENDMEDIUM
                                   ;                                ELSE
        BIT    #BEGI25,R1          ;             IF BEGINNINGOFTAPE THEN
        BNE    5$                  ;               RESULT := STARTMEDIUM
                                   ;                                ELSE
        BR     4$                  ;               RESULT := COMPLETE
2$:                                ;         ELSE "ERROR"
      $ =      RECO25              ;         IF RECORDLENGTH OR
      $ =      $ + NONE25          ;            NONEXISTENTMEMORY THEN
        BIT    #$,R1               ;
        BNE    6$                  ;           RESULT := FAILURE ELSE
        BIT    #ILLE25,R1          ;           IF ILLEGALCOMMAND THEN
        BNE    7$                  ;             RESULT := INTERVENTION
                                   ;                                ELSE
      $ =      CYCL25              ;             IF CYCLICREDUNDANCY OR
      $ =      $ + PARI25          ;                PARITYERROR OR
      $ =      $ + BADT25          ;                BADTAPE OR
      $ =      $ + BUSG25          ;                BUSGRANTLATE THEN
        BIT    #$,R1               ;
        BNE    9$                  ;               RESULT :=
                                   ;                   TRANSMISSION ELSE
        BIT    #ENDO25,R1          ;               IF ENDOFFILE THEN
        BNE    3$                  ;                 RESULT := ENDFILE
                                   ;                                ELSE
        BR     8$                  ;                 RESULT :=
                                   ;                          ENDMEDIUM;
5$:     INC    R0                  ;
8$:     INC    R0                  ;
3$:     INC    R0                  ;
6$:     INC    R0                  ;
9$:     INC    R0                  ;
7$:     INC    R0                  ;
4$:     MOV    R0,-(SP)            ;
        MOV    USER25,P10          ;       VIRTUAL.GETMAP(USER);
        JSR    PC,GETM10           ;
        BIS    #PSPMDU,PSW         ;
        MTPD   @ADDR25             ;       ADDR@ := RESULT;
        CLR    USER25              ;       USER := NIL;
        JSR    PC,ENDI12           ;       READY.ENDIO;
        RTS    PC                  ;     END;
                                   ;   END;
                                   ; END "OF INTERRUPT";
                                   ;
                                   ;
                                   ; PROCEDURE INITIALIZE;
                                   ;
                                   ; VAR I: UNITTYPE;
                                   ;
INIZ25:                            ; BEGIN
; ALL OF THE INITIALIZATIONS SHOWN ;   USER := NIL;
; HERE HAVE BEEN PERFORMED BY PRE- ;   FOR I := 0 TO 7 DO
; CEDING CONSTANT DECLARATIONS AT  ;     WITH UNITS(.I.) DO
; THE LABELS:                      ;     BEGIN
;                                  ;       ERROR := FALSE;
;       USER25,                    ;       DENSITY := NT800;
;       UNIS25,                    ;       POWERCLEAR := FALSE;
;       FTBL25, AND                ;       EVENPARITY := FALSE;
;       MTBL25.                    ;       UNIT := 2;
;                                  ;       READY := FALSE;
;                                  ;       INTERRUPT := TRUE;
;                                  ;       ADDRBITS := 0;
;                                  ;       FUNC := OFFLINE;
;                                  ;       GO := TRUE;
;                                  ;     END;
;                                  ;   FUNCTABLE(.INPUT.) := READ;
;                                  ;   FUNCTABLE(.OUTPUT.) := WRITE;
;                                  ;   MOVETABLE(.OUTEOF.) := WRITEEOF;
;                                  ;   MOVETABLE(.REWIND.) :=
;                                  ;                         REWINDTAPE;
;                                  ;   MOVETABLE(.UPSPACE.) :=
;                                  ;                       FORWARDSPACE;
;                                  ;   MOVETABLE(.BACKSPACE.) :=
;                                  ;                      BACKWARDSPACE;
;                                  ;   MOVETABLE(.UNLOAD.) := OFFLINE;
        RTS    PC                  ; END "OF INITIALIZE";
                                   ;
                                   ;
INIT25:                            ; BEGIN
        MOV    #STAT25,DEVR39      ;   CONNECTED := DEVICEPRESENT(
        JSR    PC,DEVI39           ;                         STATUSREG);
        MOV    DEV39R,CONN25       ;
        BEQ    1$                  ;   IF CONNECTED THEN
        JSR    PC,INIZ25           ;     INITIALIZE;
1$:     RTS    PC                  ; END "OF TM11TAPE";
                                   ;
                                   ;
        .PAGE
        .SBTTL DISK (RK11) I/O DRIVER
                                   ;"###################################
                                   ;                      #  RK11DISK  #
                                   ;###################################"
                                   ;
                                   ;
                                   ; VAR RK11DISK:
                                   ; CLASS
                                   ;
IOCO27  =      -256.               ; CONST IOCOUNT = -256;
                                   ;
                                   ; TYPE FUNCTYPE = (
CONT27  =      RCFCRE              ;                  CONTROLRESET,
WRIT27  =      RCFWR               ;                  WRITE,
READ27  =      RCFRD               ;                  READ,
WRCH27  =      RCFWRC              ;                  WRITECHECK,
SEEK27  =      RCFSK               ;                  SEEK,
RDCH27  =      RCFRDC              ;                  READCHECK,
DRVR27  =      RCFDRE              ;                  DRIVERESET,
WRLK27  =      RCFWRL              ;                  WRITELOCK
                                   ;                 );
                                   ;
      $ =      0                   ; TYPE DISKCONTROL = (
LOAD27  =      $                   ;                     LOAD
                                   ;                    );
                                   ;
                                   ; TYPE DISKCOMMAND =
                                   ;   PACKED RECORD
ERRO27  =      RCSERR              ;     ERROR,
HARD27  =      RCSHE               ;     HARDERROR,
SEAR27  =      RCSSCP              ;     SEARCHCOMPLETE,
INHI27  =      RCSIBA              ;     INHIBITINCREMENT,
FORM27  =      RCSFMT              ;     FORMAT,
STOP27  =      RCSSSE              ;     STOPONSOFTERROR,
CONR27  =      RCSRDY              ;     CONTROLREADY,
INEN27  =      RCSIDE              ;     INTERRUPT: BOOLEAN;
ADDB27  =      RCSMEX              ;     ADDRBITS: 0..3;
FUNC27  =      RCSFUN              ;     FUNC: FUNCTYPE;
GO27    =      RCSGO               ;     GO: BOOLEAN;
                                   ;   END;
                                   ;
                                   ; TYPE DISKADDRESS =
                                   ;   PACKED RECORD
DRIV27  =      RDADRS              ;     DRIVE: UNITTYPE;
CYLI27  =      RDACYL              ;     CYLINDER: 0..199;
SURF27  =      RDASUR              ;     SURFACE: 0..1;
SECT27  =      RDASC               ;     SECTOR: 0..11;
                                   ;   END;
                                   ;
FTBL27:                            ; VAR FUNCTABLE: ARRAY
      $ =      INEN27 + GO27       ;        (.IOOPERATION.) OF FUNCTYPE;
        .WORD  FUNC27 * READ27 + $ ;
        .WORD  FUNC27 * WRIT27 + $ ;
USER27: .WORD  NIL                 ;     USER: PROCESSREF;
ADDR27: .BLKB  .ADDRESS            ;     ADDR: @IORESULT;
CONN27: .BLKB  .BOOLEAN            ; VAR ENTRY
                                   ;     CONNECTED: BOOLEAN;
                                   ; "HARDWARE"
ERRR27  =      RKER                ;     ERRORREG:
                                   ;       PACKED RECORD
DRVE27  =      RERDRE              ;         DRIVEERROR,
OVER27  =      REROVR              ;         OVERRUN,
WRVI27  =      RERWLO              ;         WRITEVIOLATION,
SKER27  =      RERSKE              ;         SEEKERROR,
PROG27  =      RERPGE              ;         PROGRAMERROR,
NONE27  =      RERNXM              ;         NONEXISTENTMEMORY,
DATA27  =      RERDLT              ;         DATALATE,
TIMI27  =      RERTE               ;         TIMINGERROR,
NXDI27  =      RERNXD              ;         NONEXISTENTDISK,
NXCY27  =      RERNXC              ;         NONEXISTENTCYLINDER,
NXSE27  =      RERNXS              ;         NONEXISTENTSECTOR,
CHEC27  =      RERCSE              ;         CHECKSUMERROR,
WRCE27  =      RERWCE              ;         WRITECHECKERROR: BOOLEAN;
                                   ;       END;
COMM27  =      RKCS                ;     COMMANDREG: DISKCOMMAND;
COUN27  =      RKWC                ;     COUNTREG: INTEGER;
ADRG27  =      RKBA                ;     ADDRREG: ADDRESS;
SRRG27  =      RKDA                ;     SEARCHREG: DISKADDRESS;
                                   ;
                                   ;
BUF27:  .BLKB  .ADDRESS            ; PROCEDURE INITIO(VAR BUF:
                                   ;                        @BUFFERTYPE;
COM27:  .BLKB  .ADDRESS            ;                  VAR COM: @IOPARAM;
UNIN27: .BLKB  .INTEGER            ;                  UNITNUMBER:
                                   ;                          UNITTYPE);
                                   ;
;OPER   IS     R1                  ; VAR OPER: IOOPERATION;
IOAR27: .BLKB  .INTEGER            ;     IOARG: UNIV INTEGER;
;BLOCK  IS     R0, R1              ;     BLOCK: 0..4799;
;DISKADDR IS   R0                  ;     DISKADDR: DISKADDRESS;
DISK27: .BLKB  .INTEGER            ;     DISKFUNC: DISKCOMMAND;
PREF27: .BLKB  .INTEGER            ;     PREFIX: 0..3;
                                   ;
INIO27:                            ; BEGIN
        MOV    COM27,R0            ;   OPER := COM@.OPERATION;
        MFPD   (R0)+               ;
        MOV    (SP)+,R1            ;
        MOV    R0,ADDR27           ;   ADDR := @COM@.STATUS;
        ADD    #2,R0               ;   IOARG := COM@.MODIFIER;
        MFPD   (R0)                ;
        MOV    (SP)+,IOAR27        ;
                                   ;   WITH DISKADDR, DISKFUNC DO
        ASL    R1                  ;   CASE OPER OF
        JMP    1$(R1)              ;
1$:     BR     2$                  ;
        BR     3$                  ;
        BR     4$                  ;
        BR     5$                  ;
2$: 3$:                            ;     INPUT, OUTPUT:
                                   ;     BEGIN
        MOV    FTBL27(R1),DISK27   ;       DISKFUNC :=
                                   ;                  FUNCTABLE(.OPER.);
        MOV    BUF27,VTLA10        ;       VIRTUAL.REALADDRESS(BUF,
        MOV    #PREF27,PREF10      ;                           PREFIX,
        MOV    #ADRG27,REST10      ;                           ADDRREG);
        JSR    PC,REAL10           ;
        MOV    PREF27,R0           ;       ADDRBITS := PREFIX;
        ASH    #4.,R0              ;
        ADD    R0,DISK27           ;
        MOV    #IOCO27,COUN27      ;       COUNTREG := IOCOUNT;
        MOV    IOAR27,R1           ;       BLOCK := IOARG;
        CLR    R0                  ;       SECTOR := BLOCK MOD 12;
        DIV    #12.,R0             ;       BLOCK := BLOCK DIV 12;
                                   ;       SURFACE := BLOCK MOD 2;
        MOV    UNIN27,R2           ;       DRIVE := UNITNUMBER;
        SWAB   R2                  ;
        BIS    R2,R0               ;
        ASH    #4,R0               ;       CYLINDER := BLOCK DIV 2;
        BIS    R1,R0               ;
        MOV    R0,SRRG27           ;       SEARCHREG := DISKADDR
	BIS    UNITNO,SRRG27	   ;<01>			   + UNIT;
        MOV    DISK27,COMM27       ;       COMMANDREG := DISKFUNC;
        JSR    PC,PREE11           ;       USER := RUNNING.PREEMPTED;
        MOV    PRE11R,USER27       ;
        RTS    PC                  ;     END;
                                   ;
4$:                                ;     MOVE:
        CLR    -(SP)               ;     COM@.STATUS := COMPLETE;
        MTPD   @ADDR27             ;
        RTS    PC                  ;
                                   ;
5$:                                ;     CONTROL:
        MOV    IOAR27,$SDA0        ;     KERNEL.INITIALIZE(IOARG);
        JMP    $RVM0               ;
                                   ;   END;
                                   ; END "OF INITIO";
                                   ;
                                   ;
                                   ; PROCEDURE INTERRUPT;
                                   ;
;RESULT IS     R0                  ; VAR RESULT: IORESULT;
                                   ;
INTE27:                            ; BEGIN
        MOV    USER27,R0           ;   IF USER <> NIL THEN
        BNE    1$                  ;
        RTS    PC                  ;
                                   ;     WITH COMMANDREG, ERRORREG DO
1$:                                ;     BEGIN
        MOV    R0,P12              ;       READY.ENTER(USER);
        JSR    PC,ENTE12           ;
        CLR    R0                  ;
        BIT    #HARD27,COMM27      ;       IF NOT HARDERROR THEN
        BNE    2$                  ;
        TST    COMM27              ;         IF ERROR THEN
        BMI    3$                  ;           RESULT := TRANSMISSION
        BR     4$                  ;           ELSE RESULT := COMPLETE
2$:                                ;         ELSE "HARDERROR"
      $ =      OVER27              ;         IF OVERRUN OR
      $ =      $ + PROG27          ;            PROGRAMERROR OR
      $ =      $ + NONE27          ;            NONEXISTENTMEMORY OR
      $ =      $ + NXDI27          ;            NONEXISTENTDISK OR
      $ =      $ + NXCY27          ;            NONEXISTENTCYLINDER OR
      $ =      $ + NXSE27          ;            NONEXISTENTSECTOR THEN
        BIT    #$,ERRR27           ;
        BNE    5$                  ;           RESULT := FAILURE ELSE
      $ =      DRVE27              ;           IF DRIVEERROR OR
      $ =      $ + WRVI27          ;              WRITEVIOLATION THEN
        BIT    #$,ERRR27           ;             RESULT := INTERVENTION
        BNE    6$                  ;                                ELSE
                                   ;             IF SEEKERROR OR
                                   ;                TIMINGERROR OR
                                   ;                DATALATE THEN
        BR     3$                  ;               RESULT :=
                                   ;                       TRANSMISSION;
5$:     INC    R0                  ;       IF RESULT <> COMPLETE THEN
3$:     INC    R0                  ;         BEGIN
6$:     INC    R0                  ;           FUNC := CONTROLRESET;
      $ =      FUNC27*CONT27+GO27  ;           INTERRUPT := FALSE;
        MOV    #$,COMM27           ;           GO := TRUE;
7$:     TSTB   COMM27              ;           REPEAT UNTIL
        BGE    7$                  ;                       CONTROLREADY;
                                   ;         END;
4$:     MOV    R0,-(SP)            ;
        MOV    USER27,P10          ;       VIRTUAL.GETMAP(USER);
        JSR    PC,GETM10           ;
        BIS    #PSPMDU,PSW         ;
        MTPD   @ADDR27             ;       ADDR@ := RESULT;
        CLR    USER27              ;       USER := NIL;
        JSR    PC,ENDI12           ;       READY.ENDIO;
        RTS    PC                  ;     END;
                                   ; END "OF INTERRUPT";
                                   ;
                                   ;
                                   ; PROCEDURE INITIALIZE;
                                   ;
INIZ27:                            ; BEGIN
; ALL OF THE INITIALIZATIONS SHOWN ;   USER := NIL;
; HERE HAVE BEEN PERFORMED BY PRE- ;   WITH FUNCTABLE(.INPUT.) DO
; CEDING CONSTANT DECLARATIONS AT  ;   BEGIN
; THE LABELS:                      ;     INTERRUPT := TRUE;
;                                  ;     FUNC := READ;
;       USER27, AND                ;     GO := TRUE;
;       FTBL27.                    ;     INHIBITINCREMENT := FALSE;
;                                  ;     FORMAT := FALSE;
;                                  ;     STOPONSOFTERROR := FALSE;
;                                  ;     ADDRBITS := 0;
;                                  ;   END;
;                                  ;   WITH FUNCTABLE(.OUTPUT.) DO
;                                  ;   BEGIN
;                                  ;     INTERRUPT := TRUE;
;                                  ;     FUNC := WRITE;
;                                  ;     GO := TRUE;
;                                  ;     INHIBITINCREMENT := FALSE;
;                                  ;     FORMAT := FALSE;
;                                  ;     STOPONSOFTERROR := FALSE;
;                                  ;     ADDRBITS := 0;
;                                  ;   END;
        RTS    PC                  ; END "OF INITIALIZE";
                                   ;
                                   ;
INIT27:                            ; BEGIN
        MOV    #ERRR27,DEVR39      ;   CONNECTED := DEVICEPRESENT(
        JSR    PC,DEVI39           ;                          ERRORREG);
        MOV    DEV39R,CONN27       ;
        BEQ    1$                  ;   IF CONNECTED THEN
        JSR    PC,INIZ27           ;     INITIALIZE;
1$:     RTS    PC                  ; END "OF RK11DISK";
                                   ;
                                   ;
        .PAGE
        .SBTTL TERMINAL (LT33) I/O DRIVER
                                   ;"###################################
                                   ;                  #  LT33TERMINAL  #
                                   ;###################################"
                                   ;
                                   ;
                                   ; VAR LT33TERMINAL:
                                   ; CLASS
                                   ;
BELC28  =      7.                  ; CONST BELCHAR = '(:7:)';
LFCH28  =      10.                 ;       LFCHAR = '(:10:)';
CRCH28  =      13.                 ;       CRCHAR = '(:13:)';
                                   ;
      $ =      0                   ; TYPE TERMINALSTATE = (
PASS28  =      $                   ;                       PASSIVE,
      $ =      $ + 1               ;
READ28  =      $                   ;                       READING,
      $ =      $ + 1               ;
WRIT28  =      $                   ;                       WRITING
                                   ;                      );
                                   ;
      $ =      0                   ; TYPE TERMCONTROL = (
WAIT28  =      $                   ;                     WAITFORBELL
                                   ;                    );
                                   ;
                                   ; TYPE STATUSTYPE =
                                   ;   PACKED RECORD
BUSY28  =      TSRBSY              ;     BUSY,
DONE28  =      TSRRDY              ;     DONE,
INEN28  =      TSRIDE              ;     INTERRUPT,
GO28    =      TSRGO               ;     GO: BOOLEAN;
                                   ;   END;
                                   ;
                                   ; VAR ENTRY
STAT28: .WORD  PASS28              ;     STATE: TERMINALSTATE;
BELL28: .BLKB  .SIGNAL             ; VAR BELL: SIGNAL;
CHAR28: .BLKB  .ADDRESS            ;     CHARADDR: @BUFFERTYPE;
USER28: .BLKB  .ADDRESS            ;     USER: PROCESSREF;
OUTL28: .WORD  0                   ;     OUTLF: BOOLEAN;
ECHO28: .WORD  0                   ;     ECHO: BOOLEAN;
INCH28: .BLKB  .CHAR               ;     INCHAR: CHAR;
CONN28: .BLKB  .BOOLEAN            ; VAR ENTRY
                                   ;     CONNECTED: BOOLEAN;
                                   ; "HARDWARE"
                                   ;     READREGS:
                                   ;         PACKED RECORD
RDST28  =      RCSR                ;         READSTATUS: STATUSTYPE;
RDBF28  =      RBUF                ;         READBUF: CHAR;
                                   ;       END;
                                   ;     WRITEREGS:
                                   ;       PACKED RECORD
WRST28  =      XCSR                ;         WRITESTATUS: STATUSTYPE;
WRBF28  =      XBUF                ;         WRITEBUF: CHAR;
                                   ;       END;
                                   ;
                                   ;
CH28:   .BLKB  .CHAR               ; PROCEDURE WRITECHAR(CH: CHAR);
                                   ;
WRCH28:                            ; BEGIN
        MOV    #WRIT28,STAT28      ;   STATE := WRITING;
        CMP    #LFCH28,CH28        ;   IF CH = LFCHAR THEN
        BNE    1$                  ;     BEGIN
        MOV    #1,OUTL28           ;       OUTLF := TRUE;
        MOV    #CRCH28,WRBF28      ;       WRITEBUF := CRCHAR;
        BR     2$                  ;     END ELSE
1$:     MOV    CH28,WRBF28         ;     WRITEBUF := CH;
2$:     BIS    #INEN28,WRST28      ;   WRITEREGS.WRITESTATUS.INTERRUPT
                                   ;                            := TRUE;
        RTS    PC                  ; END;
                                   ;
                                   ;
                                   ; PROCEDURE READINTERRUPT;
                                   ;
RINT28:                            ; BEGIN
        MOV    RDBF28,INCH28       ;   INCHAR := READBUF;
        BIC    #ASCII8,INCH28      ;
        CMP    #BELC28,INCH28      ;   IF INCHAR = BELCHAR THEN
        BNE    1$                  ;
        MOV    #BELL28,SIG26T      ;     BELL.SEND ELSE
     $$ =      SEND26              ;
        BLTICK                     ;
        JSR    PC,$$               ;
        BR     2$                  ;
1$:     CMP    #READ28,STAT28      ;     IF STATE = READING THEN
        BNE    2$                  ;       BEGIN
        CMP    #CRCH28,INCH28      ;         IF INCHAR = CRCHAR THEN
        BNE    3$                  ;           INCHAR := LFCHAR;
        MOV    #LFCH28,INCH28      ;
3$:     MOV    #1,ECHO28           ;         ECHO := TRUE;
        MOV    INCH28,CH28         ;         WRITECHAR(INCHAR);
        JSR    PC,WRCH28           ;       END;
2$:     INC    RDST28              ;   READREGS.READSTATUS.GO := TRUE;
        RTS    PC                  ; END;
                                   ;
                                   ;
                                   ; PROCEDURE WRITEINTERRUPT;
                                   ;
WINT28:                            ; BEGIN
        CMP    #WRIT28,STAT28      ;   IF STATE = WRITING THEN
        BNE    1$                  ;     BEGIN
        TST    OUTL28              ;       IF OUTLF THEN
        BEQ    2$                  ;         BEGIN
        CLR    OUTL28              ;           OUTLF := FALSE;
        MOV    #LFCH28,WRBF28      ;           WRITEBUF := LFCHAR;
        BR     1$                  ;         END ELSE
2$:                                ;         BEGIN
        MOV    USER28,P12          ;           READY.ENTER(USER);
        JSR    PC,ENTE12           ;
        MOV    #PASS28,STAT28      ;           STATE := PASSIVE;
        TST    ECHO28              ;           IF ECHO THEN
        BEQ    3$                  ;             BEGIN
        CLR    ECHO28              ;               ECHO := FALSE;
        MOV    USER28,P10          ;               VIRTUAL.GETMAP(USER);
        JSR    PC,GETM10           ;
        MOV    INCH28,-(SP)        ;               CHARADDR@ := INCHAR;
        BIS    #PSPMDU,PSW         ;
        MTPD   @CHAR28             ;             END;
3$:     JSR    PC,ENDI12           ;           READY.ENDIO;
                                   ;         END;
                                   ;     END;
1$:     RTS    PC                  ; END;
                                   ;
                                   ;
BUF28:  .BLKB  .ADDRESS            ; PROCEDURE INITIO(VAR BUF:
                                   ;                        @BUFFERTYPE;
COM28:  .BLKB  .ADDRESS            ;                  VAR COM:
                                   ;                          @IOPARAM);
                                   ;
OPER28: .BLKB  .INTEGER            ; VAR OPER: IOOPERATION;
                                   ;
INIO28:                            ; BEGIN
        MOV    COM28,R0            ;   OPER := COM@.OPERATION;
        MFPD   (R0)+               ;
        MOV    (SP)+,R1            ;
        MOV    R1,OPER28           ;
        CLR    -(SP)               ;   COM@.STATUS := COMPLETE;
        MTPD   (R0)                ;
        ASL    R1                  ;   CASE OPER OF
        JMP    1$(R1)              ;
1$:     BR     2$                  ;
        BR     3$                  ;
        BR     4$                  ;
        BR     5$                  ;
2$: 3$:                            ;     INPUT, OUTPUT:
                                   ;     BEGIN
        JSR    PC,PREE11           ;       USER := RUNNING.PREEMPTED;
        MOV    PRE11R,USER28       ;
        TST    OPER28              ;       IF OPER = INPUT THEN
        BNE    6$                  ;         BEGIN
        MOV    BUF28,CHAR28        ;           CHARADDR := BUF;
        MOV    #READ28,STAT28      ;           STATE := READING;
        RTS    PC                  ;         END ELSE
6$:     MFPD   @BUF28              ;         WRITECHAR(BUF@);
        MOV    (SP)+,CH28          ;
        JSR    PC,WRCH28           ;
        RTS    PC                  ;     END;
5$:                                ;     CONTROL:
        MOV    #BELL28,SIG26T      ;       BELL.AWAIT;
        JSR    PC,AWAI26           ;
4$:                                ;     MOVE: ;
        RTS    PC                  ;   END;
                                   ; END;
                                   ;
                                   ;
CHR28:  .BLKB  .CHAR               ; PROCEDURE KERNELWRITE(CHR: CHAR);
                                   ;
KERN28:                            ; BEGIN
                                   ; WITH WRITEREGS, WRITESTATUS DO
                                   ;   BEGIN
1$:     TSTB   WRST28              ;     REPEAT UNTIL DONE;
        BGE    1$                  ;
        MOV    #PASS28,STAT28      ;     STATE := PASSIVE;
        MOV    CHR28,WRBF28        ;     WRITEBUF := CHR;
2$:     TSTB   WRST28              ;     REPEAT UNTIL DONE;
        BGE    2$                  ;
        CLR    OUTL28              ;     OUTLF := FALSE;
        CLR    ECHO28              ;     ECHO := FALSE;
        RTS    PC                  ;   END;
                                   ; END;
                                   ;
                                   ;
                                   ; PROCEDURE INITIALIZE;
                                   ;
INIZ28:                            ; BEGIN
        MOV    #BELL28,SIG26T      ;   BELL.INITIALIZE;
        JSR    PC,INIT26           ;
                                   ;   STATE := PASSIVE;
                                   ;   OUTLF := FALSE;
                                   ;   ECHO := FALSE;
                                   ;   WITH READREGS, READSTATUS DO
                                   ;   BEGIN
      $ =      INEN28 + GO28       ;     INTERRUPT := TRUE;
        MOV    #$,RDST28           ;     GO := TRUE;
                                   ;   END;
                                   ;   WRITEREGS.WRITESTATUS.INTERRUPT
                                   ;                           := FALSE;
        RTS    PC                  ; END "OF INITIALIZE";
                                   ;
                                   ;
INIT28:                            ; BEGIN
        MOV    #RDST28,DEVR39      ;   CONNECTED := DEVICEPRESENT(
        JSR    PC,DEVI39           ;               READREGS.READSTATUS);
        MOV    DEV39R,CONN28       ;
        BEQ    1$                  ;   IF CONNECTED THEN
        MOV    #WRST28,DEVR39      ;   CONNECTED := DEVICEPRESENT(
        JSR    PC,DEVI39           ;             WRITEREGS.WRITESTATUS);
        MOV    DEV39R,CONN28       ;
        BEQ    1$                  ;   IF CONNECTED THEN
        JSR    PC,INIZ28           ;     INITIALIZE;
1$:     RTS    PC                  ; END "OF LT33TERMINAL";
                                   ;
                                   ;
        .PAGE
        .SBTTL LINE PRINTER (LPXX) I/O DRIVER
                                   ;"###################################
                                   ;                   #  LPXXPRINTER  #
                                   ;###################################"
                                   ;
                                   ;
                                   ; VAR LPXXPRINTER:
                                   ; CLASS
                                   ;
                                   ; TYPE LINE = ARRAY (.1..124.) OF
                                   ;                               CHAR;
USER29: .WORD  NIL                 ; VAR USER: PROCESSREF;
ADDR29: .BLKB  .ADDRESS            ;     ADDR: @IORESULT;
CONN29: .BLKB  .BOOLEAN            ; VAR ENTRY
                                   ;     CONNECTED: BOOLEAN;
                                   ; "HARDWARE"
STAT29  =      LPS                 ;     STATUSREG:
                                   ;       PACKED RECORD
ERRO29  =      LPSERR              ;         ERROR,
READ29  =      LPSRDY              ;         READY,
INEN29  =      LPSIDE              ;         INTERRUPT: BOOLEAN;
                                   ;       END;
BUFF29  =      LPB                 ;     BUFFER: CHAR;
                                   ;
                                   ;
BUF29:  .BLKB  .ADDRESS            ; PROCEDURE INITIO(BUF: @LINE;
COM29:  .BLKB  .ADDRESS            ;                  VAR COM:
                                   ;                          @IOPARAM);
                                   ;
;CURSOR IS     R0                  ; VAR CURSOR: @LINE;
;I      IS     R0                  ;     I: INTEGER;
                                   ;
INIO29: MOV    COM29,R0            ; BEGIN
        MFPD   (R0)+               ;
        MOV    (SP)+,R1            ;
        TST    STAT29              ;   IF STATUSREG.ERROR THEN "OFFLINE"
        BGE    1$                  ;     COM@.STATUS := INTERVENTION
        MOV    #INTE22,R2          ;                                ELSE
        BR     2$                  ;
1$:     DEC    R1                  ;     IF COM@.OPERATION <> OUTPUT
        BEQ    3$                  ;                                THEN
        CLR    R2                  ;       COM@.STATUS := COMPLETE ELSE
2$:     MOV    R2,-(SP)            ;
        MTPD   (R0)                ;
        RTS    PC                  ;
3$:                                ;       BEGIN
        MOV    R0,ADDR29           ;         ADDR := @COM@.STATUS;
        MOV    BUF29,R0            ;         CURSOR := BUF;
                                   ;         I := 1;
4$:     MFPD   (R0)+               ;         REPEAT
        MOV    (SP)+,R1            ;           STATUSREG.INTERRUPT:=
        BIS    #INEN29,STAT29      ;             TRUE;
        MOV    #8.,R2
5$:     SOB    R2,5$
        MOVB   R1,BUFF29           ;           BUFFER:= CURSOR@(.I.);
        MOV    #8.,R2
6$:     SOB    R2,6$
        TSTB   STAT29              ;
        BGE    9$                  ;
        SWAB   R1                  ;
        BIS    #INEN29,STAT29      ;
        MOV    #8.,R2
7$:     SOB    R2,7$
        MOVB   R1,BUFF29           ;           I:= I + 1;
        MOV    #8.,R2
8$:     SOB    R2,8$
        TSTB   STAT29              ;
        BMI    4$                  ;         UNTIL NOT STATUSREG.READY;
9$:
        JSR    PC,PREE11           ;         USER := RUNNING.PREEMPTED;
        MOV    PRE11R,USER29       ;
        RTS    PC                  ;       END;
                                   ; END;
                                   ;
                                   ;
                                   ; PROCEDURE INTERRUPT;
                                   ;
INTE29:                            ; BEGIN
        TST    USER29              ;   IF USER <> NIL THEN
        BNE    1$                  ;
        RTS    PC                  ;     BEGIN
1$:     MOV    USER29,P12          ;       READY.ENTER(USER);
        JSR    PC,ENTE12           ;
        MOV    USER29,P10          ;       VIRTUAL.GETMAP(USER);
        JSR    PC,GETM10           ;
        CLR    -(SP)               ;
        TST    STAT29              ;       IF STATUSREG.ERROR THEN
        BGE    2$                  ;
        INC    (SP)                ;         ADDR@ := INTERVENTION ELSE
2$:     BIS    #PSPMDU,PSW         ;
        MTPD   @ADDR29             ;         ADDR@ := COMPLETE;
        CLR    USER29              ;       USER := NIL;
        JSR    PC,ENDI12           ;       READY.ENDIO;
        RTS    PC                  ;     END;
                                   ; END;
                                   ;
                                   ;
                                   ; PROCEDURE INITIALIZE;
                                   ;
INIZ29:                            ; BEGIN
; DONE AT LABEL "USER29".          ;   USER := NIL;
;                                  ;   STATUSREG.INTERRUPT := FALSE;
        RTS    PC                  ; END "OF INITIALIZE";
                                   ;
                                   ;
INIT29:                            ; BEGIN
        MOV    #STAT29,DEVR39      ;   CONNECTED := DEVICEPRESENT(
        JSR    PC,DEVI39           ;                         STATUSREG);
        MOV    DEV39R,CONN29       ;
        BEQ    1$                  ;   IF CONNECTED THEN
        JSR    PC,INIZ29           ;     INITIALIZE;
1$:     RTS    PC                  ; END "OF LPXXPRINTER";
                                   ;
                                   ;
        .PAGE
        .SBTTL CARDREADER (CD11-A) I/O DRIVER
                                   ;"###################################
                                   ;               #  CD11ACARDREADER  #
                                   ;###################################"
                                   ;
                                   ;
                                   ; VAR CD11ACARDREADER:
                                   ; CLASS
                                   ;
IOCO30  =      -80.                ; CONST IOCOUNT = -80;
SUBC30  =      26.                 ;       SUBCHAR = '(:26:)';
                                   ;
                                   ; TYPE CHARCODE = -128..127;
                                   ; TYPE CARD = ARRAY (.1..80.) OF
                                   ;                               CHAR;
USER30: .WORD  NIL                 ; VAR USER: PROCESSREF;
ADDR30: .BLKB  .ADDRESS            ;     ADDR: @IORESULT;
IMAG30: .BLKB  .ADDRESS            ;     IMAGE: @CARD;
                                   ;     I: INTEGER;
BUFF30: .BLKB  80.                 ;     BUFFER: ARRAY (.1..80.) OF
                                   ;                           CHARCODE;
TRAN30  =      TTBL30 + 128.       ;     TRANSLATE: ARRAY (.CHARCODE.)
                                   ;                            OF CHAR;
CONN30: .BLKB  .BOOLEAN            ; VAR ENTRY
                                   ;     CONNECTED: BOOLEAN;
                                   ; "HARDWARE"
STAT30  =      CDST                ;     STATUSREG:
                                   ;       PACKED RECORD
ERRO30  =      CDSERR              ;         ERROR,
RDCH30  =      CDSRDC              ;         READERCHECK,
ENDO30  =      CDSEOF              ;         ENDOFFILE,
OFFL30  =      CDSOFL              ;         OFFLINE,
DTER30  =      CDSDER              ;         DATAERROR,
DTLT30  =      CDSDTL              ;         DATALATE,
NONE30  =      CDSNXM              ;         NONEXISTENTMEMORY,
POWE30  =      CDSPCL              ;         POWERCLEAR,
READ30  =      CDSRDY              ;         READY,
INEN30  =      CDSIDE              ;         INTERRUPT: BOOLEAN;
ADDB30  =      CDSMEX              ;         ADDRBITS: 0..3;
TRNS30  =      CDSOLT              ;         TRANSITION,
HOPP30  =      CDSHPC              ;         HOPPERCHECK,
DTPK30  =      CDSDPK              ;         DATAPACKING,
GO30    =      CDSGO               ;         GO: BOOLEAN;
                                   ;       END;
COUN30  =      CDCC                ;     COUNTREG: INTEGER;
ADRG30  =      CDBA                ;     ADDRREG: ADDRESS;
                                   ;
                                   ;
BUF30:  .BLKB  .ADDRESS            ; PROCEDURE INITIO(VAR BUF: @CARD;
COM30:  .BLKB  .ADDRESS            ;                  VAR COM:
                                   ;                          @IOPARAM);
                                   ;
INIO30: MOV    COM30,R0            ; BEGIN
        MFPD   (R0)+               ;   WITH STATUSREG DO
        MOV    (SP)+,R1            ;   BEGIN
        BIT    #OFFL30,STAT30      ;     IF OFFLINE THEN
        BEQ    1$                  ;
        MOV    #INTE22,-(SP)       ;       COM@.STATUS := INTERVENTION
        BR     2$                  ;                                ELSE
1$:     TST    R1                  ;       IF COM@.OPERATION <> INPUT
                                   ;                                THEN
        BEQ    3$                  ;         COM@.STATUS := COMPLETE
        CLR    -(SP)               ;                                ELSE
2$:     MTPD   (R0)                ;
        RTS    PC                  ;         BEGIN
3$:     MOV    R0,ADDR30           ;           ADDR := @COM@.STATUS;
        MOV    BUF30,IMAG30        ;           IMAGE := BUF;
        MOV    #BUFF30,ADRG30      ;           ADDRREG := @BUFFER;
        MOV    #IOCO30,COUN30      ;           COUNTREG := IOCOUNT;
      $ =      INEN30              ;           INTERRUPT := TRUE;
        BIS    #<$+GO30>,STAT30    ;           GO := TRUE;
        JSR    PC,PREE11           ;           USER :=
        MOV    PRE11R,USER30       ;                  RUNNING.PREEMPTED;
        RTS    PC                  ;         END;
                                   ;   END;
                                   ; END;
                                   ;
                                   ;
                                   ; PROCEDURE INTERRUPT;
                                   ;
;RESULT IS     R0                  ; VAR RESULT: IORESULT;
;I      IS     R0                  ;     I: INTEGER;
                                   ;
INTE30: MOV    USER30,R0           ; BEGIN
        BNE    1$                  ;   IF USER <> NIL THEN
        RTS    PC                  ;     WITH STATUSREG DO
1$:     MOV    R0,P12              ;     BEGIN
        JSR    PC,ENTE12           ;       READY.ENTER(USER);
        MOV    USER30,P10          ;       VIRTUAL.GETMAP(USER);
        JSR    PC,GETM10           ;
        CLR    R0                  ;       RESULT := COMPLETE;
        MOV    STAT30,R1           ;       IF ERROR THEN
        BGE    2$                  ;
        BIT    #OFFL30,R1          ;         IF OFFLINE AND
        BEQ    8$                  ;
        BIT    #HOPP30,R1          ;            NOT HOPPERCHECK THEN
        BEQ    3$                  ;           RESULT := INTERVENTION
                                   ;                                ELSE
8$:     BIT    #DTLT30,R1          ;           IF DATALATE THEN
        BNE    7$                  ;             RESULT := FAILURE ELSE
        BIT    #DTER30,R1          ;             IF DATAERROR THEN
        BNE    6$                  ;               RESULT :=
        BR     2$                  ;                       TRANSMISSION;
7$:     INC    R0                  ;
6$:     INC    R0                  ;
3$:     INC    R0                  ;
2$:     MOV    R0,-(SP)            ;       ADDR@ := RESULT;
        BIS    #PSPMDU,PSW         ;
        MTPD   @ADDR30             ;
        TST    R0                  ;       IF (RESULT = COMPLETE) OR
        BEQ    9$                  ;
        CMP    #TRAN22,R0          ;          (RESULT = TRANSMISSION)
        BNE    4$                  ;                                THEN
9$:     MOV    #40.,R0             ;         FOR I := 1 TO 80 DO
        MOV    IMAG30,R1           ;
        MOV    #BUFF30,R2          ;
5$:     MOVB   (R2)+,R3            ;       IMAGE@(.I.) :=
        MOVB   TRAN30(R3),R4       ;           TRANSLATE(.BUFFER(.I.).);
        MOVB   (R2)+,R3            ;
        MOVB   TRAN30(R3),R3       ;
        SWAB   R3                  ;
        BIS    R4,R3               ;
        MOV    R3,-(SP)            ;
        MTPD   (R1)+               ;
        SOB    R0,5$               ;
4$:     CLR    USER30              ;       USER := NIL;
        JSR    PC,ENDI12           ;       READY.ENDIO;
        RTS    PC                  ;     END;
                                   ; END;
                                   ;
                                   ;
                                   ; PROCEDURE INITIALIZE;
                                   ;
INIZ30:                            ; BEGIN
; DONE AT LABEL "USER30".          ;   USER := NIL;
;                                  ;   WITH STATUSREG DO
;                                  ;   BEGIN
        BIS    #POWE30,STAT30      ;     POWERCLEAR := TRUE;
      $ =      0                   ;     INTERRUPT := FALSE;
                                   ;     ADDRBITS := 0;
      $ =      $ + DTPK30          ;     DATAPACKING := TRUE;
                                   ;     GO := FALSE;
        BIS    #$,STAT30           ;   END;
        RTS    PC                  ;
TTBL30:                            ;
        .ASCII /&ABCDEFGH/         ;   TRANSLATE(.-128.) := '&';
                                   ;   TRANSLATE(.-127.) := 'A';
                                   ;   TRANSLATE(.-126.) := 'B';
                                   ;   TRANSLATE(.-125.) := 'C';
                                   ;   TRANSLATE(.-124.) := 'D';
                                   ;   TRANSLATE(.-123.) := 'E';
                                   ;   TRANSLATE(.-122.) := 'F';
                                   ;   TRANSLATE(.-121.) := 'G';
                                   ;   TRANSLATE(.-120.) := 'H';
        .ASCII <SUBC30><SUBC30>    ;   TRANSLATE(.-119.) := SUBCHAR;
                                   ;   TRANSLATE(.-118.) := SUBCHAR;
        .ASCII /.<(+!I/            ;   TRANSLATE(.-117.) := '.';
                                   ;   TRANSLATE(.-116.) := '<';
                                   ;   TRANSLATE(.-115.) := '(';
                                   ;   TRANSLATE(.-114.) := '+';
                                   ;   TRANSLATE(.-113.) := '!';
                                   ;   TRANSLATE(.-112.) := 'I';
        .REPT  55.                 ;   FOR I := -111 TO -1 DO
        .ASCII <SUBC30><SUBC30>    ;   TRANSLATE(.I.) := SUBCHAR;
        .ENDR                      ;
        .ASCII <SUBC30>            ;
        .ASCII / 12345678/         ;   TRANSLATE(.0.) := ' ';
                                   ;   TRANSLATE(.1.) := '1';
                                   ;   TRANSLATE(.2.) := '2';
                                   ;   TRANSLATE(.3.) := '3';
                                   ;   TRANSLATE(.4.) := '4';
                                   ;   TRANSLATE(.5.) := '5';
                                   ;   TRANSLATE(.6.) := '6';
                                   ;   TRANSLATE(.7.) := '7';
                                   ;   TRANSLATE(.8.) := '8';
        .ASCII <SUBC30>            ;   TRANSLATE(.9.) := SUBCHAR;
        .ASCII /:#@'="9/           ;   TRANSLATE(.10.) := ':';
                                   ;   TRANSLATE(.11.) := '#';
                                   ;   TRANSLATE(.12.) := '@';
                                   ;   TRANSLATE(.13.) := '''';
                                   ;   TRANSLATE(.14.) := '=';
                                   ;   TRANSLATE(.15.) := '"';
                                   ;   TRANSLATE(.16.) := '9';
        .REPT  7                   ;   FOR I := 17 TO 31 DO
        .ASCII <SUBC30><SUBC30>    ;   TRANSLATE(.I.) := SUBCHAR;
        .ENDR                      ;
        .ASCII <SUBC30>            ;
        .ASCII ;0/STUVWXY;         ;   TRANSLATE(.32.) := '0';
                                   ;   TRANSLATE(.33.) := '/';
                                   ;   TRANSLATE(.34.) := 'S';
                                   ;   TRANSLATE(.35.) := 'T';
                                   ;   TRANSLATE(.36.) := 'U';
                                   ;   TRANSLATE(.37.) := 'V';
                                   ;   TRANSLATE(.38.) := 'W';
                                   ;   TRANSLATE(.39.) := 'X';
                                   ;   TRANSLATE(.40.) := 'Y';
        .ASCII <SUBC30><SUBC30>    ;   TRANSLATE(.41.) := SUBCHAR;
                                   ;   TRANSLATE(.42.) := SUBCHAR;
        .ASCII /,%_>?Z/            ;   TRANSLATE(.43.) := ',';
                                   ;   TRANSLATE(.44.) := '%';
                                   ;   TRANSLATE(.45.) := '_';
                                   ;   TRANSLATE(.46.) := '>';
                                   ;   TRANSLATE(.47.) := '?';
                                   ;   TRANSLATE(.48.) := 'Z';
        .REPT  7                   ;   FOR I := 49 TO 63 DO
        .ASCII <SUBC30><SUBC30>    ;   TRANSLATE(.I.) := SUBCHAR;
        .ENDR                      ;
        .ASCII <SUBC30>            ;
        .ASCII /-JKLMNOPQ/         ;   TRANSLATE(.64.) := '-';
                                   ;   TRANSLATE(.65.) := 'J';
                                   ;   TRANSLATE(.66.) := 'K';
                                   ;   TRANSLATE(.67.) := 'L';
                                   ;   TRANSLATE(.68.) := 'M';
                                   ;   TRANSLATE(.69.) := 'N';
                                   ;   TRANSLATE(.70.) := 'O';
                                   ;   TRANSLATE(.71.) := 'P';
                                   ;   TRANSLATE(.72.) := 'Q';
        .ASCII <SUBC30><SUBC30>    ;   TRANSLATE(.73.) := SUBCHAR;
                                   ;   TRANSLATE(.74.) := SUBCHAR;
        .ASCII /$*);^R/            ;   TRANSLATE(.75.) := '$';
                                   ;   TRANSLATE(.76.) := '*';
                                   ;   TRANSLATE(.77.) := ')';
                                   ;   TRANSLATE(.78.) := ';';
                                   ;   TRANSLATE(.79.) := '^';
                                   ;   TRANSLATE(.80.) := 'R';
        .REPT  23.                 ;   FOR I := 81 TO 127 DO
        .ASCII <SUBC30><SUBC30>    ;   TRANSLATE(.I.) := SUBCHAR;
        .ENDR                      ;
        .ASCII <SUBC30>            ;
                                   ; END "OF INITIALIZE";
                                   ;
                                   ;
INIT30:                            ; BEGIN
        MOV    #STAT30,DEVR39      ;   CONNECTED := DEVICEPRESENT(
        JSR    PC,DEVI39           ;                         STATUSREG);
        MOV    DEV39R,CONN30       ;
        BEQ    1$                  ;   IF CONNECTED THEN
        JSR    PC,INIZ30           ;     INITIALIZE;
1$:     RTS    PC                  ; END "OF CD11ACARDREADER";
                                   ;
                                   ;
        .PAGE
        .SBTTL COMMON I/O CONTROL
                                   ;"###################################
                                   ;                  #  IO/INTERRUPT  #
                                   ;###################################"
                                   ;
                                   ;
                                   ; PROCEDURE ENTRY IO(VAR BUFFER:
                                   ;                         BUFFERTYPE;
                                   ;                    VAR PARAM:
                                   ;                           @IOPARAM;
                                   ;                    DEVICE:
                                   ;                          IODEVICE);
                                   ;
UNI031  =      0                   ; CONST UNIT0 = 0;
UNI131  =      2                   ;       UNIT1 = 2;
                                   ;
                                   ; VAR NODEVICE: BOOLEAN;
                                   ;
IO31:                              ; BEGIN
        STIO11                     ;   RUNNING.STARTIO;
                                   ;   NODEVICE := FALSE;
        MOV    #<HEAD11+PARAM1>,R0 ;
        MOV    (R0)+,R1            ;
        MOV    (R0)+,R2            ;
        MOV    (R0),R0             ;   CASE DEVICE OF
        ASL    R0                  ;
        JMP    1$(R0)              ;
1$:     BR     2$                  ;
        BR     3$                  ;
        BR     4$                  ;
        BR     5$                  ;
        BR     6$                  ;
        BR     7$                  ;
2$:     TST    CONN28              ;     TTY0:
        BEQ    NODE31              ;     WITH LT33TERMINAL DO
        MOV    R1,BUF28            ;     IF CONNECTED THEN
        MOV    R2,COM28            ;       INITIO(BUFFER, PARAM) ELSE
        JMP    INIO28              ;       NODEVICE := TRUE;
                                   ;
3$:     TST    CONN27              ;     DISK0:
        BEQ    NODE31              ;     WITH RK11DISK DO
        MOV    R1,BUF27            ;     IF CONNECTED THEN
        MOV    R2,COM27            ;       INITIO(BUFFER, PARAM, UNIT0)
        CLR    UNIN27              ;       ELSE NODEVICE := TRUE;
        JMP    INIO27              ;
                                   ;
4$:     CLR    UNIN25              ;     TAPE90:
41$:    TST    CONN25              ;     WITH TM11TAPE DO
        BEQ    NODE31              ;     IF CONNECTED THEN
        MOV    R1,BUF25            ;       INITIO(BUFFER, PARAM, UNIT0)
        MOV    R2,COM25            ;       ELSE NODEVICE := TRUE;
        JMP    INIO25              ;
                                   ;
5$:     TST    CONN29              ;     PRINTER0:
        BEQ    NODE31              ;     WITH LPXXPRINTER DO
        MOV    R1,BUF29            ;     IF CONNECTED THEN
        MOV    R2,COM29            ;       INITIO(BUFFER, PARAM) ELSE
        JMP    INIO29              ;       NODEVICE := TRUE;
                                   ;
6$:     TST    CONN30              ;     CARDREADER0:
        BEQ    NODE31              ;     WITH CD11ACARDREADER DO
        MOV    R1,BUF30            ;     IF CONNECTED THEN
        MOV    R2,COM30            ;       INITIO(BUFFER, PARAM) ELSE
        JMP    INIO30              ;       NODEVICE := TRUE;
                                   ;
7$:                                ;     TAPE91:
        MOV    #UNI131,UNIN25      ;     WITH TM11TAPE DO
        BR     41$                 ;     IF CONNECTED THEN
                                   ;       INITIO(BUFFER, PARAM, UNIT1)
                                   ;       ELSE NODEVICE := TRUE;
                                   ;
                                   ;   END;
NODE31: MOV    R2,PARA38           ;   IF NODEVICE THEN
        JMP    IOFA38              ;     IOFAIL(PARAM);
                                   ; END;
                                   ;
                                   ;
                                   ; PROCEDURE ENTRY INTERRUPT(DEVICE:
                                   ;                          IODEVICE);
                                   ; BEGIN
                                   ;   CASE DEVICE OF
                                   ;     TTY0:
                                   ;       WITH LT33TERMINAL DO
                                   ;       CASE STATE OF
LTIN32: 		           ;         PASSIVE, READING:
        INTSRV RINT28              ;<01>                  READINTERRUPT;

LTOU32:                            ;<01>     WRITING: WRITEINTERRUPT;
        INTSRV WINT28              ;<01>    END;

RKIN32:                            ;<01> DISK0: RK11DISK.INTERRUPT;
        INTSRV INTE27              ;<01>

TMIN32:                            ;<01> TAPE90, TAPE91:
        INTSRV INTE25              ;<01>             TM11TAPE.INTERRUPT;

LPIN32:                            ;<01> PRINTER0:
        INTSRV INTE29              ;<01>          LPXXPRINTER.INTERRUPT;

CDIN32:			           ;<01> CARDREADER0:
        INTSRV INTE30              ;<01>      CD11ACARDREADER.INTERRUPT;
                                   ;   END;
                                   ; END;
                                   ;
                                   ;
        .PAGE
        .SBTTL MESSAGE WRITERS
                                   ;"###################################
                                   ;                      #  MESSAGES  #
                                   ;###################################"
                                   ;
                                   ;
NEWL35: .ASCIZ <13.><10.>          ; CONST NEWLINE =
        .EVEN                      ;                '(:13:)(:10:)(:0:)';
                                   ;
                                   ; TYPE LINE = UNIV STRING;
                                   ;
                                   ;
TEXT33: .BLKB  .ADDRESS            ; PROCEDURE WRITETEXT(TEXT: @LINE);
                                   ;
NULC33  =      0                   ; CONST NULCHAR = '(:0:)';
                                   ;
I33:    .BLKB  .ADDRESS            ; VAR I: INTEGER;
                                   ;
WRIT33:                            ; BEGIN
        MOV    TEXT33,I33          ;   I := 1;
1$:     MOV    I33,R0              ;   WHILE NOT (TEXT@(.I.) = NULCHAR)
        MOVB   (R0)+,R1            ;                                  DO
        BNE    2$                  ;
        RTS    PC                  ;
2$:     MOV    R0,I33              ;   BEGIN
        MOV    R1,CHR28            ;     LT33TERMINAL.KERNELWRITE(
        JSR    PC,KERN28           ;                        TEXT@(.I.));
        BR     1$                  ;     I :+ 1;
                                   ;   END;
                                   ; END;
                                   ;
                                   ;
NN34:   .BLKB  .INTEGER            ; PROCEDURE WRITEINT(NN: INTEGER);
                                   ;
BLAN34  =      '                   ; CONST BLANK = ' ';
NULC34  =      0                   ;       NULCHAR = '(:0:)';
ZERO34  =      '0                  ;
                                   ;
;N      IS     R0, R1              ; VAR N: INTEGER;
;I      IS     R2                  ;     I: INTEGER;
INT34:  .ASCIZ /012345/            ;     INT: ARRAY (.1..7.) OF CHAR;
        .EVEN                      ;
WRIT34:                            ; BEGIN
                                   ;   INT(.7.) := NULCHAR;
        MOV    NN34,R1             ;   N := NN;
        MOV    #<INT34+6>,R2       ;   I := 7;
                                   ;   REPEAT
1$:     CLR    R0                  ;     I :- 1;
        DIV    #10.,R0             ;     INT(.I.) := CHR(N MOD 10 +
        ADD    #ZERO34,R1          ;                          ORD('0'));
        MOVB   R1,-(R2)            ;
        MOV    R0,R1               ;     N := N DIV 10;
        BNE    1$                  ;   UNTIL N = 0;
        MOVB   #BLAN34,-(R2)       ;   I :- 1;
                                   ;   INT(.I.) := BLANK;
        MOV    R2,TEXT33           ;   WRITETEXT(@INT(.I.));
        JSR    PC,WRIT33           ;
        RTS    PC                  ; END;
                                   ;
                                   ;
RESU19: .BLKB  .INTEGER            ; PROCEDURE KERNELERROR(RESULT:
                                   ;                              LINE);
SYST19: .ASCIZ /SYSTEM LINE/       ; CONST SYSTEM = 'SYSTEM LINE(:0:)';
BLAN19: .ASCIZ / /                 ;       BLANK = ' (:0:)';
        .EVEN                      ;
KERN19:                            ; BEGIN
        MOV    #NEWL35,TEXT33      ;   WRITETEXT(NEWLINE);
        JSR    PC,WRIT33           ;
        MOV    #SYST19,TEXT33      ;   WRITETEXT(SYSTEM);
        JSR    PC,WRIT33           ;
        MOV    HEAD11+OPLIN1,NN34  ;   WRITEINT(RUNNING.HEAD.OPLINE);
        JSR    PC,WRIT34           ;
        MOV    #BLAN19,TEXT33      ;   WRITETEXT(BLANK);
        JSR    PC,WRIT33           ;
        MOV    RESU19,TEXT33       ;   WRITETEXT(RESULT);
        JSR    PC,WRIT33           ;
        MOV    #NEWL35,TEXT33      ;   WRITETEXT(NEWLINE);
        JSR    PC,WRIT33           ;
        HALT                       ;   CYCLE END;
        SYSERR                     ;
                                   ; END;
                                   ;
                                   ;
                                   ; PROCEDURE KERNELREADY;
                                   ;
READ37: .ASCIZ /SYSTEM READY/      ; CONST READYMESSAGE =
        .EVEN                      ;                'SYSTEM READY(:0:)';
                                   ;
KERN37:                            ; BEGIN
        MOV    #NEWL35,TEXT33      ;   WRITETEXT(NEWLINE);
        JSR    PC,WRIT33           ;
        MOV    #READ37,TEXT33      ;   WRITETEXT(READYMESSAGE);
        JSR    PC,WRIT33           ;
        MOV    #NEWL35,TEXT33      ;   WRITETEXT(NEWLINE);
        JSR    PC,WRIT33           ;
        RTS    PC                  ; END;
                                   ;
                                   ;
        .PAGE
        .SBTTL KERNEL INITIALIZATION
                                   ;"###################################
                                   ;                #  INITIALIZATION  #
                                   ;###################################"
                                   ;
                                   ;
                                   ; "INITIALIZE THE KERNEL"
                                   ;
INIT36:                            ; BEGIN
; THE CODE FOR THESE STANDARD PRO- ;   LOADVIRTUALMACHINE;
; CEDURES IS TO BE FOUND IN THE    ;   LOADSYSTEMPROGRAM;
; PROCESSOR DEFINITION PREFIX OF   ;
; THIS PROGRAM.  IT IS INVOKED AS  ;
; PART OF THE INITIAL PROGRAM LOAD-;
; ING BY MEANS OF A JUMP TO ADDRESS;
; ZERO.                            ;
                                   ;
        JSR    PC,INIT16           ;   NEWCORE.INITIALIZE;
        JSR    PC,INIT6            ;   TIMER.INITIALIZE;
        JSR    PC,INIT7            ;   CLOCK.INITIALIZE;
        JSR    PC,INIT9            ;   CORE.INITIALIZE;
        JSR    PC,INIT10           ;   VIRTUAL.INITIALIZE;
        JSR    PC,INIT11           ;   RUNNING.INITIALIZE;
        JSR    PC,INIT12           ;   READY.INITIALIZE;
        JSR    PC,INIT25           ;   TM11TAPE.INITIALIZE;
        JSR    PC,INIT27           ;   RK11DISK.INITIALIZE;
        JSR    PC,INIT28           ;   LT33TERMINAL.INITIALIZE;
        JSR    PC,INIT29           ;   LPXXPRINTER.INITIALIZE;
        JSR    PC,INIT30           ;   CD11ACARDREADER.INITIALIZE;
                                   ;
        MOV    INTL99,INTL11       ;   RUNNING.INITPARENT(
        JSR    PC,INPA11           ;                 INTERPRETERLENGTH);
        JSR    PC,KERN37           ;   KERNELREADY;
        RTS    PC                  ; END "OF KERNEL";
                                   ;
                                   ;
        .SBTTL
        .SBTTL #########################################################
        .SBTTL
                                   ;"KERNELTEXT4"
        .PAGE
        .SBTTL KERNEL/INTERPRETER INTERFACE
	.DSABL	AMA		   ;<01> THE FOLLOWING CODE MUST BE 
				   ;<01> RELOCATABLE
                                   ;
                                   ;
INTL99: .WORD  <INTEND - USER99>   ; CONST INTERPRETERLENGTH = ...;
                                   ;
                                   ;
     $1 =      . - ZERO            ;  "ENSURE BLOCK ALIGNMENT"
     $2 =      <$1 + 63.> / 64.    ;
     $2 =      <$2 * 64.> - $1     ;
        .BLKB  $2                  ;
                                   ;
                                   ;
USER99: .BLKB  .PROCREF            ;
USER    =      USER99              ;
TABL99: .WORD   CONSTA-USER,LOCALA-USER,GLOBAL-USER,PUSHCO-USER
        .WORD   PUSHLO-USER,PUSHGL-USER,PUSHIN-USER,PUSHBY-USER
        .WORD   PUSHRE-USER,PUSHSE-USER,FIELD -USER,INDEX -USER
        .WORD   POINTE-USER,VARIAN-USER,RANGE -USER,COPYBY-USER
        .WORD   COPYWO-USER,COPYRE-USER,COPYSE-USER,COPYTA-USER
        .WORD   COPYST-USER,NEW   -USER,NEWINI-USER,NOT   -USER
        .WORD   ANDWOR-USER,ANDSET-USER,ORWORD-USER,ORSET -USER
        .WORD   NEGWOR-USER,NEGREA-USER,ADDWOR-USER,ADDREA-USER
        .WORD   SUBWOR-USER,SUBREA-USER,SUBSET-USER,MULWOR-USER
        .WORD   MULREA-USER,DIVWOR-USER,DIVREA-USER,MODWOR-USER
        .WORD   BUILDS-USER,INSET -USER,LSWORD-USER,EQWORD-USER
        .WORD   GRWORD-USER,NLWORD-USER,NEWORD-USER,NGWORD-USER
        .WORD   LSREAL-USER,EQREAL-USER,GRREAL-USER,NLREAL-USER
        .WORD   NEREAL-USER,NGREAL-USER,EQSET -USER,NLSET -USER
        .WORD   NESET -USER,NGSET -USER,LSSTRU-USER,EQSTRU-USER
        .WORD   GRSTRU-USER,NLSTRU-USER,NESTRU-USER,NGSTRU-USER
        .WORD   FUNCVA-USER,JUMP  -USER,FALSEJ-USER,CASEJU-USER
        .WORD   INITVA-USER,CALL  -USER,CALLSY-USER,ENTER -USER
        .WORD   EXIT  -USER,ENPROG-USER,EXPROG-USER,BEGINC-USER
        .WORD   ENDCLA-USER,ENTERC-USER,EXITCL-USER,BEGINM-USER
        .WORD   ENDMON-USER,ENTERM-USER,EXITMO-USER,BEGINP-USER
        .WORD   ENDPRO-USER,ENPROC-USER,EXPROC-USER,POP   -USER
        .WORD   NEWLIN-USER,INCWOR-USER,DECWOR-USER,INITCL-USER
        .WORD   INITMO-USER,INITPR-USER,PUSHLA-USER,CALLPR-USER
        .WORD   TRUNCR-USER,ABSWOR-USER,ABSREA-USER,SUCCWO-USER
        .WORD   PREDWO-USER,CONVWO-USER,EMPTY -USER,ATTRIB-USER
        .WORD   REALTI-USER,DELAY -USER,CONTIN-USER,IO    -USER
        .WORD   START -USER,STOP  -USER,SETHEA-USER,WAIT  -USER
HEAD99: .BLKB  .HEADTYPE           ;
CONS99: .BLKB  .INTEGER            ;
                                   ;
                                   ;
KLEN99  =      . - ZERO            ;
                                   ;
                                   ;


        .SBTTL
        .SBTTL #########################################################
        .SBTTL
        .PAGE
        .TITLE  PASCAL INTERPRETER


;  TOM ZEPKO
;  JORGENSEN LAB  286-80
;  CALIFORNIA INSTITUTE OF TECHNOLOGY
;  OCTOBER 1974


        .SBTTL  PROCESS HEAD    ;
                                ;
HEAD  = HEAD99 - USER99         ;  "THESE ENTRIES IN THE PROCESS HEAD
HEAPTO= HEAD99 + HEAPT1         ;    ARE USED BY THE INTERPRETER."
LINE  = HEAD99 + LINE1          ;
RESULT= HEAD99 + RESUL1         ;
JOB   = HEAD99 + JOB1           ;
CONT  = HEAD99 + CONTI1         ;
OPCODE= HEAD99 + OPCOD1         ;
ARG1  = HEAD99 + PARAM1         ;
ARG2  = HEAD99 + PARAM1 + 2     ;
ARG3  = HEAD99 + PARAM1 + 4     ;
ARG4  = HEAD99 + PARAM1 + 6     ;
OPLINE= HEAD99 + OPLIN1         ;
CONST = CONS99                  ;
                                ;
                                ;
        .SBTTL  KERNEL OPERATIONS
                                ;
INITG1= INIT18                  ;INITGATE1
ENTEG1= ENTE17                  ;ENTERGATE1
LEAVG1= LEAV17                  ;LEAVEGATE1
ENDPR1= ENDP14                  ;ENDPROCESS1
INITP1= INIT13                  ;INITPROCESS1
REALT1= REALT7                  ;REALTIME1
DELAY1= DELA17                  ;DELAYGATE1
CONTG1= CONT17                  ;CONTGATE1
STOPJ1= STOP15                  ;STOPJOB1
WAIT1 = WAIT7                   ;WAIT1
SYSTE1= SYST11                  ;SYSTEMERROR1
IO1   = IO31                    ;INPUT_OUTPUT
                                ;
                                ;
        .SBTTL  NEXT INSTRUCTION MACRO
        .MACRO  NEXT
        .IF NE  $.DBIT
        JSR     PC,ITRACE
        .ENDC
        MOV     @(Q)+,P
        .ENDM   NEXT
                                ;
                                ;
        .SBTTL  KERNEL CALL MACRO
        .MACRO  KNCALL
        MOV     (B),OPLINE
        IOT
        .ENDM   KNCALL
                                ;
                                ;
        .SBTTL  INTERPRETER TRACE MACRO
        .MACRO  INTRCE
        .IF NE  $.DBIT
        MOV     HEAD99+INDEX1,R0
        DEC     R0
        ASL     R0
        MOV     S,ENDSTK-USER99(R0)
        BR      ITRACX
ENDSTK: .REPT   PROCS
        .WORD   0
        .ENDR
ITRACE: MOV     (Q),ARG1
        MOV     Q,ARG2
        SUB     #2.,ARG2
        MOV     S,ARG3
        ADD     #2.,ARG3
        MOV     HEAD99+INDEX1,R1
        DEC     R1
        ASL     R1
        MOV     ENDSTK-USER99(R1),ARG4
        TRAP
        RTS     PC
ITRACX:
        .ENDC
        .ENDM   INTRCE
                                ;
                                ;
        .PAGE
        .SBTTL  START ADDRESS   ;
STARTA: INTRCE                  ;STARTADDR: P:=ST(Q); Q:+2;
        NEXT                    ;
                                ;
                                ;
        .SBTTL  REAL OVERFLOW   ;
REALOV: JMP     OVERFL          ;REALOVERFLOW:  GOTO OVERFLOWERROR;
                                ;
                                ;
        .SBTTL  CONSTADDR       ;  PROCEDURE CONSTADDR(DISPL);
                                ;  BEGIN
CONSTA: TST     JOB             ;    TEST ST(JOB);
        BNE     1$              ;    IF ZERO
        MOV     CONST,-(S)      ;      THEN BEGIN S:-2; ST(S):=ST(CONSTADDR); END; "SYSTEM"
        BR      2$              ;
1$:     MOV     10.(G),-(S)     ;      ELSE BEGIN S:-2; ST(S):=ST(G+10); END;     "JOB"
2$:     ADD     (Q)+,(S)        ;    ST(S):+ST(Q); Q:+2;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  LOCALADDR       ;  PROCEDURE LOCALADDR(DISPL);
                                ;  BEGIN
LOCALA: MOV     B,-(S)          ;    S:-2; ST(S):=B;
        ADD     (Q)+,(S)        ;    ST(S):+ST(Q); Q:+2;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  GLOBALADDR      ;  PROCEDURE GLOBALADDR(DISPL);
                                ;  BEGIN
GLOBAL: MOV     G,-(S)          ;    S:-2; ST(S):=G;
        ADD     (Q)+,(S)        ;    ST(S):+ST(Q); Q:+2;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  PUSHCONST       ;  PROCEDURE PUSHCONST(VALUE);
                                ;  BEGIN
PUSHCO: MOV     (Q)+,-(S)       ;  S:-2; ST(S):=ST(Q); Q:+2;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  PUSHLOCAL       ;  PROCEDURE PUSHLOCAL(DISPL);
                                ;  BEGIN
PUSHLO: MOV     B,W             ;    W:=B;
        ADD     (Q)+,W          ;    W:+ST(Q); Q:+2;
        MOV     (W),-(S)        ;    S:-2; ST(S):=ST(W);
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  PUSHGLOBAL      ;  PROCEDURE PUSHGLOBAL(DISPL);
                                ;  BEGIN
PUSHGL: MOV     G,W             ;    W:=G;
        ADD     (Q)+,W          ;    W:+ST(Q); Q:+2;
        MOV     (W),-(S)        ;    S:-2; ST(S):=ST(W);
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  PUSHIND         ;  PROCEDURE PUSHIND;
                                ;  BEGIN
PUSHIN: MOV     @(S),(S)        ;    ST(S):=ST(ST(S));
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  PUSHBYTE        ;  PROCEDURE PUSHBYTE;
                                ;  BEGIN
PUSHBY: MOVB    @(S),W          ;    W:=<BYTE>ST(ST(S));
        MOV     W,(S)           ;    ST(S):=W;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  PUSHREAL        ;  PROCEDURE PUSHREAL;
                                ;  BEGIN
PUSHRE: MOV     (S)+,W          ;    W:=ST(S); S:+2;
        ADD     #8.,W           ;    W:+8;
        MOV     -(W),-(S)       ;    W:-2; S:-2; ST(S):=ST(W);
        MOV     -(W),-(S)       ;    W:-2; S:-2; ST(S):=ST(W);
        MOV     -(W),-(S)       ;    W:-2; S:-2; ST(S):=ST(W);
        MOV     -(W),-(S)       ;    W:-2; S:-2; ST(S):=ST(W);
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  PUSHSET         ;  PROCEDURE PUSHSET;
                                ;  BEGIN
PUSHSE: MOV     (S)+,W          ;    W:=ST(S); S:+2;
        ADD     #16.,W          ;    W:+16;
        MOV     -(W),-(S)       ;    W:-2; S:-2; ST(S):=ST(W);
        MOV     -(W),-(S)       ;    W:-2; S:-2; ST(S):=ST(W);
        MOV     -(W),-(S)       ;    W:-2; S:-2; ST(S):=ST(W);
        MOV     -(W),-(S)       ;    W:-2; S:-2; ST(S):=ST(W);
        MOV     -(W),-(S)       ;    W:-2; S:-2; ST(S):=ST(W);
        MOV     -(W),-(S)       ;    W:-2; S:-2; ST(S):=ST(W);
        MOV     -(W),-(S)       ;    W:-2; S:-2; ST(S):=ST(W);
        MOV     -(W),-(S)       ;    W:-2; S:-2; ST(S):=ST(W);
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  FIELD           ;  PROCEDURE FIELD(DISPL);
                                ;  BEGIN
FIELD:  ADD     (Q)+,(S)        ;    ST(S):+ST(Q); Q:+2;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  INDEX           ;  PROCEDURE INDEX(MIN,MAX-MIN,LENGTH);
                                ;  BEGIN
INDEX:  MOV     (S)+,X          ;    X:=ST(S); S:+2;
        SUB     (Q)+,X          ;    X:-ST(Q); Q:+2;
        BGE     1$              ;    IF LESS THEN
        JMP     RANGER          ;      GOTO RANGEERROR;
1$:     CMP     X,(Q)+          ;    X COMPARE ST(Q); Q:+2;
        BLE     2$              ;    IF GREATER THEN
        JMP     RANGER          ;      GOTO RANGEERROR
2$:     MUL     (Q)+,X          ;    X:*ST(Q); Q:+2;
        ADD     X,(S)           ;    ST(S):+X;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  POINTER         ;  PROCEDURE POINTER;
                                ;  BEGIN
POINTE: TST     (S)             ;    TEST ST(S);
        BNE     1$              ;    IF ZERO THEN
        JMP     POINER          ;      GOTO POINTERERROR;
1$:     NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  VARIANT         ;  PROCEDURE VARIANT(DISPL,TAGSET)
                                ;  BEGIN
VARIAN: MOV     #1,W            ;    W:=1;
        MOV     (S),X           ;    X:=ST(S);              "X=RECORD ADDR"
        ADD     (Q)+,X          ;    X:+ST(Q); Q:+2;        "X=TAG ADDR"
        ASH     (X),W           ;    W:SHIFT ST(X);        "W=1 SHIFT TAGVALUE"
        BIT     W,(Q)+          ;    ST(Q) TESTBIT W; Q:+2;
        BNE     1$              ;    IF BITZERO THEN
        JMP     VARIER          ;      GOTO VARIANTERROR;
1$:     NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  RANGE           ;  PROCEDURE RANGE(MIN,MAX);
                                ;  BEGIN
RANGE:  CMP     (S),(Q)+        ;    ST(S) COMPARE ST(Q); Q:+2;
        BGE     1$              ;    IF LESS THEN
        JMP     RANGER          ;      GOTO RANGEERROR;
1$:     CMP     (S),(Q)+        ;    ST(S) COMPARE ST(Q); Q:+2;
        BLE     2$              ;    IF GREATER THEN
        JMP     RANGER          ;      GOTO RANGEERROR;
2$:     NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  COPYBYTE        ;  PROCEDURE COPYBYTE;
                                ;  BEGIN
COPYBY: MOVB    (S)+,@(S)+      ;    ST(ST(S+2)):=<BYTE>ST(S); S:+4;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  COPYWORD        ;  PROCEDURE COPYWORD;
                                ;  BEGIN
COPYWO: MOV     (S)+,@(S)+      ;    ST(ST(S+2)):=ST(S); S:+4;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  COPYREAL        ;  PROCEDURE COPYREAL;
                                ;  BEGIN
COPYRE: MOV     8.(S),W         ;    W:=ST(S+8);
        MOV     (S)+,(W)+       ;    ST(W):=ST(S); W:+2; S:+2;
        MOV     (S)+,(W)+       ;    ST(W):=ST(S); W:+2; S:+2;
        MOV     (S)+,(W)+       ;    ST(W):=ST(S); W:+2; S:+2;
        MOV     (S)+,(W)+       ;    ST(W):=ST(S); W:+2; S:+2;
        TST     (S)+            ;    TEST ST(S); S:+2;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  COPYSET         ;  PROCEDURE COPYSET;
                                ;  BEGIN
COPYSE: MOV     16.(S),W        ;    W:=ST(S+16);
        MOV     (S)+,(W)+       ;    ST(W):=ST(S); W:+2; S:+2;
        MOV     (S)+,(W)+       ;    ST(W):=ST(S); W:+2; S:+2;
        MOV     (S)+,(W)+       ;    ST(W):=ST(S); W:+2; S:+2;
        MOV     (S)+,(W)+       ;    ST(W):=ST(S); W:+2; S:+2;
        MOV     (S)+,(W)+       ;    ST(W):=ST(S); W:+2; S:+2;
        MOV     (S)+,(W)+       ;    ST(W):=ST(S); W:+2; S:+2;
        MOV     (S)+,(W)+       ;    ST(W):=ST(S); W:+2; S:+2;
        MOV     (S)+,(W)+       ;    ST(W):=ST(S); W:+2; S:+2;
        TST     (S)+            ;    TEST ST(S); S:+2;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  COPYTAG         ;  PROCEDURE COPYTAG(LENGTH DIV 2);
                                ;  BEGIN                        "LENGTH>0"
COPYTA: MOV     (S)+,@(S)       ;    ST(ST(S+2)):=ST(S); S:+2;
        MOV     (Q)+,W          ;    W:=ST(Q); Q:+2;            "W=LENGTH DIV 2"
        MOV     (S)+,X          ;    X:=ST(S); S:+2;             "X=TAG ADDR"
        TST     (X)+            ;    TEST ST(X); X:+2;
1$:     CLR     (X)+            ;    ITERATE W TIMES
                                ;    BEGIN
        SOB     W,1$            ;      CLEAR ST(X); X:+2;
                                ;    END;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  COPYSTRUC       ;  PROCEDURE COPYSTRUC(LENGTH DIV 2);
                                ;  BEGIN
COPYST: MOV     (Q)+,W          ;    W:=ST(Q); Q:+2;            "W=LENGTH DIV 2"
        MOV     (S)+,X          ;    X:=ST(S); S:+2;            "X=SOURCE ADDR"
        MOV     (S)+,Y          ;    Y:=ST(S); S:+2;            "Y=DEST ADDR"
1$:     MOV     (X)+,(Y)+       ;    ITERATE W TIMES
                                ;    BEGIN
        SOB     W,1$            ;      ST(Y):=ST(X); Y:+2; X:+2;
                                ;    END;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  NEW             ;  PROCEDURE NEW(STACKLENGTH+LENGTH,LENGTH);
                                ;  BEGIN
NEW:    MOV     B,X             ;    X:=B;
        SUB     HEAPTO,X        ;    X:-ST(HEAPTOP);
        CMP     X,(Q)+          ;    X COMPARE ST(Q); Q:+2;
        BHIS    1$              ;    IF LESS<UNSIGNED> THEN
        JMP     HEAPLI          ;      GOTO HEAPLIMIT;
1$:     MOV     HEAPTO,@(S)+    ;    ST(ST(S)):=ST(HEAPTOP); S:+2;
        ADD     (Q)+,HEAPTO     ;    ST(HEAPTOP):+ST(Q); Q:+2;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  NEWINIT         ;  PROCEDURE NEWINIT(STACKLENGTH+LENGTH,LENGTH);
                                ;  BEGIN                        "LENGTH>0"
NEWINI: MOV     B,X             ;    X:=B
        SUB     HEAPTO,X        ;    X:-ST(HEAPTOP);
        CMP     X,(Q)+          ;    X COMPARE ST(Q); Q:+2;
        BHIS    1$              ;    IF LESS<UNSIGNED> THEN
        JMP     HEAPLI          ;      GOTO HEAPLIMIT;
1$:     MOV     HEAPTO,@(S)+    ;    ST(ST(S)):=ST(HEAPTOP); S:+2;
        MOV     (Q)+,W          ;    W:=ST(Q); Q:+2;
        ADD     W,HEAPTO        ;    ST(HEAPTOP):+W;
        ASR     W               ;    HALVE W
        MOV     HEAPTO,X        ;    X:=ST(HEAPTOP);
2$:     CLR     -(X)            ;    ITERATE W TIMES
                                ;    BEGIN
        SOB     W,2$            ;      X:-2; CLEAR ST(X);
                                ;    END;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  NOT             ;  PROCEDURE NOT;
                                ;  BEGIN
NOT:    NEG     (S)             ;    ST(S):=-ST(S);
        INC     (S)             ;    INCREMENT ST(S);
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  ANDWORD         ;  PROCEDURE ANDWORD;
                                ;  BEGIN
ANDWOR: MOV     (S)+,W          ;    W:=ST(S); S:+2;
        COM     W               ;    W:=NOT W;
        BIC     W,(S)           ;    ST(S):ANDNOT W;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  ANDSET          ;  PROCEDURE ANDSET;
                                ;  BEGIN
ANDSET: MOV     #8.,W           ;    W:=8;
                                ;    ITERATE W TIMES
                                ;      BEGIN
1$:     COM     (S)             ;        ST(S):=NOT ST(S);
        BIC     (S)+,14.(S)     ;        ST(S+16):ANDNOT ST(S); S:+2;
        SOB     W,1$            ;      END;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  ORWORD          ;  PROCEDURE ORWORD;
                                ;  BEGIN
ORWORD: BIS     (S)+,(S)        ;    ST(S+2):OR ST(S); S:+2;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  ORSET           ;  PROCEDURE ORSET;
                                ;  BEGIN
ORSET:  MOV     #8.,W           ;    W:=8;
1$:     BIS     (S)+,14.(S)     ;    ITERATE W TIMES
                                ;    BEGIN
        SOB     W,1$            ;      ST(S+16):OR ST(S); S:+2;
                                ;    END;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  NEGWORD         ;  PROCEDURE NEGWORD;
                                ;  BEGIN
NEGWOR: NEG     (S)             ;    ST(S):=-ST(S)
        BVC     1$              ;    IF OVERFLOW THEN
        JMP     OVERFL          ;      GOTO OVERFLOWERROR;
1$:     NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  NEGREAL         ;  PROCEDURE NEGREAL;
                                ;  BEGIN
NEGREA: ADD	#100000,(SP)    ;    ST(S):=<REAL>-ST(S);		;<01>
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  ADDWORD         ;  PROCEDURE ADDWORD;
                                ;  BEGIN
ADDWOR: ADD     (S)+,(S)        ;    ST(S+2):+ST(S); S:+2;
        BVC     1$              ;    IF OVERFLOW THEN
        JMP     OVERFL          ;      GOTO OVERFLOWERROR;
1$:     NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  ADDREAL         ;  PROCEDURE ADDREAL;
                                ;  BEGIN
ADDREA:
	.IF	DF,F$PU		;<01>	IF FPU, USE IT
	LDD     (S)+,W          ;    W:=<REAL>ST(S); S:+8;
        ADDD    (S),W           ;    W:+<REAL>ST(S);
        STD     W,(S)           ;    ST(S):=<REAL>W;
	.IFF			;<01>	IF NOT, USE SOFTWARE ROUTINES
	JSR	PC,$ADD		;<01>
	.ENDC			;<01>	F$PU
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  SUBWORD         ;  PROCEDURE SUBWORD;
                                ;  BEGIN
SUBWOR: SUB     (S)+,(S)        ;    ST(S+2):-ST(S);  S:+2;
        BVC     1$              ;    IF OVERFLOW THEN
        JMP     OVERFL          ;      GOTO OVERFLOWERROR;
1$:     NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  SUBREAL         ;  PROCEDURE SUBREAL;
                                ;  BEGIN
SUBREA:
	.IF	DF,F$PU		;<01>	GOT FPU?
	LDD     (S)+,W          ;    W:=<REAL>ST(S); S:+8;
        LDD     (S),X           ;    X:=<REAL>ST(S);
        SUBD    W,X             ;    X:-<REAL>W;
        STD     X,(S)           ;    ST(S):=<REAL>X;
	.IFF			;<01>	IF NOT, USE SOFTWARE
	JSR	PC,$SBD		;<01>
	.ENDC			;<01>	F$PU
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  SUBSET          ;  PROCEDURE SUBSET;
                                ;  BEGIN
SUBSET: MOV     #8.,W           ;    W:=8;
1$:     BIC     (S)+,14.(S)     ;    ITERATE W TIMES
                                ;    BEGIN
        SOB     W,1$            ;      ST(S+16):ANDNOT ST(S); S:+2;
                                ;    END;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  MULWORD         ;  PROCEDURE MULWORD;
                                ;  BEGIN
MULWOR: MOV     (S)+,X          ;    X:=ST(S); S:+2;
        CLC                     ;    CARRY:=FALSE;
        MUL     (S),X           ;    X:*ST(S);
        BCC     1$              ;    IF CARRY THEN
        JMP     OVERFL          ;      GOTO OVERFLOWERROR;
1$:     MOV     X,(S)           ;    ST(S):=X;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  MULREAL         ;  PROCEDURE MULREAL;
                                ;  BEGIN
MULREA:	.IF	DF,F$PU		;<01>	FPU PRESENT?
	LDD     (S)+,W          ;    W:=<REAL>ST(S); S:+8;
        MULD    (S),W           ;    W:*<REAL>ST(S);
        STD     W,(S)           ;    ST(S):=<REAL>W;
	.IFF			;<01>	IF NOT, USE SOFTWARE
	JSR	PC,$MLD		;<01>
	.ENDC			;<01>	F$PU
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  DIVWORD         ;  PROCEDURE DIVWORD;
                                ;  BEGIN
DIVWOR: MOV     2(S),X          ;    X:=ST(S+2);
        SXT     W               ;    EXTENDSIGN W;
        DIV     (S)+,W          ;    WX:/ST(S); S:+2;
        BVC     1$              ;    IF OVERFLOW THEN
        JMP     OVERFL          ;      GOTO OVERFLOWERROR;
1$:     MOV     W,(S)           ;    ST(S):=W;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  DIVREAL         ;  PROCEDURE DIVREAL;
                                ;  BEGIN
DIVREA:	.IF	DF,F$PU		;<01>	FPU PRESENT?
	LDD     8.(S),W         ;    W:=<REAL>ST(S+8);
        DIVD    (S)+,W          ;    W:/<REAL>ST(S); S:+8;
        STD     W,(S)           ;    ST(S):=<REAL>W;
	.IFF			;<01>	NO, USE SOFTWARE
	JSR	PC,$DVD		;<01>	CALL DP DIVIDE ROUTINE
	.ENDC			;<01>	F$PU
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  MODWORD         ;  PROCEDURE MODWORD;
                                ;  BEGIN
MODWOR: MOV     2(S),X          ;    X:=ST(S+2);
        SXT     W               ;    EXTENDSIGN W;
        DIV     (S)+,W          ;    WX:/ST(S); S:+2;
        BVC     1$              ;    IF OVERFLOW THEN
        JMP     OVERFL          ;      GOTO OVERFLOWERROR;
1$:     MOV     X,(S)           ;    ST(S):=X;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  BUILDSET        ;  PROCEDURE BUILDSET;
                                ;  BEGIN
BUILDS: MOV     (S)+,W          ;    W:=ST(S); S:+2;
        BLT     1$              ;    IF W<0 THEN GOTO RANGEERROR;
        CMP     W,#127.         ;    W COMPARE 127;
        BLE     2$              ;    IF GREATER THEN
1$:     JMP     RANGER          ;      GOTO RANGEERROR;
2$:     MOV     W,X             ;    X:=W;                      "X=MEMBER"
        BIC     #177770,W       ;    W:MOD 8;                   "W=MEMBER MOD 8"
        ASH     #-3.,X          ;    X:DIV 8;
        ADD     S,X             ;    X:+S;                      "X=SET BYTE ADR"
        MOV     #1,Y            ;    Y:=1;
        ASH     W,Y             ;    Y:SHIFT W;                 "Y=SET BYTE BIT"
        BISB    Y,(X)           ;    ST(X):OR<BYTE> Y;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  INSET           ;  PROCEDURE INSET;
                                ;  BEGIN
INSET:  MOV     16.(S),W        ;    W:=ST(S+16);
        BLT     1$              ;    IF W<0 THEN GOTO RANGEERROR;
        CMP     W,#127.         ;    W COMPARE 127;
        BLE     2$              ;    IF GREATER THEN
1$:     JMP     RANGER          ;      GOTO RANGEERROR;
2$:     MOV     W,X             ;    X:=W;                      "X=MEMBER"
        BIC     #177770,W       ;    W:MOD 8;                   "W=MEMBER MOD 8"
        ASH     #-3.,X          ;    X:DIV 8;
        ADD     S,X             ;    X:+S;                      "X=SET BYTE ADR"
        MOVB    (X),Y           ;    Y:=<BYTE> ST(X);           "Y=SET BYTE"
        NEG     W               ;    W:=-W;
        ASH     W,Y             ;    Y:SHIFT W;
        BIC     #177776,Y       ;    Y:MOD 2;                   "Y=SET BIT"
        ADD     #16.,S          ;    S:+16;
        MOV     Y,(S)           ;    ST(S):=Y;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  LSWORD          ;  PROCEDURE LSWORD;
                                ;  BEGIN
LSWORD: CLR     W               ;    CLEAR W;
        CMP     (S)+,(S)        ;    ST(S) COMPARE ST(S+2);  S:+2;
        BLE     1$              ;    IF GREATER THEN
        INC     W               ;      INCREMENT W;
1$:     MOV     W,(S)           ;    ST(S):=W;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  EQWORD          ;  PROCEDURE EQWORD;
                                ;  BEGIN
EQWORD: CLR     W               ;    CLEAR W;
        CMP     (S)+,(S)        ;    ST(S) COMPARE ST(S+2); S:+2;
        BNE     1$              ;    IF EQUAL THEN
        INC     W               ;      INCREMENT W;
1$:     MOV     W,(S)           ;    ST(S):=W;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  GRWORD          ;  PROCEDURE GRWORD;
                                ;  BEGIN
GRWORD: CLR     W               ;    CLEAR W;
        CMP     (S)+,(S)        ;    ST(S) COMPARE ST(S+2); S:+2;
        BGE     1$              ;    IF LESS THEN
        INC     W               ;      INCREMENT W;
1$:     MOV     W,(S)           ;    ST(S):=W;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  NLWORD          ;  PROCEDURE NLWORD;
                                ;  BEGIN
NLWORD: CLR     W               ;    CLEAR W;
        CMP     (S)+,(S)        ;    ST(S) COMPARE ST(S+2); S:+2;
        BGT     1$              ;    IF NOTGREATER THEN
        INC     W               ;      INCREMENT W;
1$:     MOV     W,(S)           ;    ST(S):=W;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  NEWORD          ;  PROCEDURE NEWORD;
                                ;  BEGIN
NEWORD: CLR     W               ;    CLEAR W;
        CMP     (S)+,(S)        ;    ST(S) COMPARE ST(S+2); S:+2;
        BEQ     1$              ;    IF NOTEQUAL THEN
        INC     W               ;      INCREMENT W;
1$:     MOV     W,(S)           ;    ST(S):=W;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  NGWORD          ;  PROCEDURE NGWORD;
                                ;  BEGIN
NGWORD: CLR     W               ;    CLEAR W;
        CMP     (S)+,(S)        ;    ST(S) COMPARE ST(S+2); S:+2;
        BLT     1$              ;    IF NOTLESS THEN
        INC     W               ;      INCREMENT W;
1$:     MOV     W,(S)           ;    ST(S):=W;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  LSREAL          ;  PROCEDURE LSREAL;
                                ;  BEGIN
LSREAL: CLR     W               ;    CLEAR W;
	.IF	DF,F$PU		;<01>	FPU PRESENT?
        LDD     (S)+,X          ;    X:=<REAL>ST(S); S:+8;
        CMPD    (S)+,X          ;    ST(S) COMPARE X; S:+8;
        CFCC                    ;    COPYCONDITIONS;
	.IFF			;<01>	IF NOT, USE SOFTWARE
	JSR	PC,$DCMP	;<01>	CALL FLT COMPARE ROUTINE
	.ENDC			;<01>	F$PU
        BGE     1$              ;    IF LESS THEN
        INC     W               ;      INCREMENT W;
1$:     MOV     W,-(S)          ;    S:-2; ST(S):=W;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  EQREAL          ;  PROCEDURE EQREAL;
                                ;  BEGIN
EQREAL: CLR     W               ;    CLEAR W;
	.IF	DF,F$PU		;<01>
        LDD     (S)+,X          ;    X:=<REAL>ST(S); S:+8;
        CMPD    (S)+,X          ;    ST(S) COMPARE X; S:+8;
        CFCC                    ;    COPYCONDITIONS;
	.IFF			;<01>
	JSR	PC,$DCMP	;<01>
	.ENDC			;<01>	F$PU
        BNE     1$              ;    IF EQUAL THEN
        INC     W               ;      INCREMENT W;
1$:     MOV     W,-(S)          ;    S:-2; ST(S):=W;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  GRREAL          ;  PROCEDURE GRREAL
                                ;  BEGIN
GRREAL: CLR     W               ;    CLEAR W;
	.IF	DF,F$PU		;<01>
        LDD     (S)+,X          ;    X:=<REAL>ST(S); S:+8;
        CMPD    (S)+,X          ;    ST(S) COMPARE X; S:+8;
        CFCC                    ;    COPYCONDITIONS;
	.IFF			;<01>
	JSR	PC,$DCMP	;<01>
	.ENDC			;<01>	F$PU
        BLE     1$              ;    IF GREATER THEN
        INC     W               ;      INCREMENT W;
1$:     MOV     W,-(S)          ;    S:-2; ST(S):=W;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  NLREAL          ;  PROCEDURE NLREAL
                                ;  BEGIN
NLREAL: CLR     W               ;    CLEAR W;
	.IF	DF,F$PU		;<01>
        LDD     (S)+,X          ;    X:=<REAL>ST(S); S:+8;
        CMPD    (S)+,X          ;    ST(S) COMPARE X; S:+8;
        CFCC                    ;    COPYCONDITIONS;
	.IFF			;<01>
	JSR	PC,$DCMP	;<01>
	.ENDC			;<01>	F$PU
        BLT     1$              ;    IF NOTLESS THEN
        INC     W               ;      INCREMENT W;
1$:     MOV     W,-(S)          ;    S:-2; ST(S):=W;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  NEREAL          ;  PROCEDURE NEREAL;
                                ;  BEGIN
NEREAL: CLR     W               ;    CLEAR W;
	.IF	DF,F$PU		;<01>
        LDD     (S)+,X          ;    X:=<REAL>ST(S); S:+8;
        CMPD    (S)+,X          ;    ST(S) COMPARE X; S:+8;
        CFCC                    ;    COPYCONDITIONS;
	.IFF			;<01>
	JSR	PC,$DCMP	;<01>
	.ENDC			;<01>
        BEQ     1$              ;    IF NOTEQUAL THEN
        INC     W               ;      INCREMENT W;
1$:     MOV     W,-(S)          ;    S:-2; ST(S):=W;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  NGREAL          ;  PROCEDURE NGREAL
                                ;  BEGIN
NGREAL: CLR     W               ;    CLEAR W;
	.IF	DF,F$PU		;<01>
        LDD     (S)+,X          ;    X:=<REAL>ST(S); S:+8;
        CMPD    (S)+,X          ;    ST(S) COMPARE X; S:+8;
        CFCC                    ;    COPYCONDITIONS;
	.IFF			;<01>
	JSR	PC,$DCMP	;<01>
	.ENDC			;<01>	F$PU
        BGT     1$              ;    IF NOTGREATER THEN
        INC     W               ;      INCREMENT W;
1$:     MOV     W,-(S)          ;    S:-2; ST(S):=W;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  EQSET           ;  PROCEDURE EQSET;
                                ;  BEGIN
EQSET:  CLR     W               ;    CLEAR W;
        MOV     S,X             ;    X:=S;
        MOV     #8.,Y           ;    Y:=8;
                                ;    REPEAT
1$:     CMP     16.(X),(X)+     ;      ST(X+16) COMPARE ST(X); X:+2;
        BNE     2$              ;      Y:-1;
        SOB     Y,1$            ;    UNTIL (Y=0) OR NOTEQUAL;
        INC     W               ;    IF EQUAL THEN INCREMENT W;
2$:     ADD     #30.,S          ;    S:+30;
        MOV     W,(S)           ;    ST(S):=W;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  NLSET           ;  PROCEDURE NLSET;
                                ;  BEGIN
NLSET:  CLR     W               ;    CLEAR W;
        MOV     S,X             ;    X:=S;
        MOV     #8.,Y           ;    Y:=8;
                                ;    REPEAT
1$:     BIC     16.(X),(X)+     ;      ST(X):ANDNOT ST(X+16); X:+2;
        BNE     2$              ;      Y:-1;
        SOB     Y,1$            ;    UNTIL (Y=0) OR NOTZERO;
        INC     W               ;    IF ZERO THEN INCREMENT W;
2$:     ADD     #30.,S          ;    S:+30;
        MOV     W,(S)           ;    ST(S):=W;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  NESET           ;  PROCEDURE NESET;
                                ;  BEGIN
NESET:  MOV     #1,W            ;    W:=1;
        MOV     S,X             ;    X:=S;
        MOV     #8.,Y           ;    Y:=8;
                                ;    REPEAT
1$:     CMP     16.(X),(X)+     ;      ST(X+16) COMPARE ST(X); X:+2;
        BNE     2$              ;      Y:-1;
        SOB     Y,1$            ;    UNTIL (Y=0) OR NOTEQUAL;
        CLR     W               ;    IF EQUAL THEN CLEAR W;
2$:     ADD     #30.,S          ;    S:+30;
        MOV     W,(S)           ;    ST(S):=W;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  NGSET           ;  PROCEDURE NGSET;
                                ;  BEGIN
NGSET:  CLR     W               ;    CLEAR W;
        MOV     S,X             ;    X:=S;
        MOV     #8.,Y           ;    Y:=8;
                                ;    REPEAT
1$:     BIC     (X)+,14.(X)     ;      ST(X+16):ANDNOT ST(X); X:+2;
        BNE     2$              ;      Y:-1;
        SOB     Y,1$            ;    UNTIL (Y=0) OR NOTZERO;
        INC     W               ;    IF ZERO THEN INCREMENT W;
2$:     ADD     #30.,S          ;    S:+30;
        MOV     W,(S)           ;    ST(S):=W;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  LSSTRUCT        ;  PROCEDURE LSSTRUCT(LENGTH DIV 2);
                                ;  BEGIN
LSSTRU: MOV     (Q)+,W          ;    W:=ST(Q); Q:+2;
        ASL     W               ;    DOUBLE W;                  "W=LENGTH"
        MOV     (S)+,X          ;    X:=ST(S); S:+2;            "X=SOURCE ADDR"
        MOV     (S),Y           ;    Y:=ST(S);                  "Y=DEST ADDR"
        CLR     (S)             ;    CLEAR ST(S);
                                ;    REPEAT
1$:     CMPB    (Y)+,(X)+       ;      ST(Y) COMPARE<BYTE> ST(X); Y:+1; X:+1;
        BNE     2$              ;      W:-1;
        SOB     W,1$            ;    UNTIL (W=0) OR NOTEQUAL;
2$:     BGE     3$              ;    IF LESS THEN
        INC     (S)             ;      INCREMENT ST(S);
3$:     NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  EQSTRUCT        ;  PROCEDURE EQSTRUCT(LENGTH DIV 2);
                                ;  BEGIN
EQSTRU: MOV     (Q)+,W          ;    W:=ST(Q); Q:+2;            "W=LENGTH DIV 2"
        MOV     (S)+,X          ;    X:=ST(S); S:+2;            "X=SOURCE ADDR"
        MOV     (S),Y           ;    Y:=ST(S);                  "Y=DEST ADDR"
        CLR     (S)             ;    CLEAR ST(S);
                                ;    REPEAT
1$:     CMP     (Y)+,(X)+       ;      ST(Y) COMPARE ST(X); Y:+2; X:+2;
        BNE     2$              ;      W:-1;
        SOB     W,1$            ;    UNTIL (W=0) OR NOTEQUAL;
        INC     (S)             ;    IF EQUAL THEN INCREMENT ST(S);
2$:     NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  GRSTRUCT        ;  PROCEDURE GRSTRUCT(LENGTH DIV 2);
                                ;  BEGIN
GRSTRU: MOV     (Q)+,W          ;    W:=ST(Q); Q:+2;
        ASL     W               ;    DOUBLE W;                  "W=LENGTH"
        MOV     (S)+,X          ;    X:=ST(S); S:+2;            "X=SOURCE ADDR"
        MOV     (S),Y           ;    Y:=ST(S);                  "Y=DEST ADDR"
        CLR     (S)             ;    CLEAR ST(S);
                                ;    REPEAT
1$:     CMPB    (Y)+,(X)+       ;      ST(Y) COMPARE<BYTE> ST(X); Y:+1; X:+1;
        BNE     2$              ;      W:-1;
        SOB     W,1$            ;    UNTIL (W=0) OR NOTEQUAL;
2$:     BLE     3$              ;    IF GREATER THEN
        INC     (S)             ;      INCREMENT ST(S);
3$:     NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  NLSTRUCT        ;  PROCEDURE NLSTRUCT(LENGTH DIV 2);
                                ;  BEGIN
NLSTRU: MOV     (Q)+,W          ;    W:=ST(Q); Q:+2;
        ASL     W               ;    DOUBLE W;                  "W=LENGTH"
        MOV     (S)+,X          ;    X:=ST(S); S:+2;            "X=SOURCE ADDR"
        MOV     (S),Y           ;    Y:=ST(S);                  "Y=DEST ADDR"
        CLR     (S)             ;    CLEAR ST(S);
                                ;    REPEAT
1$:     CMPB    (Y)+,(X)+       ;      ST(Y) COMPARE<BYTE> ST(X); Y:+1; X:+1;
        BNE     2$              ;      W:-1;
        SOB     W,1$            ;    UNTIL (W=0) OR NOTEQUAL;
2$:     BLT     3$              ;    IF NOTLESS THEN
        INC     (S)             ;      INCREMENT ST(S);
3$:     NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  NESTRUCT        ;  PROCEDURE NESTRUCT(LENGTH DIV 2);
                                ;  BEGIN
NESTRU: MOV     (Q)+,W          ;    W:=ST(Q); Q:+2;            "W=LENGTH DIV 2"
        MOV     (S)+,X          ;    X:=ST(S); S:+2;             "X=SOURCE ADDR"
        MOV     (S),Y           ;    Y:=ST(S);                  "Y=DEST ADDR"
        MOV     #1,(S)          ;    ST(S):=1;
                                ;    REPEAT
1$:     CMP     (Y)+,(X)+       ;      ST(Y) COMPARE ST(X); Y:+2; X:+2;
        BNE     2$              ;      W:-1;
        SOB     W,1$            ;    UNTIL (W=0) OR NOTEQUAL;
        CLR     (S)             ;    IF EQUAL THEN CLEAR ST(S);
2$:     NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  NGSTRUCT        ;  PROCEDURE NGSTRUCT(LENGTH DIV 2);
                                ;  BEGIN
NGSTRU: MOV     (Q)+,W          ;    W:=ST(Q); Q:+2;
        ASL     W               ;    DOUBLE W;                  "W=LENGTH"
        MOV     (S)+,X          ;    X:=ST(S); S:+2;            "X=SOURCE ADDR"
        MOV     (S),Y           ;    Y:=ST(S);                  "Y=DEST ADDR"
        CLR     (S)             ;    CLEAR ST(S);
                                ;    REPEAT
1$:     CMPB    (Y)+,(X)+       ;      ST(Y) COMPARE<BYTE> ST(X); Y:+1; X:+1;
        BNE     2$              ;      W:-1;
        SOB     W,1$            ;    UNTIL (W=0) OR NOTEQUAL;
2$:     BGT     3$              ;    IF NOT GREATER THEN
        INC     (S)             ;      INCREMENT ST(S);
3$:     NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  FUNCVALUE       ;  PROCEDURE FUNCVALUE(KIND);
                                ;  BEGIN
FUNCVA: ADD     (Q)+,P          ;    CASE KIND OF
                                ;      SIMPLEWORD:              "0"
                                ;        BEGIN
        CLR     -(S)            ;          S:-2; CLEAR ST(S);
        BR      1$              ;        END;
        .WORD   0,0             ;        "FILLER"
                                ;      SIMPLEREAL:              "8"
                                ;        BEGIN
        SUB     #8.,S           ;          S:-8;
        BR      1$              ;        END;
        .WORD   0               ;        "FILLER"
                                ;      CLASSWORD:               "16"
                                ;        BEGIN
        MOV     (S),W           ;          W:=ST(S);
        CLR     (S)             ;          CLEAR ST(S);
        MOV     W,-(S)          ;          S:-2; ST(S):=W;
        BR      1$              ;        END;
                                ;      CLASSREAL:               "24"
                                ;        BEGIN
        MOV     (S),W           ;          W:=ST(S);
        SUB     #8.,S           ;          S:-8;
        MOV     W,(S)           ;          ST(S):=W;
1$:     NEXT                    ;        END;
                                ;      END;
                                ;  END;
                                ;
                                ;
        .SBTTL  JUMP            ;  PROCEDURE JUMP(DISTANCE);
                                ;  BEGIN
JUMP:   ADD     (Q),Q           ;    Q:+ST(Q);
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  FALSEJUMP       ;  PROCEDURE FALSEJUMP(DISTANCE);
                                ;  BEGIN
FALSEJ: ADD     CONT,P          ;    IF (ST(CONTINUE) = 0)
        TST     JOB             ;     AND
        BEQ     1$              ;      (ST(JOB) <> 0)
        JMP     EXCEPT          ;    THEN GOTO EXCEPTION
                                ;    ELSE
                                ;    BEGIN
1$:     TST     (S)+            ;    TEST ST(S); S:+2;          "CONTINUE=10"
        BNE     2$              ;    IF ZERO
        ADD     (Q),Q           ;      THEN Q:+ST(Q)
        NEXT                    ;
2$:     TST     (Q)+            ;      ELSE Q:+2;
                                ;    END
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  CASEJUMP        ;  PROCEDURE CASEJUMP(MIN,MAX-MIN,DISTANCES);
                                ;  BEGIN
CASEJU: MOV     (S)+,W          ;    W:=ST(S); S:+2;
        SUB     (Q)+,W          ;    W:-ST(Q); Q:+2;
        BLT     1$              ;    IF LESS THEN GOTO RANGEERROR;
        CMP     W,(Q)+          ;    W COMPARE ST(Q); Q:+2;
        BLE     2$              ;    IF GREATER THEN
1$:     JMP     RANGER          ;      GOTO RANGEERROR;
2$:     ASL     W               ;    DOUBLE W;
        ADD     W,Q             ;    Q:+W;
        ADD     (Q),Q           ;    Q:+ST(Q);
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  INITVAR         ;  PROCEDURE INITVAR(LENGTH DIV 2);
                                ;  BEGIN
INITVA: MOV     (Q)+,W          ;    W:=ST(Q); Q:+2;
        MOV     S,X             ;    X:=S;
1$:     CLR     (X)+            ;    ITERATE W TIMES
                                ;    BEGIN
        SOB     W,1$            ;      CLEAR ST(X); X:+2;
                                ;    END;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  CALL            ;  PROCEDURE CALL(DISTANCE);
                                ;  BEGIN
CALL:   MOV     Q,W             ;    W:=Q;
        ADD     (Q)+,W          ;    W:+ST(Q); Q:+2;
        MOV     Q,-(S)          ;    S:-2; ST(S):=Q;
        MOV     W,Q             ;    Q:=W;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  CALLSYS         ;  PROCEDURE CALLSYS((ENTRY-2)*2);
                                ;  BEGIN
CALLSY: MOV     2(G),W          ;    W:=ST(G+2);     "OLD S BEFORE PROGRAM CALL"
        ADD     (Q)+,W          ;    W:+ST(Q); Q:+2; "W = ENTRY POINT ADDR"
        MOV     Q,-(S)          ;    S:-2; ST(S):=Q;
        MOV     (W),Q           ;    Q:=ST(W);
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  ACTIVATION REC  ;"ACTIVATION RECORD:
                                ;            <HEAP>
                                ;  HEAPTOP:  <FREE SPACE>
                                ;  S:        <TEMPORARIES>
                                ;            <VARIABLES>
                                ;  B (OR G): <LINE>
                                ;    + 2     <OLD S>
                                ;    + 4     <OLD B>
                                ;    + 6     <OLD G>
                                ;    + 8     <OLD Q>
                                ;    + 10    <PARAMETERS>
                                ;           (<FUNCTION RESULT>)
                                ;
                                ; MONITOR VARIABLE:
                                ;            <VARIABLES>
                                ;  G:        <GATE ADDRESS>
                                ;            <PARAMETERS>
                                ;
                                ; STACKLENGTH = VARLENGTH + TEMPLENGTH + 10
                                ; POPLENGTH = PARAMLENGTH + 8"
                                ;
                                ;
        .SBTTL  ENTER           ;  PROCEDURE ENTER(STACKLENGTH,POPLENGTH,LINE,
                                ;                                    VARLENGTH);
                                ;  BEGIN
ENTER:  MOV     S,X             ;    X:=S;
        SUB     HEAPTO,X        ;    X:-ST(HEAPTOP);
        CMP     X,(Q)+          ;    X COMPARE ST(Q); Q:+2;     "ERROR MESSAGE"
        BHIS    1$              ;    IF LESS<UNSIGNED> THEN     "WILL REFER TO"
        JMP     STACKL          ;      GOTO STACKLIMIT;         "LINE OF CALL"
1$:     MOV     G,-(S)          ;    S:-2; ST(S):=G;
        MOV     B,-(S)          ;    S:-2; ST(S):=B;
        TST     -(S)            ;    S:-2;
        MOV     S,(S)           ;          ST(S):=S;
        ADD     (Q)+,(S)        ;    ST(S):+ST(Q); Q:+2;
        MOV     (Q)+,-(S)       ;    S:-2; ST(S):=ST(Q); Q:+2;
        MOV     S,B             ;    B:=S;
        SUB     (Q)+,S          ;    S:-ST(Q); Q:+2;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  EXIT            ;  PROCEDURE EXIT;
                                ;  BEGIN
EXIT:   MOV     B,S             ;    S:=B;
        TST     (S)+            ;    TEST ST(S); S:+2;
        MOV     (S)+,W          ;    W:=ST(S); S:+2;
        MOV     (S)+,B          ;    B:=ST(S); S:+2;
        MOV     (S)+,G          ;    G:=ST(S); S:+2;
        MOV     (S)+,Q          ;    Q:=ST(S); S:+2;
        MOV     W,S             ;    S:=W;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  ENTERPROG       ;  PROCEDURE ENTERPROG(POPLENGTH,LINE,STACKLENGTH,
                                ;                                    VARLENGTH);
                                ;  BEGIN
ENPROG: INC     JOB             ;    INCREMENT ST(JOB);
        MOV     G,-(S)          ;    S:-2; ST(S):=G;
        MOV     B,-(S)          ;    S:-2; ST(S):=B;
        TST     -(S)            ;    S:-2;
        MOV     S,(S)           ;          ST(S):=S;
        ADD     (Q)+,(S)        ;    ST(S):+ST(Q); Q:+2;
        MOV     (Q)+,-(S)       ;    S:-2; ST(S):=ST(Q); Q:+2;
        MOV     S,B             ;    B:=S;
        MOV     B,G             ;    G:=B;
        MOV     S,X             ;    X:=S;
        SUB     HEAPTO,X        ;    X:-ST(HEAPTOP);
        CMP     X,(Q)+          ;    X COMPARE ST(Q); Q:+2;     "ERROR MESSAGE"
        BHIS    1$              ;    IF LESS<UNSIGNED> THEN     "WILL REFER TO"
        JMP     STACKL          ;      GOTO STACKLIMIT;         "LINE 1 OF USER"
1$:     SUB     (Q)+,S          ;    S:-ST(Q); Q:+2;            "PROGRAM"
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  EXITPROG        ;  PROCEDURE EXITPROG;
                                ;  BEGIN
EXPROG: TST     CONT            ;    TEST ST(CONTINUE);
        BNE     1$              ;    IF ZERO
        JMP     EXCEPT          ;      THEN GOTO EXCEPTION
1$:     JMP     TERMIN          ;      ELSE GOTO TERMINATED;
                                ;  END;
                                ;
                                ;
        .SBTTL  BEGINCLASS      ;  PROCEDURE BEGINCLASS(STACKLENGTH,10,LINE,0);
                                ;  BEGIN
BEGINC: MOV     S,X             ;    X:=S;
        SUB     HEAPTO,X        ;    X:-ST(HEAPTOP);
        CMP     X,(Q)+          ;    X COMPARE ST(Q); Q:+2;     "ERROR MESSAGE"
        BHIS    1$              ;    IF LESS<UNSIGNED> THEN     "WILL REFER TO"
        JMP     STACKL          ;      GOTO STACKLIMIT;         "LINE OF CALL"
1$:     MOV     G,-(S)          ;    S:-2; ST(S):=G;
        MOV     B,-(S)          ;    S:-2; ST(S):=B;
        TST     -(S)            ;    S:-2;
        MOV     S,(S)           ;          ST(S):=S;
        ADD     (Q)+,(S)        ;    ST(S):+ST(Q); Q:+2;
        MOV     (Q)+,-(S)       ;    S:-2; ST(S):=ST(Q); Q:+2;
        MOV     S,B             ;    B:=S;
        SUB     (Q)+,S          ;    S:-ST(Q); Q:+2;
        MOV     2(B),W          ;    W:=ST(B+2);
        MOV     -2(W),G         ;    G:=ST(W-2);
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  ENDCLASS        ;  PROCEDURE ENDCLASS;
                                ;  BEGIN
ENDCLA= EXIT                    ;    "SAME AS EXIT"
                                ;  END;
                                ;
                                ;
        .SBTTL  ENTERCLASS      ;  PROCEDURE ENTERCLASS(STACKLENGTH,POPLENGTH,
                                ;                              LINE,VARLENGTH);
                                ;  BEGIN
ENTERC= BEGINC                  ;    "SAME AS BEGINCLASS"
                                ;  END;
                                ;
                                ;
        .SBTTL  EXITCLASS       ;  PROCEDURE EXITCLASS;
                                ;  BEGIN
EXITCL= EXIT                    ;    "SAME AS EXIT"
                                ;  END;
                                ;
                                ;
        .SBTTL  BEGINMON        ;  PROCEDURE BEGINMON(STACKLENGTH,10,LINE,0);
                                ;  BEGIN
BEGINM: MOV     S,X             ;    X:=S;
        SUB     HEAPTO,X        ;    X:-ST(HEAPTOP);
        CMP     X,(Q)+          ;    X COMPARE ST(Q); Q:+2;     "ERROR MESSAGE"
        BHIS    1$              ;    IF LESS<UNSIGNED> THEN     "WILL REFER TO"
        JMP     STACKL          ;      GOTO STACKLIMIT;         "LINE OF CALL"
1$:     MOV     G,-(S)          ;    S:-2; ST(S):=G;
        MOV     B,-(S)          ;    S:-2; ST(S):=B;
        TST     -(S)            ;    S:-2;
        MOV     S,(S)           ;          ST(S):=S;
        ADD     (Q)+,(S)        ;    ST(S):+ST(Q); Q:+2;
        MOV     (Q)+,-(S)       ;    S:-2; ST(S):=ST(Q); Q:+2;
        MOV     S,B             ;    B:=S;
        SUB     (Q)+,S          ;    S:-ST(Q); Q:+2;
        MOV     2(B),W          ;    W:=ST(B+2);
        MOV     -2(W),G         ;    G:=ST(W-2);
        MOV     #INITG1,OPCODE  ;    ST(KERNELOP):=INITGATE1;
        MOV     G,ARG1          ;    ST(KERNELARG1):=G;
        KNCALL                  ;    KERNELCALL;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  ENDMON          ;  PROCEDURE ENDMON;
                                ;  BEGIN
ENDMON: MOV     #LEAVG1,OPCODE  ;    ST(KERNELOP):=LEAVEGATE1;
        MOV     (G),ARG1        ;    ST(KERNELARG1):=ST(G);
        KNCALL                  ;    KERNELCALL;
        MOV     B,S             ;    S:=B;
        TST     (S)+            ;    TEST ST(S); S:+2;
        MOV     (S)+,W          ;    W:=ST(S); S:+2;
        MOV     (S)+,B          ;    B:=ST(S); S:+2;
        MOV     (S)+,G          ;    G:=ST(S); S:+2;
        MOV     (S)+,Q          ;    Q:=ST(S); S:+2;
        MOV     W,S             ;    S:=W;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  ENTERMON        ;  PROCEDURE ENTERMON(STACKLENGTH, POPLENGTH,
                                ;                              LINE, VARLENGTH);
                                ;  BEGIN
ENTERM: MOV     S,X             ;    X:=S;
        SUB     HEAPTO,X        ;    X:-ST(HEAPTOP);
        CMP     X,(Q)+          ;    X COMPARE ST(Q); Q:+2;     "ERROR MESSAGE"
        BHIS    1$              ;    IF LESS<UNSIGNED> THEN     "WILL REFER TO"
        JMP     STACKL          ;      GOTO STACKLIMIT;         "LINE OF CALL"
1$:     MOV     G,-(S)          ;    S:-2; ST(S):=G;
        MOV     B,-(S)          ;    S:-2; ST(S):=B;
        TST     -(S)            ;    S:-2;
        MOV     S,(S)           ;          ST(S):=S;
        ADD     (Q)+,(S)        ;    ST(S):+ST(Q); Q:+2;
        MOV     (Q)+,-(S)       ;    S:-2; ST(S):=ST(Q); Q:+2;
        MOV     S,B             ;    B:=S;
        SUB     (Q)+,S          ;    S:-ST(Q); Q:+2;
        MOV     2(B),W          ;    W:=ST(B+2);
        MOV     -2(W),G         ;    G:=ST(W-2);
        MOV     #ENTEG1,OPCODE  ;    ST(KERNELOP):=ENTERGATE1;
        MOV     (G),ARG1        ;    ST(KERNELARG1):=ST(G);
        KNCALL                  ;    KERNELCALL;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  EXITMON         ;  PROCEDURE EXITMON;
                                ;  BEGIN
EXITMO= ENDMON                  ;    "SAME AS ENDMON"
                                ;  END;
                                ;
                                ;
        .SBTTL  BEGINPROC       ;  PROCEDURE BEGINPROC(LINE);
                                ;  BEGIN
BEGINP: MOV     (Q)+,(B)        ;    ST(B):=ST(Q); Q:+2;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  ENDPROC         ;  PROCEDURE ENDPROC;
                                ;  BEGIN
ENDPRO: MOV     #ENDPR1,OPCODE  ;    ST(KERNELOP):=ENDPROCESS1;
        KNCALL                  ;    KERNELCALL;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  ENTERPROC       ;  PROCEDURE ENTERPROC(STACKLENGTH,POPLENGTH,
                                ;                               LINE,VARLENGTH);
                                ;  BEGIN
ENPROC: MOV     S,X             ;    X:=S;
        SUB     HEAPTO,X        ;    X:-ST(HEAPTOP);
        CMP     X,(Q)+          ;    X COMPARE ST(Q); Q:+2;     "ERROR MESSAGE"
        BHIS    1$              ;    IF LESS<UNSIGNED> THEN     "WILL REFER TO"
        JMP     STACKL          ;      GOTO STACKLIMIT;         "LINE OF CALL"
1$:     MOV     G,-(S)          ;    S:-2; ST(S):=G;
        MOV     B,-(S)          ;    S:-2; ST(S):=B;
        TST     -(S)            ;    S:-2;
        MOV     S,(S)           ;          ST(S):=S;
        ADD     (Q)+,(S)        ;    ST(S):+ST(Q); Q:+2;
        MOV     (Q)+,-(S)       ;    S:-2; ST(S):=ST(Q); Q:+2;
        MOV     S,B             ;    B:=S;
        SUB     (Q)+,S          ;    S:-ST(Q); Q:+2;
        MOV     6(G),G          ;    G:=ST(G+6);
        CLR     JOB             ;    CLEAR ST(JOB);
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  EXITPROC        ;  PROCEDURE EXITPROC;
                                ;  BEGIN
EXPROC: MOV     B,S             ;    S:=B;
        TST     (S)+            ;    TEST ST(S); S:+2;
        MOV     (S)+,W          ;    W:=ST(S); S:+2;
        MOV     (S)+,B          ;    B:=ST(S); S:+2;
        MOV     (S)+,G          ;    G:=ST(S); S:+2;
        MOV     (S)+,Q          ;    Q:=ST(S); S:+2;
        MOV     W,S             ;    S:=W;
        INC     JOB             ;    INCREMENT ST(JOB);
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  POP             ;  PROCEDURE POP(LENGTH);
                                ;  BEGIN
POP:    ADD     (Q)+,S          ;    S:+ST(Q); Q:+2;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  NEWLINE         ;  PROCEDURE NEWLINE(NUMBER);
                                ;  BEGIN
NEWLIN: MOV     (Q)+,(B)        ;    ST(B):=ST(Q); Q:+2;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  INCRWORD        ;  PROCEDURE INCRWORD;
                                ;  BEGIN
INCWOR: INC     @(S)+           ;    INCREMENT ST(ST(S)); S:+2;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  DECRWORD        ;  PROCEDURE DECRWORD;
                                ;  BEGIN
DECWOR: DEC     @(S)+           ;    DECREMENT ST(ST(S)); S:+2;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  INITCLASS       ;  PROCEDURE INITCLASS(PARAMLENGTH,DISTANCE);
                                ;  BEGIN
INITCL: MOV     (Q)+,W          ;    W:=ST(Q); Q:+2;            "W=PARAMLENGTH"
        BEQ     2$              ;    IF NONZERO THEN
                                ;      BEGIN
        MOV     S,X             ;        X:=S;
        ADD     W,X             ;        X:+W;                 "X=S+PARAMLENGTH"
        MOV     (X),X           ;        X:=ST(X);
        TST     (X)+            ;        TEST ST(X); X:+2;     "X=CLASS ADDR+2"
        ASR     W               ;        HALVE W
1$:     MOV     (S)+,(X)+       ;        ITERATE W TIMES
                                ;        BEGIN
        SOB     W,1$            ;          ST(X):=ST(S); X:+2; S:+2;
                                ;        END;
                                ;      END;
2$:     MOV     Q,W             ;    W:=Q;
        ADD     (Q)+,W          ;    W:+ST(Q); Q:+2;
        MOV     Q,-(S)          ;    S:-2; ST(S):=Q;
        MOV     W,Q             ;    Q:=W;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  INITMON         ;  PROCEDURE INITMON(PARAMLENGTH,DISTANCE);
                                ;  BEGIN
INITMO= INITCL                  ;    "SAME AS INITCLASS"
                                ;  END;
                                ;
                                ;
        .SBTTL  INITPROC        ;  PROCEDURE INITPROC(PARAMLENGTH,VARLENGTH,
                                ;                         STACKLENGTH,DISTANCE);
                                ;  BEGIN
INITPR: MOV     #INITP1,OPCODE  ;    ST(KERNELOP):=INITPROCESS1;
        MOV     (Q)+,ARG1       ;    ST(KERNELARG1):=ST(Q); Q:+2;
        MOV     (Q)+,ARG2       ;    ST(KERNELARG2):=ST(Q); Q:+2;
        MOV     (Q)+,ARG3       ;    ST(KERNELARG3):=ST(Q); Q:+2;
        MOV     Q,ARG4          ;    ST(KERNELARG4):=Q;
        ADD     (Q)+,ARG4       ;    ST(KERNELARG4):+ST(Q); Q:+2;
        KNCALL                  ;    KERNELCALL;
        TST     (S)+            ;    TEST ST(S); S:+2;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  PUSHLABEL       ;  PROCEDURE PUSHLABEL(DISTANCE);
                                ;  BEGIN
PUSHLA: MOV     Q,-(S)          ;    S:-2; ST(S):=Q;
        ADD     (Q)+,(S)        ;    ST(S):+ST(Q); Q:+2;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  CALLPROG        ;  PROCEDURE CALLPROG;
                                ;  BEGIN
CALLPR: MOV     Q,W             ;    W:=Q;                      "W=OLD Q"
        MOV     (S),Q           ;    Q:=ST(S);                  "Q=CODE ADDR"
        TST     (Q)+            ;    TEST ST(Q); Q:+2;
        MOV     (Q)+,(S)        ;    ST(S):=ST(Q); Q:+2;        "ST(S)=CODELENG"
        ADD     #4.,Q           ;    Q:+4;                      "Q=CODEADDR+8"
        ADD     Q,(S)           ;    ST(S):+Q;                  "ST(S)=CONSTADR"
        MOV     W,-(S)          ;    S:-2; ST(S):=W;            "PUSH(OLD Q)"
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  TRUNCREAL       ;  PROCEDURE TRUNCREAL;
                                ;  BEGIN
TRUNCR:	.IF	DF,F$PU		;<01>
	LDD     (S)+,W          ;    W:=<REAL>ST(S); S:+8;
        STCDI   W,-(S)          ;    S:-2; ST(S):=TRUNC(W);
        BVC     1$              ;    IF OVERFLOW THEN
        JMP     OVERFL          ;      GOTO OVERFLOWERROR;
	.IFF			;<01>
	JSR	PC,$DI		;<01> CONVERT DOUBLE -> INTEGER
	.ENDC			;<01>	F$PU
1$:     NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  ABSWORD         ;  PROCEDURE ABSWORD;
                                ;  BEGIN
ABSWOR: TST     (S)             ;    TEST ST(S);
        BGE     1$              ;    IF NEGATIVE THEN
                                ;      BEGIN
        NEG     (S)             ;        ST(S):=-ST(S);
        BVC     1$              ;        IF OVERFLOW THEN
        JMP     OVERFL          ;          GOTO OVERFLOWERROR;
                                ;      END;
1$:     NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  ABSREAL         ;  PROCEDURE ABSREAL;
                                ;  BEGIN
ABSREA:	BIC	#100000,(S)	;<01>	SAVE A FEW MICRO-SECONDS
                                ;    ST(S):=ABS<REAL>(ST(S));
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  SUCCWORD        ;  PROCEDURE SUCCWORD;
                                ;  BEGIN
SUCCWO: INC     (S)             ;    INCREMENT ST(S);
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  PREDWORD        ;  PROCEDURE PREDWORD;
                                ;  BEGIN
PREDWO: DEC     (S)             ;    DECREMENT ST(S);
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  CONVWORD        ;  PROCEDURE CONVWORD;
                                ;  BEGIN
CONVWO:	.IF	DF,F$PU		;<01>
	LDCID   (S)+,W          ;    W:=CONV(ST(S)); S:+2;
        STD     W,-(S)          ;    S:-8; ST(S):=<REAL>W;
	.IFF			;<01>
	JSR	PC,$ID		;<01>
	.ENDC
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  EMPTY           ;  PROCEDURE EMPTY;
                                ;  BEGIN
EMPTY:  CLR     W               ;    CLEAR W;
        TST     (S)             ;    TEST ST(S);
        BNE     1$              ;    IF ZERO THEN
        INC     W               ;      INCREMENT W;
1$:     MOV     W,(S)           ;    ST(S):=W;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  ATTRIBUTE       ;  PROCEDURE ATTRIBUTE;
                                ;  BEGIN
ATTRIB: MOV     (S),W           ;    W:=ST(S);
        ASL     W               ;    DOUBLE W;
        MOV     HEAD(W),(S)     ;    ST(S):=ST(W+HEAD);
        NEXT                    ;  END;
                                ;
                                ;


        .SBTTL  REALTIME        ;  PROCEDURE REALTIME;
                                ;  BEGIN
REALTI: MOV     #REALT1,OPCODE  ;    ST(KERNELOP):=REALTIME1;
        KNCALL                  ;    KERNELCALL;
        MOV     ARG1,-(S)       ;    S:-2; ST(S):=ST(KERNELARG1);
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  DELAY           ;  PROCEDURE DELAY;
                                ;  BEGIN
DELAY:  MOV     #DELAY1,OPCODE  ;    ST(KERNELOP):=DELAYGATE1;
        MOV     (G),ARG1        ;    ST(KERNELARG1):=ST(G);
        MOV     (S)+,ARG2       ;    ST(KERNELARG2):=ST(S); S:+2;
        KNCALL                  ;    KERNELCALL;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  CONTINUE        ;  PROCEDURE CONTINUE;
                                ;  BEGIN
CONTIN: MOV     #CONTG1,OPCODE  ;    ST(KERNELOP):=CONTGATE1;
        MOV     (G),ARG1        ;    ST(KERNELARG1):=ST(G);
        MOV     (S)+,ARG2       ;    ST(KERNELARG2):=ST(S); S:+2;
        KNCALL                  ;    KERNELCALL;
        MOV     B,S             ;    S:=B;
        TST     (S)+            ;    TEST ST(S); S:+2;
        MOV     (S)+,W          ;    W:=ST(S); S:+2;
        MOV     (S)+,B          ;    B:=ST(S); S:+2;
        MOV     (S)+,G          ;    G:=ST(S); S:+2;
        MOV     (S)+,Q          ;    Q:=ST(S); S:+2;
        MOV     W,S             ;    S:=W;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  IO              ;  PROCEDURE IO;
                                ;  BEGIN
IO:     MOV     #IO1,OPCODE     ;    ST(KERNELOP):=IO1;
        MOV     (S)+,ARG3       ;    ST(KERNELARG3):=ST(S); S:+2;
        MOV     (S)+,ARG2       ;    ST(KERNELARG2):=ST(S); S:+2;
        MOV     (S)+,ARG1       ;    ST(KERNELARG1):=ST(S); S:+2;
        KNCALL                  ;    KERNELCALL;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  START           ;  PROCEDURE START;
                                ;  BEGIN
START:  MOV     #10.,CONT       ;    ST(CONTINUE):=10;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  STOP            ;  PROCEDURE STOP;
                                ;  BEGIN
STOP:   MOV     #STOPJ1,OPCODE  ;    ST(KERNELOP):=STOPJOB1;
        MOV     (S)+,ARG2       ;    ST(KERNELARG2):=ST(S); S:+2;
        MOV     (S)+,ARG1       ;    ST(KERNELARG1):=ST(S); S:+2;
        KNCALL                  ;    KERNELCALL;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  SETHEAP         ;  PROCEDURE SETHEAP;
                                ;  BEGIN
SETHEA: MOV     (S)+,HEAPTO     ;    ST(HEAPTOP):=ST(S); S:+2;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  WAIT            ;  PROCEDURE WAIT;
                                ;  BEGIN
WAIT:   MOV     #WAIT1,OPCODE   ;    ST(KERNELOP):=WAIT1;
        KNCALL                  ;    KERNELCALL;
        NEXT                    ;  END;
                                ;
                                ;
        .SBTTL  TERMINATED      ;TERMINATED:
TERMIN: MOV     #0,RESULT       ;  ST(RESULT):=0;
        JMP     EXCEPT          ;  GOTO EXCEPTION;
                                ;
                                ;
        .SBTTL  OVERFLOWERROR   ;OVERFLOWERROR:
OVERFL: MOV     #1,RESULT       ;  ST(RESULT):=1;
        JMP     EXCEPT          ;  GOTO EXCEPTION;
                                ;
                                ;
        .SBTTL  POINTERERROR    ;POINTERERROR:
POINER: MOV     #2,RESULT       ;  ST(RESULT):=2;
        JMP     EXCEPT          ;  GOTO EXCEPTION;
                                ;
                                ;
        .SBTTL  RANGEERROR      ;RANGEERROR:
RANGER: MOV     #3,RESULT       ;  ST(RESULT):=3;
        JMP     EXCEPT          ;  GOTO EXCEPTION;
                                ;
                                ;
        .SBTTL  VARIANTERROR    ;VARIANTERROR:
VARIER: MOV     #4,RESULT       ;  ST(RESULT):=4;
        JMP     EXCEPT          ;  GOTO EXCEPTION;
                                ;
                                ;
        .SBTTL  HEAPLIMIT       ;HEAPLIMIT:
HEAPLI: MOV     #5,RESULT       ;  ST(RESULT):=5;
        JMP     EXCEPT          ;  GOTO EXCEPTION;
                                ;
                                ;
        .SBTTL  STACKLIMIT      ;STACKLIMIT:
STACKL: MOV     #6,RESULT       ;  ST(RESULT):=6;
        JMP     EXCEPT          ;  GOTO EXCEPTION;
                                ;
                                ;
        .SBTTL  EXCEPTION       ;EXCEPTION:
EXCEPT: MOV     (B),LINE        ;  ST(LINE):=ST(B);
        TST     JOB             ;  TEST ST(JOB);
        BNE     1$              ;  IF ZERO THEN "INSYSTEM"
                                ;    BEGIN
        MOV     #SYSTE1,OPCODE  ;    ST(KERNELOP):=SYSTEMERROR;
        KNCALL                  ;      KERNELCALL;
        BR      2$              ;    END
                                ;  ELSE "IN JOB"
                                ;    BEGIN
1$:     MOV     G,B             ;      B:=G;
        MOV     B,S             ;      S:=B;
        TST     (S)+            ;      TEST ST(S); S:+2;
        MOV     (S)+,W          ;      W:=ST(S); S:+2;
        MOV     (S)+,B          ;      B:=ST(S); S:+2;
        MOV     (S)+,G          ;      G:=ST(S); S:+2;
        MOV     (S)+,Q          ;      Q:=ST(S); S:+2;
        MOV     W,S             ;      S:=W;
        CLR     JOB             ;      CLEAR ST(JOB);
2$:     NEXT                    ;  END;
                                ;
                                ;
	.TITLE DADD DOUBLE FLOATING ADD AND SUBTRACT
	.IF	NDF,F$PU			;<01>
	.GLOBL	$ADD,$SBD,OVERFL
;	$ADD  --- THE DOUBLE PRECISION ADD ROUT1INE
;	ADD THE TOP STACK ITEM TO THE SECOND ITEM
;	AND LEAVE THE SUM IN THEIR PLACE.
;	$SBD  --- THE DOUBLE PRECISION SUBTRACT ROUT1INE
;	SUBTRACT THE TOP STACK ITEM FROM THE SECOND ITEM
;	AND LEAVE THE DIFFERENCE IN PLACE OF THEM


	A1=6+10
	B1=8.+10
	C1=10.+10
	D1=12.+10
	A2=14.+10
	B2=16.+10
	C2=18.+10
	D2=20.+10
	SIGNS=0.




;ADD AND SUBTRACT TO STACK FROM STACK

SUD$SS:
$SBD:	ADD	#100000,2(SP)	;<01>	NEGATE TOP STACK ITEM
$ADD:
ADD$SS:
	POP	R0		;<01>	PUT RETURN ADDRESS IN R0
	PUSH	<R0,R1,R2,R3,R4,R5> ;<01> SAVE THE REGISTERS
	CLR	-(SP)		;CLEAR SIGNS
	CLR	R4		;CLEAR EXPONENTS
	CLR	R5
	ASL	D1(SP)		;SHIFT OUT1 SIGN OF TOP ITEM
	ROL	C1(SP)
	ROL	B1(SP)
	ROL	A1(SP)		;SHIFT A1
	BISB	A1+1(SP),R4	;GET E1
	BEQ	A1Z		;JUMP IF $ZERO
	ROLB	@SP		;GET S1
	ASL	D2(SP)		;SHIFT OUT1 SIGN OF SECOND ITEM
	ROL	C2(SP)
	ROL	B2(SP)
	ROL	A2(SP)		;SHIFT A2
	BISB	A2+1(SP),R5	;GET E2
	BNE	A2NZ		;JUMP IF NOT 0
	RORB	@SP		;RECONSTRUCT A1
	ROR	A1(SP)
	ROR	B1(SP)
	ROR	C1(SP)
	ROR	D1(SP)
	MOV	A1(SP),A2(SP)	;FIRST ARG TO TOP OF STACK
	MOV	B1(SP),B2(SP)
	MOV	C1(SP),C2(SP)
	MOV	D1(SP),D2(SP)
A1Z:	TST	(SP)+		;FLUSH SIGNS
	JMP	OUT1		;DONE
A2NZ:	ROLB	SIGNS+1(SP)   	;GET S2
	MOVB	#1,A2+1(SP)	;INSERT NORMAL BIT
	MOVB	#1,A1+1(SP)	;INSERT NORMAL BIT
	SUB	R4,R5		;R5=E2-E1, R4=E1
	BGT	EXPA		;JUMP IF E2>E1
	MOV	A2(SP),R0	;R0=A2
	MOV	B2(SP),R1	;R1=B2
	MOV	C2(SP),R2
	MOV	D2(SP),R3
	BR	SCHK		;GO CHECK SIGNS
EXPA:	ADD	R5,R4		;R5=E2-E1,R4=E2,E2>E1
	MOV	A1(SP),R0	;R0=A1
	MOV	B1(SP),R1	;R1=B1
	MOV	C1(SP),R2
	MOV	D1(SP),R3
	MOV	A2(SP),A1(SP)
	MOV	B2(SP),B1(SP)
	MOV	C2(SP),C1(SP)
	MOV	D2(SP),D1(SP)
	SWAB	@SP		;EXCHANGE SIGNS
	NEG	R5		;E1-E2
SCHK:	CMPB	SIGNS+1(SP),@SP	;COMPARE SIGNS
	BEQ	ECHK		;THEY'RE THE SAME. CHECK EXPONENT
	NEG	R3		;NEGATE OPERAND
	ADC	R2
	ADC	R1
	ADC	R0
	NEG	R2
	ADC	R1
	ADC	R0
	NEG	R1
	ADC	R0
	NEG	R0
ECHK:	TST	R5		;CHECK EXPONENTS
	BEQ	SHFT1D		;JUMP IF E1=E2
SHFT1:	CMP	#-57.,R5	;IS THERE ANY POINT IN SHIFTING?
	BLE	SHFTR		;YES
	MOV	A1(SP),R0	;NO, ANSWER IS OPERAND
	MOV	B1(SP),R1	;WITH THE LARGER EXPONENT
	MOV	C1(SP),R2
	MOV	D1(SP),R3
	BR	NORMD1
SHFTR:	CMP	#-8.,R5		;CHECK # OF BITS TO SHIFT
	BLE	SR8		;JUMP IF NOT MORE THAN 1/2 WORD
	TST	R0
	SXT	-(SP)		;EXTEND SIGN
SHFTR1:	CMP	#-16.,R5
	BLT	SR16		;JUMP IF NOT MORE THAN A WORD TO SHIFT
	MOV	R2,R3		;SHIFT A WORD AT A TIME
	MOV	R1,R2
	MOV	R0,R1
	MOV	@SP,R0		;USE EXTENSION
	ADD	#16.,R5		;ADJUST EXPONENT
	BNE	SHFTR1		;TRY AGAIN
	TST	(SP)+		;POP EXTENSION
	BR	SHFT1D		;SHIFT IS ALL DONE
SR16:	CMP	#-3,R5		;JUMP IF NOT MORE THAN 3 TO SHIFT
	BLE	SR8A
	MOV	R4,@SP		;SAVE EXP AND SHIFT COUNT
	MOV	R5,-(SP)
	MOV	R1,R4		;SAVE R1
	ASHC	R5,R0		;SHIFT HIGH ORDER
	MOV	R2,R5		;SAVE R2
	ASHC	@SP,R4		;SHIFT IT
	MOV	R2,R4
	MOV	R5,R2		;R2 DONE
	MOV	R3,R5		;SET UP LOW ORDER
	ASHC	(SP)+,R4	;DO LOW ORDER
	MOV	R5,R3
	MOV	(SP)+,R4	;RESTORE EXPONENT TO R4
	BR	SHFT1D
SR8A:	TST	(SP)+		;POP EXTENSION
SR8:	ASR	R0		;SHIFT RIGHT
	ROR	R1
	ROR	R2
	ROR	R3
	INC	R5		;COUNT LOOP
	BLT	SR8
SHFT1D:	ADD	D1(SP),R3	;FORM THE SUM
	ADC	R2
	ADC	R1
	ADC	R0
	ADD	C1(SP),R2
	ADC	R1
	ADC	R0
	ADD	B1(SP),R1
	ADC	R0
	ADD	A1(SP),R0
	CMPB	SIGNS+1(SP),@SP	;CHECK FOR UNEQUAL SIGNS
	BNE	SUB		;GO CLEAN UP SUBTRACT
	BIT	R0,#1000
	BEQ	NORMD1		;JUMP IF NO NORMAL BIT OVERFLOW
	ASR	R0
	ROR	R1
	ROR	R2
	ROR	R3
	INC	R4		;INCREASE EXPONENT
NORMD1:	SWAB	R4		;MOVE EXPONENT LEFT
	BNE	OVER1F		;JUMP IF OVERFLOW
NFLOW:	BISB	R0,R4		;INSERT HIGH ORDER FRACTION
	ROR	(SP)+		;INSERT SIGN
	ROR	R4
	ROR	R1
	ROR	R2
	ROR	R3
	ADC	R3
	ADC	R2
	ADC	R1
	ADC	R4
	BVS	OVER1		;JUMP IF OVERFLOW ON ROUND
	BCS	OVER1
	MOV	R4,A2+0-2(SP)	;STORE EXPONENT AND SIGN
	MOV	R1,B2+0-2(SP)	;INSERT LOW ORDER FRACTION
	MOV	R2,C2+0-2(SP)
	MOV	R3,D2+0-2(SP)
OUT1:	POP	<R5,R4,R3,R2,R1,R0>
	ADD	#8.,SP		;POP SECOND ARGUMENT
	JMP	@R0		;<01>	RETURN

OVER1F:	TST	(SP)+		;POP SIGN

OVER1:	POP	<R5,R4,R3,R2,R1,R0> ;<01> UNSAVE REGISTERS
	ADD	#8.,SP		;<01> 	POP 1ST OPD
	JMP	OVERFL

UTEST:	TST	R4		;CHECK FOR UNDERFLOW
	BGT	NORMD1
UNDERF:				;<01>	UNDERFLOW!
UNDER:	CLR	R0
	CLR	R1		;UNDERFLOW. TREAT AS 0
	CLR	R2
	CLR	R3
$ZERO:	CLR	@SP		;SET SIGN PLUS
	CLR	R4
	BR	NFLOW		;FINISH OUT1 NORMALLY

SUB:	TST	R0		;CHECK HIGH ORDER RESULT FRACTION
	BGT	BIT9		;IF POSITIVE SIGN IS OK
	BEQ	ZTEST		;CHECK FOR $ZERO RESULT
	NEG	R3		;GET ABSOLUTE VALUE
	ADC	R2
	ADC	R1
	ADC	R0
	NEG	R2
	ADC	R1
	ADC	R0
	NEG	R1
	ADC	R0
	SWAB	@SP		;EXCHANGE SIGNS
	NEG	R0
	BEQ	ZTEST		;CHECK FOR $ZERO RESULT
BIT9:
BIT9A:	BIT	R0,#400		;CHECK NORMAL BIT
	BNE	UTEST		;JUMP IF FOUND
	DEC	R4		;DECREASE EXPONENT
	ASL	R3		;DOUBLE FRACTION
	ROL	R2
	ROL	R1
	ROL	R0
	BR	BIT9A		;TRY AGAIN
ZTEST:	SUB	#8.,R4		;REDUCE EXPONENT
	TST	R1
	BNE	ZT1		;JUMP IF ONLY R0=0
	SUB	#16.,R4
	MOV	R2,R1
	BNE	ZT2		;JUMP IF R2 NOT 0
	SUB	#16.,R4
	TST	R3
	BEQ	$ZERO		;ANSWER IS 0
	BISB	R3,R1		;MOVE BYTES TO R0,R1
	SWAB	R1
	SWAB	R3
	BISB	R3,R0
	CLR	R3		;MAKE ALL OTHERS 0
	BR	BIT9		;GO NORMALIZE
ZT2:	MOV	R3,R2
	CLR	R3
ZT1:	SWAB	R1		;MOVE ALL BYTES LEFT
	BISB	R1,R0
	CLRB	R1
	SWAB	R2
	BISB	R2,R1
	CLRB	R2
	SWAB	R3
	BISB	R3,R2
	CLRB	R3
	BR	BIT9		;GO NORMALIZE WHAT'S LEFT

	.ENDC
	.TITLE DMUL DOUBLE FLOATING MULTIPLIES
	.IF	NDF,F$PU	;<01>
	.GLOBL	$MLD,OVERFL
;	$MLD     THE DOUBLE MULTIPLY ROUTINE
;	CALLED IN POLISH MODE.
;	REPLACES THE TOP TWO DOUBLES ON THE STACK 
;	WITH THEIR PRODUCT.


	A=8.+10
	B=16.+10
	RESLT=12.+10
	$SIGN=2
;MULTIPLY STACK AND STACK

$MLD:
MUD$SS:
	POP	R0		;<01>	POP RETURN TO R0
	PUSH	<R0,R1,R2,R3,R4,R5> ;<01> SAVE THE REGISTERS
	ASL	A+0-4(SP)	;SHIFT MULTIPLICAND
	ROL	-(SP)		;KEEP $SIGN
	CLR	-(SP)		;CLEAR EXPONENT
	MOVB	A+1(SP),@SP	;KEEP MULTIPLICAND EXPONENT
	BEQ	$ZERO1		;JUMP IF ANSWER IS $ZERO1
	MOVB	A(SP),A+1(SP)	;SHIFT FRACTION LEFT
	SEC			;INSERT NORMAL BIT
	ROR	A(SP)
	MOVB	A+3(SP),A(SP)
	SWAB	A+2(SP)
	MOVB	A+5(SP),A+2(SP)
	SWAB	A+4(SP)
	MOVB	A+7(SP),A+4(SP)
	SWAB	A+6(SP)
	CLRB	A+6(SP)		;MAKE ROOM FOR EXTRA BITS
	ASL	B(SP)		;SHIFT HIGH MULTIPLIER
	ADC	$SIGN(SP)	;GET PRODUCT $SIGN
	TSTB	B+1(SP)
	BNE	NONZ		;JUMP IF NOT $ZERO1
$ZERO1:	CMP	(SP)+,(SP)+	;FLUSH $SIGN AND EXPONENT
ZERO11:	JMP	ZERO12
NONZ:	CLR	R0		;CLEAR PRODUCT
	CLR	R1
	CLR	R4
	BISB	B+1(SP),R4	;GET EXPONENT
	ADD	R4,@SP		;GET SUM OF EXPONENTS
	MOVB	#1,B+1(SP)	;INSERT NORMAL BIT
	ROR	B(SP)
	SWAB	B(SP)		;LEFT JUSTIFY FRACTION
	MOVB	B+3(SP),B(SP)
	SWAB	B+2(SP)
	MOVB	B+5(SP),B+2(SP)
	SWAB	B+4(SP)
	MOVB	B+7(SP),B+4(SP)
	SWAB	B+6(SP)
	CLRB	B+6(SP)
	MOV	A(SP),-(SP)
	MOV	B+6+2(SP),R4	;GET A1*B4
	JSR	PC,EMULT
	MOV	R4,R2		;RESULT TO PRODUCT
	MOV	R5,R3
	MOV	A+2(SP),-(SP)
	MOV	B+4+2(SP),R4	;GET A2*B3
	JSR	PC,EMULT
	ADD	R4,R2		;ADD TO PRODUCT
	ADC	R1
	ADD	R5,R3
	ADC	R2
	ADC	R1
	MOV	A+4(SP),-(SP)
	MOV	B+2+2(SP),R4	;GET A3*B2
	JSR	PC,EMULT
	ADD	R4,R2
	ADC	R1
	ADD	R5,R3
	ADC	R2
	ADC	R1
	MOV	A+6(SP),-(SP)
	MOV	B+0+2(SP),R4	;GET A4*B1
	JSR	PC,EMULT
	ADD	R4,R2
	ADC	R1
	ADD	R5,R3
	ADC	R2
	ADC	R1
	MOV	R2,R3		;DIVIDE BY 2**16
	MOV	R1,R2
	CLR	R1
	MOV	A(SP),-(SP)
	MOV	B+4+2(SP),R4	;GET A1*B3
	JSR	PC,EMULT
	ADD	R4,R2
	ADC	R1
	ADD	R5,R3
	ADC	R2
	ADC	R1
	MOV	A+2(SP),-(SP)
	MOV	B+2+2(SP),R4	;GET A2*B2
	JSR	PC,EMULT
	ADD	R4,R2
	ADC	R1
	ADD	R5,R3
	ADC	R2
	ADC	R1
	MOV	A+4(SP),-(SP)
	MOV	B+0+2(SP),R4	;GET A3*B1
	JSR	PC,EMULT
	ADD	R4,R2
	ADC	R1
	ADD	R5,R3
	ADC	R2
	ADC	R1
	MOV	A(SP),-(SP)
	MOV	B+2+2(SP),R4	;GET A1*B2
	JSR	PC,EMULT
	ADD	R4,R1
	ADC	R0
	ADD	R5,R2
	ADC	R1
	ADC	R0
	MOV	A+2(SP),-(SP)
	MOV	B+0+2(SP),R4	;GET A2*B1
	JSR	PC,EMULT
	ADD	R4,R1
	ADC	R0
	ADD	R5,R2
	ADC	R1
	ADC	R0
	MOV	A(SP),-(SP)
	MOV	B+0+2(SP),R4	;GET A1*B1
	JSR	PC,EMULT
	ADD	R4,R0
	ADD	R5,R1
	ADC	R0
	MOV	(SP)+,R4	;GET SUM OF EXPONENTS
	ASL	R3		;SHIFT OUT NORMAL BIT
	ROL	R2
	ROL	R1
	ROL	R0
	BCS	NORM2		;JUMP IF IT WAS FOUND
	ASL	R3
	ROL	R2
	ROL	R1
	ROL	R0		;MUST HAVE GOT IT NOW
	DEC	R4		;ADJUST EXPONENT
NORM2:	SUB	#200,R4		;TAKE OUT ONE OF THE EXCESS 128'S
	BLE	UNDER2		;JUMP IF UNDERFLOW
	CMP	#377,R4
	BLT	OVER2		;JUMP IF OVERFLOW
	CLRB	R3
	BISB	R2,R3		;SHIFT FRACTION RIGHT
	SWAB	R3
	CLRB	R2
	BISB	R1,R2
	SWAB	R2
	CLRB	R1
	BISB	R0,R1
	SWAB	R1
	CLRB	R0
	BISB	R4,R0
	SWAB	R0
	ROR	(SP)+		;GET PRODUCT $SIGN
	ROR	R0		;INSERT IT IN RESULT
	ROR	R1
	ROR	R2
	ROR	R3
	ADC	R3		;ROUND RESULT
	ADC	R2
	ADC	R1
	ADC	R0
	BCS	OVER21		;JUMP IF OVERFLOW ON ROUND
	BVS	OVER21
OUT:	MOV	R0,RESLT(SP)	;PUT OUT ANSWER
	MOV	R1,RESLT+2(SP)
	MOV	R2,RESLT+4(SP)
	MOV	R3,RESLT+6(SP)
	POP	<R5,R4,R3,R2,R1,R0> ;<01> UNSAVE REGISTERS
	ADD	#8.,SP		;FLUSH TOP ARGUMENT
	JMP	@R0		;<01> AND RETURN



OVER21:	TST	-(SP)		;FAKE $SIGN
OVER2:	TST	(SP)+		;GET RID OF SIGN
	POP	<R5,R4,R3,R2,R1,R0> ;<01> UNSAVE REGISTERS
	ADD	#8.,SP		;<01> POP OPD 1
	JMP	OVERFL	;<01> CEASE EXECUTION


UNDER2:
ECALL2:	TST	(SP)+		;FLUSH $SIGN
ZERO12:	CLR	R0		;CLEAR HIGH ORDER RESULT
	CLR	R1		;CLEAR LOW ORDER
	CLR	R2
	CLR	R3
	BR	OUT
EMULT:	CLR	-(SP)		;CLEAR HIGH PRODUCT
	TST	R4		;TEST MULTIPLICAND
	BEQ	MZ		;JUMP IF 0
	BGT	MPLUS		;+
	TST	4(SP)		;TEST MULTIPLIER
	BEQ	MZ		;JUMP IF 0
	BGT	MNEG1		;+
	BR	MNEG
MPLUS:	TST	4(SP)		;TEST MULTIPLIER
	BEQ	MZ		;JUMP IF 0
	BGT	MLTQ		;+
	ADD	R4,@SP
	BR	MLTQ
MNEG:	ADD	R4,@SP
MNEG1:	ADD	4(SP),@SP
MLTQ:	MUL	4(SP),R4	;GET PRODUCT
MDONE:	ADD	(SP)+,R4	;ADD IN HIGH ORDER PARTS
	MOV	(SP)+,@SP	;FLUSH MULTIPLIER
	RTS	PC		;RETURN
MZ:	CLR	R4		;RESULT IS 0
	CLR	R5
	BR	MDONE
	.ENDC
	.TITLE DDIV DOUBLE FLOATING DIVIDE
	.IF	NDF,F$PU		;<01>
	.GLOBL	$DVD,OVERFL

;	$DVD --- THE DOUBLE DIVIDE ROUT3INE
;	CALLED IN THE POLISH MODE
;	THE NUMERATOR IS THE SECOND ITEM ON THE STACK
;	AND THE DENOMINATOR IS ON TOP.
;	TAKES THE QUOTIENT AND PUTS IT ON TOP
;	OF THE STACK IN THEIR PLACE


	D=8.+10
	N=16.+10
	Q=16.+10



$DVD:
	POP	R0		;<01> POP RETURN @ TO R0
	PUSH	<R0,R1,R2,R3,R4,R5> ;<01> SAVE THE REGISTERS
	CLR	R0
	CLR	R1
	CLR	R2
	CLR	R3
	CLR	-(SP)
	ASL	N+0-2(SP)	;SHIFT NUMERATOR
	ROL	@SP		;GET NUMERATOR SIGN
	CLR	-(SP)
	TST	D(SP)		;CHECK FOR 0.0 DENOMINATOR
	BEQ	DCHK		;JUMP TO ERROR EXIT
	BISB	N+1(SP),@SP	;GET NUMERATOR EXPONENT
	BEQ	$$ZERO		;JUMP IF NUMERATOR IS $$ZERO
	BISB	N(SP),R0
	SWAB	R0		;LEFT JUSTIFY NUMERATOR FRACTION
	SEC			;INSERT NORMAL BIT
	ROR	R0
	BISB	N+3(SP),R0
	BISB	N+2(SP),R1
	SWAB	R1
	BISB	N+5(SP),R1
	BISB	N+4(SP),R2
	SWAB	R2
	BISB	N+7(SP),R2
	BISB	N+6(SP),R3
	SWAB	R3
	ASL	D(SP)		;SHIFT DENOMINATOR
	ADC	2(SP)		;GET RESULT SIGN
	CLR	R4
	BISB	D+1(SP),R4	;GET DIVISOR EXPONENT
	SUB	R4,@SP		;SUBTRACT EXPONENTS
	SWAB	D(SP)		;LEFT JUSTIFY DENOMINATOR
	SEC			;INSERT NORMAL BIT
	ROR	D(SP)
	MOVB	D+3(SP),D(SP)
	MOVB	D+2(SP),D+3(SP)
	MOVB	D+5(SP),D+2(SP)
	MOVB	D+4(SP),D+5(SP)
	MOVB	D+7(SP),D+4(SP)
	MOVB	D+6(SP),D+7(SP)
	CLRB	D+6(SP)
	CLR	Q(SP)		;CLEAR QUOTIENT
	CLR	Q+2(SP)
	CLR	Q+4(SP)
	CMP	R0,D(SP)	;COMPARE HIGH NUM. AND DEN.
	BHI	DLOW		;JUMP IF DENOMINATOR LOW
	BLO	DHI		;JUMP IF DENOMINATOR HIGH
	CMP	R1,D+2(SP)	;COMPARE LOW ORDER PARTS
	BHI	DLOW
	BLO	DHI
	CMP	R2,D+4(SP)
	BHI	DLOW
	BLO	DHI
	CMP	R3,D+6(SP)
	BHI	DLOW
	BNE	DHI
	INC	@SP		;BUMP EXPONENT
	CLR	R4
	BR	FLOAT
DCHK:	JMP	OVERFL	;$$ZERO DIVIDE => OVERFLOW!
	BR	$ECLL
UNDER3:
ECALL3:	TST	-(SP)		;FAKE SIGN
$ECLL:
$$ZERO:	CMP	(SP)+,(SP)+	;FLUSH EXP AND SIGN
	CLR	Q+0-4(SP)
	CLR	Q+2-4(SP)
	CLR	Q+4-4(SP)
	CLR	Q+6-4(SP)
	BR	$RTN
DLOW:	ROR	R0		;HALVE DENOMINATOR  (C=0)
	ROR	R1		;TO ENSURE THAT N<D
	ROR	R2
	ROR	R3
	INC	@SP		;COMPENSATE EXPONENT
DHI:	MOV	#9.,R5		;GO DO FIRST 9 QUOTIENT BITS
	JSR	PC,DIV1
	MOVB	R4,Q(SP)	;SAVE ALL HIGH ORDER Q FRACTION
				;EXCEPT NORMAL BIT
	TST	R5		;SEE IF DONE
	BNE	FLOAT1		;YES, REST OF NUMERATOR IS 0
	MOV	#16.,R5		;GO DO 16 MORE BITS
	JSR	PC,DIV1
	MOV	R4,Q+2(SP)
	TST	R5
	BNE	FLOAT1
	MOV	#16.,R5
	JSR	PC,DIV1
	MOV	R4,Q+4(SP)
	TST	R5
	BNE	FLOAT1
	MOV	#16.,R5
	JSR	PC,DIV1
	BR	FLOAT
FLOAT1:	CLR	R4		;CLEAR LOWEST ORDER QUOTIENT
FLOAT:	MOV	(SP)+,R5	;PUSH UP EXPONENT
	ADD	#200,R5		;ADD IN EXCESS 200
	BLE	UNDER3		;UNDER3FLOW
	CMP	#377,R5
	BLT	OVER3		;OVERFLOW
	MOVB	R5,Q+1-2(SP)	;INSERT EXPONENT IN RESLT
SIGN:	ROR	(SP)+		;INSERT QUOTIENT SIGN
	ROR	Q+0-4(SP)
	ROR	Q+2-4(SP)
	ROR	Q+4-4(SP)
	ROR	R4
	ADC	R4		;ROUND
	ADC	Q+4-4(SP)
	ADC	Q+2-4(SP)
	ADC	Q+0-4(SP)
	MOV	R4,Q+6-4(SP)	;INSERT LOW ORDER FRACTION
	BCS	OVER31
	BVS	OVER31

$RTN:	POP	<R5,R4,R3,R2,R1,R0> ;<01>
	ADD	#8.,SP		;FLUSH FIRST ARGUMENT
	JMP	@R0		;<01> RETURN

OVER31:	TST	-(SP)		;FAKE EXP
OVER3:
	TST	(SP)+		;<01> POP GARBAGE WORD
	POP	<R5,R4,R3,R2,R1,R0> ;<01> POP REGISTERS
	JMP	OVERFL	;<01> JUMP TO ERROR HANDLER

DIV1:	ASL	R4		;SHIFT QUOTIENT
	ASL	R3		;SHIFT NUMERATOR
	ROL	R2
	ROL	R1
	ROL	R0
	BCS	GO		;GUARANTEED TO GO
	CMP	D+0+2(SP),R0	;COMPARE HIGH DIVISOR AND DIVIDEND
	BHI	NOGO		;JUMP IF DIVISOR BIGGER
	BLO	GO		;JUMP IF DIVISOR SMALLER
	CMP	D+2+2(SP),R1	;CHECK THE LOW ORDERS
	BHI	NOGO
	BLO	GO
	CMP	D+4+2(SP),R2
	BHI	NOGO
	BLO	GO
	CMP	D+6+2(SP),R3
	BHI	NOGO
	BEQ	NEQD		;JUMP IF NUMERATOR =DENOMINATOR
GO:	SUB	D+6+2(SP),R3	;N=N-D
	SBC	R2
	SBC	R1
	SBC	R0
	SUB	D+4+2(SP),R2
	SBC	R1
	SBC	R0
	SUB	D+2+2(SP),R1
	SBC	R0
	SUB	D+0+2(SP),R0
	INC	R4		;INSERT QUOTIENT BIT
NOGO:	DEC	R5		;COUNT LOOP
	BGT	DIV1
	RTS	PC
NEQD:	INC	R4		;INSERT LAST 1 BIT IN QUOTIENT
	BR	EQ1
EQ2:	ASL	R4		;FINISH OUT3 QUOTIENT WITH 0'S
EQ1:	DEC	R5
	BGT	EQ2
	INC	R5		;FLAG NO MORE NUMERATOR
RTS:	RTS	PC		;RETURN TO CALLER

	.ENDC
	.TITLE CMPD THE DOUBLE COMPARE ROUTINES
	.IF	NDF,F$PU	;<01>
;	H.J.

	.GLOBL	$DCMP

;DOUBLE COMPARE ROUTINE.  UPON EXIT THE
;CONDITION CODES WILL BE SET FOR THE SIGNED BRANCHES

$DCMP:
CMD$SS:	MOV	(SP),-(SP)	;<01> MAKE ROOM FOR PSW
	PUSH	<R0,R1,R3>	;<01> SAVE REGS USED
	MOV	SP,R1		;ADDR OF ARG 2
	MOV	SP,R0
	ADD	#18.,R0		;<01> ADDR OF ARG 1
CMDIS:	ADD	#10.,R1		;<01> ADJUST ADDR OF ARG2


COMP:	MOV	@R0,R3
	BIS	@R1,R3		;SET UP N BIT SAYING EITHER WAS NEGATIVE
	CMP	(R0)+,(R1)+	;ARE HIGH PARTS EQUAL
	BNE	1$
	CMP	(R0)+,(R1)+	;CHECK REST  TO SET C BIT
	BNE	1$
	CMP	(R0)+,(R1)+
	BNE	1$
	CMP	@R0,@R1		;LOW PARTS
	BNE	1$		;GO HANDLE NOT EQUAL CASE, C BIT

	CLR	R3		;SET CONDITION CODES
	BR	$XIT		;<01> DONE, EXIT

;AT THIS POINT THE C BIT SAYS WHETHER OPERAND 1 WAS BIGGER
;OR NOT THAN OPERAND 2 IN UNSIGNED MODE.  C SET IF 1ST SMALLER

1$:	ROR	R3		;GETS C AND N BITS TOGETHER
	ROL	R3		;SET V BIT ON FINAL RESULT
	.WORD	CLN!CLZ		;DONT WANT N OR Z TO INTERFERE
$XIT:
	GETPSW	10(SP)		;<01> PUT PSW IN STACK
	POP	<R3,R1,R0>	;<01> POP REGS
	MOV	2(SP),22(SP)	;<01> PUT PSW IN PLACE
	MOV	0(SP),20(SP)	;<01> PUT PC IN PLACE
	ADD	#20,SP		;<01> SP -> NEW PC
	RTI			;<01> AND RETURN
	.ENDC			;<01>
	.SBTTL CONVERT TO INTEGER
	.IF	NDF,F$PU	;<01>
	.GLOBL	$DI
	.GLOBL	OVERFL					;<01> OVERFLOW LABEL
;	REAL TO INTEGER CONVERSION.
;	ARGUMENT IS A DOUBLE WORD REAL NUMBER ON THE TOP
;	OF THE STACK.
;	TRUNCATE IT AND CONVERT IT TO AN INTEGER ON THE
;	TOP OF THE STACK.

CLC$:
CLD$:
CIC$:
CID$:
$DI:	POP	R0		;<01> POP RETURN TO R0
	MOV	(SP)+,2(SP)	;TRUNCATE TO REAL FORMAT
	MOV	(SP)+,2(SP)
CLF$:
CIF$:
$RI:	CLR	R2		;CLEAR WORK SPACE
	INC	R2		;SET UP NORMAL BIT
	MOV	(SP)+,R1	;GET REAL ARGUMENT
	ROL	@SP		;GET SIGN
	ROL	R1		;AND
	PUSH	<R3,R2>		;<01> SAVE REGISTERS (NOTE: C-BIT UNAFFECTED!)
	ROL	-(SP)		;SAVE IT
	MOVB	R1,R3		;GET HIGH ORDER FRACTION
	CLRB	R1
	SWAB	R1		;GET EXPONENT
	SUB	#201,R1
	BLT	.ZERO		;JUMP IF IT IS TOO SMALL
	BEQ	DONE
	CMP	#15.,R1
	BLT	OVER4		;JUMP IF IT IS TOO BIG
	SWAB	R3		;FORM 16 BITS OF HIGH ORDER FRACTION
	CLRB	R3
	BISB	7(SP),R3
SHFT4:
	ASHC	R1,R2		;SHIFT 
DONE:	NEG	R2		;MAKE -
	BVS	NEGM		;JUMP IF POSSIBLE NEGMAX
	BGT	OVER4		;JUMP IF MORE THAN 15 BITS
SIGN4:	ROR	(SP)+		;GET SIGN
	BCS	OUT4		;JUMP IF -
	NEG	R2		;- RESULT
OUT4:	MOV	R2,4(SP)	;<01> STORE INTEGER RESULT
	POP	<R2,R3>		;<01> RESTORE SACRED REGISTERS
	JMP	@R0		;RETURN TO CALLER
NEGM:	ROR	(SP)+
	BCS	OUT4		;OK IF RESULT TO BE -
	TST	-(SP)		;<01> FAKE OUT STACK
OVER4:
	TST	(SP)+		;<01> POP SIGN
	POP	<R2,R3>		;<01> RESTORE REGISTERS
	JMP	OVERFL		;<01> ERROR, INT OVERFLOW
.ZERO:	CLR	R2		;ANSWER IS 0
	BR	SIGN4
	.ENDC			;<01>

	.SBTTL CONVERT FROM INTEGER TO DOUBLE
	.IF	NDF,F$PU	;<01>
	.GLOBL	$ID

;	INTEGER TO REAL CONVERSION.
;	ARGUMENT IS A FULL WORD ON THE TOP OF THE STACK
;	CONVERT IT TO REAL FORMAT AND RETURN IT AS THE TOP
;	TWO WORDS ON THE STACK.


CCI$:
CDI$:
$IC:
$ID:	POP	R0		;<01> PUT RETURN ADDRESS IN R0
	MOV	@SP,-(SP)	;PUSH ARGUMENT DOWN
	MOV	@SP,-(SP)
	CLR	2(SP)		;CLEAR LOWEST ORDER DOUBLE
	CLR	4(SP)
CFI$:
$IR:	CLR	-(SP)		;MAKE ROOM FOR RESULT
	MOV	2(SP),R1	;GET INTEGER ARGUMENT
	BGT	POS
	BEQ	..ZERO
	NEG	R1		;GET ABSOLUTE VALUE
POS:	ROL	-(SP)		;SAVE SIGN
	MOV	#220,R2		;GET MAX. POSSIBLE EXPONENT +1
	CLRB	4(SP)		;CLEAR LOWEST ORDER FRACTION
NORM5:
	ROL	R1		;LOOK FOR NORM5AL BIT
	BCS	NORM5D		;JUMP IF FOUND
	DEC	R2		;DECREASE EXPONENT
	BR	NORM5		;TRY AGAIN
NORM5D:	MOVB	R1,5(SP)	;SAVE LOW ORDER FRACTION
	CLRB	R1
	BISB	R2,R1		;COMBINE EXPONENT AND HIGH ORDER FRACTION
	SWAB	R1
	ROR	(SP)+		;GET SIGN
	ROR	R1		;INSERT SIGN IN RESULT
	RORB	3(SP)
	MOV	R1,@SP		;OUTPUT RESULT
..ZERO:	JMP	@R0

	.ENDC			;<01>
.SBTTL	END
INTEND:
...	=	INTEND - ZERO			;LENGTH OF KERNEL
...	=	...+511/512			;# BLOCKS
	.END
